var Rs=Object.defineProperty;var Zn=e=>{throw TypeError(e)};var Ds=(e,t,n)=>t in e?Rs(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n;var u=(e,t,n)=>Ds(e,typeof t!="symbol"?t+"":t,n),Ns=(e,t,n)=>t.has(e)||Zn("Cannot "+n);var _t=(e,t,n)=>(Ns(e,t,"read from private field"),n?n.call(e):t.get(e)),jn=(e,t,n)=>t.has(e)?Zn("Cannot add the same private member more than once"):t instanceof WeakSet?t.add(e):t.set(e,n);const lu=Symbol.for("@libp2p/connection"),du=Symbol.for("@libp2p/content-routing");class Ts extends Error{constructor(t="The operation was aborted"){super(t),this.name="AbortError"}}u(Ts,"name","AbortError");class Cs extends Error{constructor(t="Unexpected Peer"){super(t),this.name="UnexpectedPeerError"}}u(Cs,"name","UnexpectedPeerError");class Ks extends Error{constructor(t="Invalid crypto exchange"){super(t),this.name="InvalidCryptoExchangeError"}}u(Ks,"name","InvalidCryptoExchangeError");class lt extends Error{constructor(t="Invalid parameters"){super(t),this.name="InvalidParametersError"}}u(lt,"name","InvalidParametersError");class En extends Error{constructor(t="Invalid public key"){super(t),this.name="InvalidPublicKeyError"}}u(En,"name","InvalidPublicKeyError");class An extends Error{constructor(t="Invalid private key"){super(t),this.name="InvalidPrivateKeyError"}}u(An,"name","InvalidPrivateKeyError");class Os extends Error{constructor(t="The connection is closed"){super(t),this.name="ConnectionClosedError"}}u(Os,"name","ConnectionClosedError");class Ms extends Error{constructor(t="Connection failed"){super(t),this.name="ConnectionFailedError"}}u(Ms,"name","ConnectionFailedError");class ks extends Error{constructor(t="The muxer is closed"){super(t),this.name="MuxerClosedError"}}u(ks,"name","MuxerClosedError");class Ps extends Error{constructor(t="The stream has been reset"){super(t),this.name="StreamResetError"}}u(Ps,"name","StreamResetError");class $s extends Error{constructor(t="The stream is in an invalid state"){super(t),this.name="StreamStateError"}}u($s,"name","StreamStateError");class Vs extends Error{constructor(t="The stream buffer was full"){super(t),this.name="StreamBufferError"}}u(Vs,"name","StreamBufferError");class Hs extends Error{constructor(t="Not found"){super(t),this.name="NotFoundError"}}u(Hs,"name","NotFoundError");class qs extends Error{constructor(t="Invalid PeerID"){super(t),this.name="InvalidPeerIdError"}}u(qs,"name","InvalidPeerIdError");class Fs extends Error{constructor(t="Invalid multiaddr"){super(t),this.name="InvalidMultiaddrError"}}u(Fs,"name","InvalidMultiaddrError");class zs extends Error{constructor(t="Invalid CID"){super(t),this.name="InvalidCIDError"}}u(zs,"name","InvalidCIDError");class Zs extends Error{constructor(t="Invalid Multihash"){super(t),this.name="InvalidMultihashError"}}u(Zs,"name","InvalidMultihashError");class js extends Error{constructor(t="Unsupported protocol error"){super(t),this.name="UnsupportedProtocolError"}}u(js,"name","UnsupportedProtocolError");class Gs extends Error{constructor(t="Invalid message"){super(t),this.name="InvalidMessageError"}}u(Gs,"name","InvalidMessageError");class Ys extends Error{constructor(t="Protocol error"){super(t),this.name="ProtocolError"}}u(Ys,"name","ProtocolError");class Xs extends Error{constructor(t="Timed out"){super(t),this.name="TimeoutError"}}u(Xs,"name","TimeoutError");class Ws extends Error{constructor(t="Not started"){super(t),this.name="NotStartedError"}}u(Ws,"name","NotStartedError");class Js extends Error{constructor(t="Dial error"){super(t),this.name="DialError"}}u(Js,"name","DialError");class Qs extends Error{constructor(t="Listen error"){super(t),this.name="ListenError"}}u(Qs,"name","ListenError");class ti extends Error{constructor(t="Limited connection"){super(t),this.name="LimitedConnectionError"}}u(ti,"name","LimitedConnectionError");class ei extends Error{constructor(t="Too many inbound protocol streams"){super(t),this.name="TooManyInboundProtocolStreamsError"}}u(ei,"name","TooManyInboundProtocolStreamsError");class ni extends Error{constructor(t="Too many outbound protocol streams"){super(t),this.name="TooManyOutboundProtocolStreamsError"}}u(ni,"name","TooManyOutboundProtocolStreamsError");class ye extends Error{constructor(t="Unsupported key type"){super(t),this.name="UnsupportedKeyTypeError"}}u(ye,"name","UnsupportedKeyTypeError");class bu extends Event{constructor(n,r){super("message",r);u(this,"data");this.data=n}}class Br extends Event{constructor(n,r,s){super("close",s);u(this,"error");u(this,"local");this.error=r,this.local=n}}class yu extends Br{constructor(t,n){super(!0,t,n)}}class wu extends Br{constructor(t,n){super(!1,t,n)}}const gu=Symbol.for("@libp2p/peer-discovery"),ri=Symbol.for("@libp2p/peer-id");function pu(e){return!!e?.[ri]}const mu=Symbol.for("@libp2p/peer-routing"),xu="keep-alive";function vr(e){return e!=null&&typeof e.start=="function"&&typeof e.stop=="function"}async function Eu(...e){const t=[];for(const n of e)vr(n)&&t.push(n);await Promise.all(t.map(async n=>{n.beforeStart!=null&&await n.beforeStart()})),await Promise.all(t.map(async n=>{await n.start()})),await Promise.all(t.map(async n=>{n.afterStart!=null&&await n.afterStart()}))}async function Au(...e){const t=[];for(const n of e)vr(n)&&t.push(n);await Promise.all(t.map(async n=>{n.beforeStop!=null&&await n.beforeStop()})),await Promise.all(t.map(async n=>{await n.stop()})),await Promise.all(t.map(async n=>{n.afterStop!=null&&await n.afterStop()}))}const Su=Symbol.for("@libp2p/transport");var Gn;(function(e){e[e.FATAL_ALL=0]="FATAL_ALL",e[e.NO_FATAL=1]="NO_FATAL"})(Gn||(Gn={}));function Bu(){}var pt;class vu extends EventTarget{constructor(){super();jn(this,pt,new Map)}listenerCount(n){const r=_t(this,pt).get(n);return r==null?0:r.length}addEventListener(n,r,s){super.addEventListener(n,r,s);let i=_t(this,pt).get(n);i==null&&(i=[],_t(this,pt).set(n,i)),i.push({callback:r,once:(s!==!0&&s!==!1&&s?.once)??!1})}removeEventListener(n,r,s){super.removeEventListener(n.toString(),r??null,s);let i=_t(this,pt).get(n);i!=null&&(i=i.filter(({callback:o})=>o!==r),_t(this,pt).set(n,i))}dispatchEvent(n){const r=super.dispatchEvent(n);let s=_t(this,pt).get(n.type);return s==null||(s=s.filter(({once:i})=>!i),_t(this,pt).set(n.type,s)),r}safeDispatchEvent(n,r={}){return this.dispatchEvent(new CustomEvent(n,r))}}pt=new WeakMap;const Iu=Symbol.for("@libp2p/service-capabilities"),_u=Symbol.for("@libp2p/service-dependencies");function si(e,t){if(e===t)return!0;if(e.byteLength!==t.byteLength)return!1;for(let n=0;n<e.byteLength;n++)if(e[n]!==t[n])return!1;return!0}function ze(e){if(e instanceof Uint8Array&&e.constructor.name==="Uint8Array")return e;if(e instanceof ArrayBuffer)return new Uint8Array(e);if(ArrayBuffer.isView(e))return new Uint8Array(e.buffer,e.byteOffset,e.byteLength);throw new Error("Unknown type, must be binary type")}function ii(e){return new TextEncoder().encode(e)}function oi(e){return new TextDecoder().decode(e)}function ai(e,t){if(e.length>=255)throw new TypeError("Alphabet too long");for(var n=new Uint8Array(256),r=0;r<n.length;r++)n[r]=255;for(var s=0;s<e.length;s++){var i=e.charAt(s),o=i.charCodeAt(0);if(n[o]!==255)throw new TypeError(i+" is ambiguous");n[o]=s}var c=e.length,a=e.charAt(0),l=Math.log(c)/Math.log(256),b=Math.log(256)/Math.log(c);function d(p){if(p instanceof Uint8Array||(ArrayBuffer.isView(p)?p=new Uint8Array(p.buffer,p.byteOffset,p.byteLength):Array.isArray(p)&&(p=Uint8Array.from(p))),!(p instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(p.length===0)return"";for(var _=0,y=0,R=0,m=p.length;R!==m&&p[R]===0;)R++,_++;for(var w=(m-R)*b+1>>>0,B=new Uint8Array(w);R!==m;){for(var C=p[R],M=0,$=w-1;(C!==0||M<y)&&$!==-1;$--,M++)C+=256*B[$]>>>0,B[$]=C%c>>>0,C=C/c>>>0;if(C!==0)throw new Error("Non-zero carry");y=M,R++}for(var x=w-y;x!==w&&B[x]===0;)x++;for(var E=a.repeat(_);x<w;++x)E+=e.charAt(B[x]);return E}function A(p){if(typeof p!="string")throw new TypeError("Expected String");if(p.length===0)return new Uint8Array;var _=0;if(p[_]!==" "){for(var y=0,R=0;p[_]===a;)y++,_++;for(var m=(p.length-_)*l+1>>>0,w=new Uint8Array(m);p[_];){var B=n[p.charCodeAt(_)];if(B===255)return;for(var C=0,M=m-1;(B!==0||C<R)&&M!==-1;M--,C++)B+=c*w[M]>>>0,w[M]=B%256>>>0,B=B/256>>>0;if(B!==0)throw new Error("Non-zero carry");R=C,_++}if(p[_]!==" "){for(var $=m-R;$!==m&&w[$]===0;)$++;for(var x=new Uint8Array(y+(m-$)),E=y;$!==m;)x[E++]=w[$++];return x}}}function S(p){var _=A(p);if(_)return _;throw new Error(`Non-${t} character`)}return{encode:d,decodeUnsafe:A,decode:S}}var ci=ai,ui=ci;class fi{constructor(t,n,r){u(this,"name");u(this,"prefix");u(this,"baseEncode");this.name=t,this.prefix=n,this.baseEncode=r}encode(t){if(t instanceof Uint8Array)return`${this.prefix}${this.baseEncode(t)}`;throw Error("Unknown type, must be binary type")}}class hi{constructor(t,n,r){u(this,"name");u(this,"prefix");u(this,"baseDecode");u(this,"prefixCodePoint");this.name=t,this.prefix=n;const s=n.codePointAt(0);if(s===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=s,this.baseDecode=r}decode(t){if(typeof t=="string"){if(t.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(t.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(t){return Ir(this,t)}}class li{constructor(t){u(this,"decoders");this.decoders=t}or(t){return Ir(this,t)}decode(t){const n=t[0],r=this.decoders[n];if(r!=null)return r.decode(t);throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}function Ir(e,t){return new li({...e.decoders??{[e.prefix]:e},...t.decoders??{[t.prefix]:t}})}class di{constructor(t,n,r,s){u(this,"name");u(this,"prefix");u(this,"baseEncode");u(this,"baseDecode");u(this,"encoder");u(this,"decoder");this.name=t,this.prefix=n,this.baseEncode=r,this.baseDecode=s,this.encoder=new fi(t,n,r),this.decoder=new hi(t,n,s)}encode(t){return this.encoder.encode(t)}decode(t){return this.decoder.decode(t)}}function Ze({name:e,prefix:t,encode:n,decode:r}){return new di(e,t,n,r)}function we({name:e,prefix:t,alphabet:n}){const{encode:r,decode:s}=ui(n,e);return Ze({prefix:t,name:e,encode:r,decode:i=>ze(s(i))})}function bi(e,t,n,r){let s=e.length;for(;e[s-1]==="=";)--s;const i=new Uint8Array(s*n/8|0);let o=0,c=0,a=0;for(let l=0;l<s;++l){const b=t[e[l]];if(b===void 0)throw new SyntaxError(`Non-${r} character`);c=c<<n|b,o+=n,o>=8&&(o-=8,i[a++]=255&c>>o)}if(o>=n||255&c<<8-o)throw new SyntaxError("Unexpected end of data");return i}function yi(e,t,n){const r=t[t.length-1]==="=",s=(1<<n)-1;let i="",o=0,c=0;for(let a=0;a<e.length;++a)for(c=c<<8|e[a],o+=8;o>n;)o-=n,i+=t[s&c>>o];if(o!==0&&(i+=t[s&c<<n-o]),r)for(;i.length*n&7;)i+="=";return i}function wi(e){const t={};for(let n=0;n<e.length;++n)t[e[n]]=n;return t}function st({name:e,prefix:t,bitsPerChar:n,alphabet:r}){const s=wi(r);return Ze({prefix:t,name:e,encode(i){return yi(i,r,n)},decode(i){return bi(i,s,n,e)}})}const bt=we({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),gi=we({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),pi=Object.freeze(Object.defineProperty({__proto__:null,base58btc:bt,base58flickr:gi},Symbol.toStringTag,{value:"Module"})),ue=st({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),mi=st({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),xi=st({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),Ei=st({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),Ai=st({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),Si=st({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),Bi=st({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),vi=st({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),Ii=st({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),_i=Object.freeze(Object.defineProperty({__proto__:null,base32:ue,base32hex:Ai,base32hexpad:Bi,base32hexpadupper:vi,base32hexupper:Si,base32pad:xi,base32padupper:Ei,base32upper:mi,base32z:Ii},Symbol.toStringTag,{value:"Module"})),De=we({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),Li=we({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),Ui=Object.freeze(Object.defineProperty({__proto__:null,base36:De,base36upper:Li},Symbol.toStringTag,{value:"Module"}));var Ri=_r,Yn=128,Di=-128,Ni=Math.pow(2,31);function _r(e,t,n){t=t||[],n=n||0;for(var r=n;e>=Ni;)t[n++]=e&255|Yn,e/=128;for(;e&Di;)t[n++]=e&255|Yn,e>>>=7;return t[n]=e|0,_r.bytes=n-r+1,t}var Ti=fn,Ci=128,Xn=127;function fn(e,r){var n=0,r=r||0,s=0,i=r,o,c=e.length;do{if(i>=c)throw fn.bytes=0,new RangeError("Could not decode varint");o=e[i++],n+=s<28?(o&Xn)<<s:(o&Xn)*Math.pow(2,s),s+=7}while(o>=Ci);return fn.bytes=i-r,n}var Ki=Math.pow(2,7),Oi=Math.pow(2,14),Mi=Math.pow(2,21),ki=Math.pow(2,28),Pi=Math.pow(2,35),$i=Math.pow(2,42),Vi=Math.pow(2,49),Hi=Math.pow(2,56),qi=Math.pow(2,63),Fi=function(e){return e<Ki?1:e<Oi?2:e<Mi?3:e<ki?4:e<Pi?5:e<$i?6:e<Vi?7:e<Hi?8:e<qi?9:10},zi={encode:Ri,decode:Ti,encodingLength:Fi},Ke=zi;function hn(e,t=0){return[Ke.decode(e,t),Ke.decode.bytes]}function Oe(e,t,n=0){return Ke.encode(e,t,n),t}function Me(e){return Ke.encodingLength(e)}function te(e,t){const n=t.byteLength,r=Me(e),s=r+Me(n),i=new Uint8Array(s+n);return Oe(e,i,0),Oe(n,i,r),i.set(t,s),new Sn(e,n,t,i)}function Zi(e){const t=ze(e),[n,r]=hn(t),[s,i]=hn(t.subarray(r)),o=t.subarray(r+i);if(o.byteLength!==s)throw new Error("Incorrect length");return new Sn(n,s,o,t)}function ji(e,t){if(e===t)return!0;{const n=t;return e.code===n.code&&e.size===n.size&&n.bytes instanceof Uint8Array&&si(e.bytes,n.bytes)}}class Sn{constructor(t,n,r,s){u(this,"code");u(this,"size");u(this,"digest");u(this,"bytes");this.code=t,this.size=n,this.digest=r,this.bytes=s}}function Wn(e,t){const{bytes:n,version:r}=e;switch(r){case 0:return Yi(n,ln(e),t??bt.encoder);default:return Xi(n,ln(e),t??ue.encoder)}}const Jn=new WeakMap;function ln(e){const t=Jn.get(e);if(t==null){const n=new Map;return Jn.set(e,n),n}return t}var Ar;class J{constructor(t,n,r,s){u(this,"code");u(this,"version");u(this,"multihash");u(this,"bytes");u(this,"/");u(this,Ar,"CID");this.code=n,this.version=t,this.multihash=r,this.bytes=s,this["/"]=s}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:t,multihash:n}=this;if(t!==se)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(n.code!==Wi)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return J.createV0(n)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{const{code:t,digest:n}=this.multihash,r=te(t,n);return J.createV1(this.code,r)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(t){return J.equals(this,t)}static equals(t,n){const r=n;return r!=null&&t.code===r.code&&t.version===r.version&&ji(t.multihash,r.multihash)}toString(t){return Wn(this,t)}toJSON(){return{"/":Wn(this)}}link(){return this}[(Ar=Symbol.toStringTag,Symbol.for("nodejs.util.inspect.custom"))](){return`CID(${this.toString()})`}static asCID(t){if(t==null)return null;const n=t;if(n instanceof J)return n;if(n["/"]!=null&&n["/"]===n.bytes||n.asCID===n){const{version:r,code:s,multihash:i,bytes:o}=n;return new J(r,s,i,o??Qn(r,s,i.bytes))}else if(n[Ji]===!0){const{version:r,multihash:s,code:i}=n,o=Zi(s);return J.create(r,i,o)}else return null}static create(t,n,r){if(typeof n!="number")throw new Error("String codecs are no longer supported");if(!(r.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(t){case 0:{if(n!==se)throw new Error(`Version 0 CID must use dag-pb (code: ${se}) block encoding`);return new J(t,n,r,r.bytes)}case 1:{const s=Qn(t,n,r.bytes);return new J(t,n,r,s)}default:throw new Error("Invalid version")}}static createV0(t){return J.create(0,se,t)}static createV1(t,n){return J.create(1,t,n)}static decode(t){const[n,r]=J.decodeFirst(t);if(r.length!==0)throw new Error("Incorrect length");return n}static decodeFirst(t){const n=J.inspectBytes(t),r=n.size-n.multihashSize,s=ze(t.subarray(r,r+n.multihashSize));if(s.byteLength!==n.multihashSize)throw new Error("Incorrect length");const i=s.subarray(n.multihashSize-n.digestSize),o=new Sn(n.multihashCode,n.digestSize,i,s);return[n.version===0?J.createV0(o):J.createV1(n.codec,o),t.subarray(n.size)]}static inspectBytes(t){let n=0;const r=()=>{const[d,A]=hn(t.subarray(n));return n+=A,d};let s=r(),i=se;if(s===18?(s=0,n=0):i=r(),s!==0&&s!==1)throw new RangeError(`Invalid CID version ${s}`);const o=n,c=r(),a=r(),l=n+a,b=l-o;return{version:s,codec:i,multihashCode:c,digestSize:a,multihashSize:b,size:l}}static parse(t,n){const[r,s]=Gi(t,n),i=J.decode(s);if(i.version===0&&t[0]!=="Q")throw Error("Version 0 CID string must not include multibase prefix");return ln(i).set(r,t),i}}function Gi(e,t){switch(e[0]){case"Q":{const n=t??bt;return[bt.prefix,n.decode(`${bt.prefix}${e}`)]}case bt.prefix:{const n=t??bt;return[bt.prefix,n.decode(e)]}case ue.prefix:{const n=t??ue;return[ue.prefix,n.decode(e)]}case De.prefix:{const n=t??De;return[De.prefix,n.decode(e)]}default:{if(t==null)throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");return[e[0],t.decode(e)]}}}function Yi(e,t,n){const{prefix:r}=n;if(r!==bt.prefix)throw Error(`Cannot string encode V0 in ${n.name} encoding`);const s=t.get(r);if(s==null){const i=n.encode(e).slice(1);return t.set(r,i),i}else return s}function Xi(e,t,n){const{prefix:r}=n,s=t.get(r);if(s==null){const i=n.encode(e);return t.set(r,i),i}else return s}const se=112,Wi=18;function Qn(e,t,n){const r=Me(e),s=r+Me(t),i=new Uint8Array(s+n.byteLength);return Oe(e,i,0),Oe(t,i,r),i.set(n,s),i}const Ji=Symbol.for("@ipld/js-cid/CID"),Lr=0,Qi="identity",Ur=ze;function to(e,t){if(t?.truncate!=null&&t.truncate!==e.byteLength){if(t.truncate<0||t.truncate>e.byteLength)throw new Error(`Invalid truncate option, must be less than or equal to ${e.byteLength}`);e=e.subarray(0,t.truncate)}return te(Lr,Ur(e))}const Bn={code:Lr,name:Qi,encode:Ur,digest:to};function It(e,t){if(e===t)return!0;if(e.byteLength!==t.byteLength)return!1;for(let n=0;n<e.byteLength;n++)if(e[n]!==t[n])return!1;return!0}function Lt(e=0){return new Uint8Array(e)}function Ot(e=0){return new Uint8Array(e)}function Lu(e){return e}function tr(e,t){t==null&&(t=e.reduce((s,i)=>s+i.length,0));const n=Ot(t);let r=0;for(const s of e)n.set(s,r),r+=s.length;return n}const Rr=Symbol.for("@achingbrain/uint8arraylist");function er(e,t){if(t==null||t<0)throw new RangeError("index is out of bounds");let n=0;for(const r of e){const s=n+r.byteLength;if(t<s)return{buf:r,index:t-n};n=s}throw new RangeError("index is out of bounds")}function Ae(e){return!!e?.[Rr]}var Sr;class ft{constructor(...t){u(this,"bufs");u(this,"length");u(this,Sr,!0);this.bufs=[],this.length=0,t.length>0&&this.appendAll(t)}*[(Sr=Rr,Symbol.iterator)](){yield*this.bufs}get byteLength(){return this.length}append(...t){this.appendAll(t)}appendAll(t){let n=0;for(const r of t)if(r instanceof Uint8Array)n+=r.byteLength,this.bufs.push(r);else if(Ae(r))n+=r.byteLength,this.bufs.push(...r.bufs);else throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");this.length+=n}prepend(...t){this.prependAll(t)}prependAll(t){let n=0;for(const r of t.reverse())if(r instanceof Uint8Array)n+=r.byteLength,this.bufs.unshift(r);else if(Ae(r))n+=r.byteLength,this.bufs.unshift(...r.bufs);else throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");this.length+=n}get(t){const n=er(this.bufs,t);return n.buf[n.index]}set(t,n){const r=er(this.bufs,t);r.buf[r.index]=n}write(t,n=0){if(t instanceof Uint8Array)for(let r=0;r<t.length;r++)this.set(n+r,t[r]);else if(Ae(t))for(let r=0;r<t.length;r++)this.set(n+r,t.get(r));else throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList")}consume(t){if(t=Math.trunc(t),!(Number.isNaN(t)||t<=0)){if(t===this.byteLength){this.bufs=[],this.length=0;return}for(;this.bufs.length>0;)if(t>=this.bufs[0].byteLength)t-=this.bufs[0].byteLength,this.length-=this.bufs[0].byteLength,this.bufs.shift();else{this.bufs[0]=this.bufs[0].subarray(t),this.length-=t;break}}}slice(t,n){const{bufs:r,length:s}=this._subList(t,n);return tr(r,s)}subarray(t,n){const{bufs:r,length:s}=this._subList(t,n);return r.length===1?r[0]:tr(r,s)}sublist(t,n){const{bufs:r,length:s}=this._subList(t,n),i=new ft;return i.length=s,i.bufs=[...r],i}_subList(t,n){if(t=t??0,n=n??this.length,t<0&&(t=this.length+t),n<0&&(n=this.length+n),t<0||n>this.length)throw new RangeError("index is out of bounds");if(t===n)return{bufs:[],length:0};if(t===0&&n===this.length)return{bufs:this.bufs,length:this.length};const r=[];let s=0;for(let i=0;i<this.bufs.length;i++){const o=this.bufs[i],c=s,a=c+o.byteLength;if(s=a,t>=a)continue;const l=t>=c&&t<a,b=n>c&&n<=a;if(l&&b){if(t===c&&n===a){r.push(o);break}const d=t-c;r.push(o.subarray(d,d+(n-t)));break}if(l){if(t===0){r.push(o);continue}r.push(o.subarray(t-c));continue}if(b){if(n===a){r.push(o);break}r.push(o.subarray(0,n-c));break}r.push(o)}return{bufs:r,length:n-t}}indexOf(t,n=0){if(!Ae(t)&&!(t instanceof Uint8Array))throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');const r=t instanceof Uint8Array?t:t.subarray();if(n=Number(n??0),isNaN(n)&&(n=0),n<0&&(n=this.length+n),n<0&&(n=0),t.length===0)return n>this.length?this.length:n;const s=r.byteLength;if(s===0)throw new TypeError("search must be at least 1 byte long");const i=256,o=new Int32Array(i);for(let d=0;d<i;d++)o[d]=-1;for(let d=0;d<s;d++)o[r[d]]=d;const c=o,a=this.byteLength-r.byteLength,l=r.byteLength-1;let b;for(let d=n;d<=a;d+=b){b=0;for(let A=l;A>=0;A--){const S=this.get(d+A);if(r[A]!==S){b=Math.max(1,A-c[S]);break}}if(b===0)return d}return-1}getInt8(t){const n=this.subarray(t,t+1);return new DataView(n.buffer,n.byteOffset,n.byteLength).getInt8(0)}setInt8(t,n){const r=Ot(1);new DataView(r.buffer,r.byteOffset,r.byteLength).setInt8(0,n),this.write(r,t)}getInt16(t,n){const r=this.subarray(t,t+2);return new DataView(r.buffer,r.byteOffset,r.byteLength).getInt16(0,n)}setInt16(t,n,r){const s=Lt(2);new DataView(s.buffer,s.byteOffset,s.byteLength).setInt16(0,n,r),this.write(s,t)}getInt32(t,n){const r=this.subarray(t,t+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getInt32(0,n)}setInt32(t,n,r){const s=Lt(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setInt32(0,n,r),this.write(s,t)}getBigInt64(t,n){const r=this.subarray(t,t+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getBigInt64(0,n)}setBigInt64(t,n,r){const s=Lt(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setBigInt64(0,n,r),this.write(s,t)}getUint8(t){const n=this.subarray(t,t+1);return new DataView(n.buffer,n.byteOffset,n.byteLength).getUint8(0)}setUint8(t,n){const r=Ot(1);new DataView(r.buffer,r.byteOffset,r.byteLength).setUint8(0,n),this.write(r,t)}getUint16(t,n){const r=this.subarray(t,t+2);return new DataView(r.buffer,r.byteOffset,r.byteLength).getUint16(0,n)}setUint16(t,n,r){const s=Lt(2);new DataView(s.buffer,s.byteOffset,s.byteLength).setUint16(0,n,r),this.write(s,t)}getUint32(t,n){const r=this.subarray(t,t+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getUint32(0,n)}setUint32(t,n,r){const s=Lt(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setUint32(0,n,r),this.write(s,t)}getBigUint64(t,n){const r=this.subarray(t,t+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getBigUint64(0,n)}setBigUint64(t,n,r){const s=Lt(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setBigUint64(0,n,r),this.write(s,t)}getFloat32(t,n){const r=this.subarray(t,t+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getFloat32(0,n)}setFloat32(t,n,r){const s=Lt(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setFloat32(0,n,r),this.write(s,t)}getFloat64(t,n){const r=this.subarray(t,t+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getFloat64(0,n)}setFloat64(t,n,r){const s=Lt(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setFloat64(0,n,r),this.write(s,t)}equals(t){if(t==null||!(t instanceof ft)||t.bufs.length!==this.bufs.length)return!1;for(let n=0;n<this.bufs.length;n++)if(!It(this.bufs[n],t.bufs[n]))return!1;return!0}static fromUint8Arrays(t,n){const r=new ft;return r.bufs=t,n==null&&(n=t.reduce((s,i)=>s+i.byteLength,0)),r.length=n,r}}const eo=we({prefix:"9",name:"base10",alphabet:"0123456789"}),no=Object.freeze(Object.defineProperty({__proto__:null,base10:eo},Symbol.toStringTag,{value:"Module"})),ro=st({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),so=st({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),io=Object.freeze(Object.defineProperty({__proto__:null,base16:ro,base16upper:so},Symbol.toStringTag,{value:"Module"})),oo=st({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),ao=Object.freeze(Object.defineProperty({__proto__:null,base2:oo},Symbol.toStringTag,{value:"Module"})),Dr=Array.from("ðŸš€ðŸªâ˜„ðŸ›°ðŸŒŒðŸŒ‘ðŸŒ’ðŸŒ“ðŸŒ”ðŸŒ•ðŸŒ–ðŸŒ—ðŸŒ˜ðŸŒðŸŒðŸŒŽðŸ‰â˜€ðŸ’»ðŸ–¥ðŸ’¾ðŸ’¿ðŸ˜‚â¤ðŸ˜ðŸ¤£ðŸ˜ŠðŸ™ðŸ’•ðŸ˜­ðŸ˜˜ðŸ‘ðŸ˜…ðŸ‘ðŸ˜ðŸ”¥ðŸ¥°ðŸ’”ðŸ’–ðŸ’™ðŸ˜¢ðŸ¤”ðŸ˜†ðŸ™„ðŸ’ªðŸ˜‰â˜ºðŸ‘ŒðŸ¤—ðŸ’œðŸ˜”ðŸ˜ŽðŸ˜‡ðŸŒ¹ðŸ¤¦ðŸŽ‰ðŸ’žâœŒâœ¨ðŸ¤·ðŸ˜±ðŸ˜ŒðŸŒ¸ðŸ™ŒðŸ˜‹ðŸ’—ðŸ’šðŸ˜ðŸ’›ðŸ™‚ðŸ’“ðŸ¤©ðŸ˜„ðŸ˜€ðŸ–¤ðŸ˜ƒðŸ’¯ðŸ™ˆðŸ‘‡ðŸŽ¶ðŸ˜’ðŸ¤­â£ðŸ˜œðŸ’‹ðŸ‘€ðŸ˜ªðŸ˜‘ðŸ’¥ðŸ™‹ðŸ˜žðŸ˜©ðŸ˜¡ðŸ¤ªðŸ‘ŠðŸ¥³ðŸ˜¥ðŸ¤¤ðŸ‘‰ðŸ’ƒðŸ˜³âœ‹ðŸ˜šðŸ˜ðŸ˜´ðŸŒŸðŸ˜¬ðŸ™ƒðŸ€ðŸŒ·ðŸ˜»ðŸ˜“â­âœ…ðŸ¥ºðŸŒˆðŸ˜ˆðŸ¤˜ðŸ’¦âœ”ðŸ˜£ðŸƒðŸ’â˜¹ðŸŽŠðŸ’˜ðŸ˜ â˜ðŸ˜•ðŸŒºðŸŽ‚ðŸŒ»ðŸ˜ðŸ–•ðŸ’ðŸ™ŠðŸ˜¹ðŸ—£ðŸ’«ðŸ’€ðŸ‘‘ðŸŽµðŸ¤žðŸ˜›ðŸ”´ðŸ˜¤ðŸŒ¼ðŸ˜«âš½ðŸ¤™â˜•ðŸ†ðŸ¤«ðŸ‘ˆðŸ˜®ðŸ™†ðŸ»ðŸƒðŸ¶ðŸ’ðŸ˜²ðŸŒ¿ðŸ§¡ðŸŽâš¡ðŸŒžðŸŽˆâŒâœŠðŸ‘‹ðŸ˜°ðŸ¤¨ðŸ˜¶ðŸ¤ðŸš¶ðŸ’°ðŸ“ðŸ’¢ðŸ¤ŸðŸ™ðŸš¨ðŸ’¨ðŸ¤¬âœˆðŸŽ€ðŸºðŸ¤“ðŸ˜™ðŸ’ŸðŸŒ±ðŸ˜–ðŸ‘¶ðŸ¥´â–¶âž¡â“ðŸ’ŽðŸ’¸â¬‡ðŸ˜¨ðŸŒšðŸ¦‹ðŸ˜·ðŸ•ºâš ðŸ™…ðŸ˜ŸðŸ˜µðŸ‘ŽðŸ¤²ðŸ¤ ðŸ¤§ðŸ“ŒðŸ”µðŸ’…ðŸ§ðŸ¾ðŸ’ðŸ˜—ðŸ¤‘ðŸŒŠðŸ¤¯ðŸ·â˜ŽðŸ’§ðŸ˜¯ðŸ’†ðŸ‘†ðŸŽ¤ðŸ™‡ðŸ‘â„ðŸŒ´ðŸ’£ðŸ¸ðŸ’ŒðŸ“ðŸ¥€ðŸ¤¢ðŸ‘…ðŸ’¡ðŸ’©ðŸ‘ðŸ“¸ðŸ‘»ðŸ¤ðŸ¤®ðŸŽ¼ðŸ¥µðŸš©ðŸŽðŸŠðŸ‘¼ðŸ’ðŸ“£ðŸ¥‚"),co=Dr.reduce((e,t,n)=>(e[n]=t,e),[]),uo=Dr.reduce((e,t,n)=>{const r=t.codePointAt(0);if(r==null)throw new Error(`Invalid character: ${t}`);return e[r]=n,e},[]);function fo(e){return e.reduce((t,n)=>(t+=co[n],t),"")}function ho(e){const t=[];for(const n of e){const r=n.codePointAt(0);if(r==null)throw new Error(`Invalid character: ${n}`);const s=uo[r];if(s==null)throw new Error(`Non-base256emoji character: ${n}`);t.push(s)}return new Uint8Array(t)}const lo=Ze({prefix:"ðŸš€",name:"base256emoji",encode:fo,decode:ho}),bo=Object.freeze(Object.defineProperty({__proto__:null,base256emoji:lo},Symbol.toStringTag,{value:"Module"})),yo=st({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),wo=st({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),go=st({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),po=st({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6}),mo=Object.freeze(Object.defineProperty({__proto__:null,base64:yo,base64pad:wo,base64url:go,base64urlpad:po},Symbol.toStringTag,{value:"Module"})),xo=st({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),Eo=Object.freeze(Object.defineProperty({__proto__:null,base8:xo},Symbol.toStringTag,{value:"Module"})),Ao=Ze({prefix:"\0",name:"identity",encode:e=>oi(e),decode:e=>ii(e)}),So=Object.freeze(Object.defineProperty({__proto__:null,identity:Ao},Symbol.toStringTag,{value:"Module"}));new TextEncoder;new TextDecoder;const Uu=85,Bo=20;function vo({name:e,code:t,encode:n,minDigestLength:r,maxDigestLength:s}){return new Io(e,t,n,r,s)}class Io{constructor(t,n,r,s,i){u(this,"name");u(this,"code");u(this,"encode");u(this,"minDigestLength");u(this,"maxDigestLength");this.name=t,this.code=n,this.encode=r,this.minDigestLength=s??Bo,this.maxDigestLength=i}digest(t,n){if(n?.truncate!=null){if(n.truncate<this.minDigestLength)throw new Error(`Invalid truncate option, must be greater than or equal to ${this.minDigestLength}`);if(this.maxDigestLength!=null&&n.truncate>this.maxDigestLength)throw new Error(`Invalid truncate option, must be less than or equal to ${this.maxDigestLength}`)}if(t instanceof Uint8Array){const r=this.encode(t);return r instanceof Uint8Array?nr(r,this.code,n?.truncate):r.then(s=>nr(s,this.code,n?.truncate))}else throw Error("Unknown type, must be binary type")}}function nr(e,t,n){if(n!=null&&n!==e.byteLength){if(n>e.byteLength)throw new Error(`Invalid truncate option, must be less than or equal to ${e.byteLength}`);e=e.subarray(0,n)}return te(t,e)}function _o(e){return async t=>new Uint8Array(await crypto.subtle.digest(e,t))}const Nr=vo({name:"sha2-256",code:18,encode:_o("SHA-256")}),rr={...So,...ao,...Eo,...no,...io,..._i,...Ui,...pi,...mo,...bo};function Tr(e,t,n,r){return{name:e,prefix:t,encoder:{name:e,prefix:t,encode:n},decoder:{decode:r}}}const sr=Tr("utf8","u",e=>"u"+new TextDecoder("utf8").decode(e),e=>new TextEncoder().encode(e.substring(1))),tn=Tr("ascii","a",e=>{let t="a";for(let n=0;n<e.length;n++)t+=String.fromCharCode(e[n]);return t},e=>{e=e.substring(1);const t=Ot(e.length);for(let n=0;n<e.length;n++)t[n]=e.charCodeAt(n);return t}),Cr={utf8:sr,"utf-8":sr,hex:rr.base16,latin1:tn,ascii:tn,binary:tn,...rr};function nt(e,t="utf8"){const n=Cr[t];if(n==null)throw new Error(`Unsupported encoding "${t}"`);return n.decoder.decode(`${n.prefix}${e}`)}function z(e,t="utf8"){const n=Cr[t];if(n==null)throw new Error(`Unsupported encoding "${t}"`);return n.encoder.encode(e).substring(1)}const Lo=parseInt("11111",2),dn=parseInt("10000000",2),Uo=parseInt("01111111",2),ir={0:ie,1:ie,2:Ro,3:To,4:Co,5:No,6:Do,16:ie,22:ie,48:ie};function ee(e,t={offset:0}){const n=e[t.offset]&Lo;if(t.offset++,ir[n]!=null)return ir[n](e,t);throw new Error("No decoder for tag "+n)}function ge(e,t){let n=0;if((e[t.offset]&dn)===dn){const r=e[t.offset]&Uo;let s="0x";t.offset++;for(let i=0;i<r;i++,t.offset++)s+=e[t.offset].toString(16).padStart(2,"0");n=parseInt(s,16)}else n=e[t.offset],t.offset++;return n}function ie(e,t){ge(e,t);const n=[];for(;!(t.offset>=e.byteLength);){const r=ee(e,t);if(r===null)break;n.push(r)}return n}function Ro(e,t){const n=ge(e,t),r=t.offset,s=t.offset+n,i=[];for(let o=r;o<s;o++)o===r&&e[o]===0||i.push(e[o]);return t.offset+=n,Uint8Array.from(i)}function Do(e,t){const n=ge(e,t),r=t.offset+n,s=e[t.offset];t.offset++;let i=0,o=0;s<40?(i=0,o=s):s<80?(i=1,o=s-40):(i=2,o=s-80);let c=`${i}.${o}`,a=[];for(;t.offset<r;){const l=e[t.offset];if(t.offset++,a.push(l&127),l<128){a.reverse();let b=0;for(let d=0;d<a.length;d++)b+=a[d]<<d*7;c+=`.${b}`,a=[]}}return c}function No(e,t){return t.offset++,null}function To(e,t){const n=ge(e,t),r=e[t.offset];t.offset++;const s=e.subarray(t.offset,t.offset+n-1);if(t.offset+=n,r!==0)throw new Error("Unused bits in bit string is unimplemented");return s}function Co(e,t){const n=ge(e,t),r=e.subarray(t.offset,t.offset+n);return t.offset+=n,r}function Ko(e){let t=e.toString(16);t.length%2===1&&(t="0"+t);const n=new ft;for(let r=0;r<t.length;r+=2)n.append(Uint8Array.from([parseInt(`${t[r]}${t[r+1]}`,16)]));return n}function je(e){if(e.byteLength<128)return Uint8Array.from([e.byteLength]);const t=Ko(e.byteLength);return new ft(Uint8Array.from([t.byteLength|dn]),t)}function dt(e){const t=new ft,n=128;return(e.subarray()[0]&n)===n&&t.append(Uint8Array.from([0])),t.append(e),new ft(Uint8Array.from([2]),je(t),t)}function vn(e){const t=Uint8Array.from([0]),n=new ft(t,e);return new ft(Uint8Array.from([3]),je(n),n)}function Oo(e){return new ft(Uint8Array.from([4]),je(e),e)}function Bt(e,t=48){const n=new ft;for(const r of e)n.append(r);return new ft(Uint8Array.from([t]),je(n),n)}async function Mo(e="P-256"){const t=await crypto.subtle.generateKey({name:"ECDSA",namedCurve:e},!0,["sign","verify"]);return{publicKey:await crypto.subtle.exportKey("jwk",t.publicKey),privateKey:await crypto.subtle.exportKey("jwk",t.privateKey)}}async function ko(e,t,n){const r=await crypto.subtle.importKey("jwk",e,{name:"ECDSA",namedCurve:e.crv??"P-256"},!1,["sign"]);n?.signal?.throwIfAborted();const s=await crypto.subtle.sign({name:"ECDSA",hash:{name:"SHA-256"}},r,t.subarray());return n?.signal?.throwIfAborted(),new Uint8Array(s,0,s.byteLength)}async function Po(e,t,n,r){const s=await crypto.subtle.importKey("jwk",e,{name:"ECDSA",namedCurve:e.crv??"P-256"},!1,["verify"]);r?.signal?.throwIfAborted();const i=await crypto.subtle.verify({name:"ECDSA",hash:{name:"SHA-256"}},s,t,n.subarray());return r?.signal?.throwIfAborted(),i}const $o=Uint8Array.from([6,8,42,134,72,206,61,3,1,7]),Vo=Uint8Array.from([6,5,43,129,4,0,34]),Ho=Uint8Array.from([6,5,43,129,4,0,35]),Kr={ext:!0,kty:"EC",crv:"P-256"},Or={ext:!0,kty:"EC",crv:"P-384"},Mr={ext:!0,kty:"EC",crv:"P-521"},jt=32,Gt=48,Yt=66;function qo(e){const t=ee(e);return Fo(t)}function Fo(e){const t=e[1],n=z(t,"base64url"),r=e[2][1][0],s=1;let i,o;if(t.byteLength===jt)return i=z(r.subarray(s,s+jt),"base64url"),o=z(r.subarray(s+jt),"base64url"),new Te({...Kr,key_ops:["sign"],d:n,x:i,y:o});if(t.byteLength===Gt)return i=z(r.subarray(s,s+Gt),"base64url"),o=z(r.subarray(s+Gt),"base64url"),new Te({...Or,key_ops:["sign"],d:n,x:i,y:o});if(t.byteLength===Yt)return i=z(r.subarray(s,s+Yt),"base64url"),o=z(r.subarray(s+Yt),"base64url"),new Te({...Mr,key_ops:["sign"],d:n,x:i,y:o});throw new lt(`Private key length was wrong length, got ${t.byteLength}, expected 32, 48 or 66`)}function kr(e){const t=ee(e);return zo(t)}function zo(e){const t=e[1][1][0],n=1;let r,s;if(t.byteLength===jt*2+1)return r=z(t.subarray(n,n+jt),"base64url"),s=z(t.subarray(n+jt),"base64url"),new Ne({...Kr,key_ops:["verify"],x:r,y:s});if(t.byteLength===Gt*2+1)return r=z(t.subarray(n,n+Gt),"base64url"),s=z(t.subarray(n+Gt),"base64url"),new Ne({...Or,key_ops:["verify"],x:r,y:s});if(t.byteLength===Yt*2+1)return r=z(t.subarray(n,n+Yt),"base64url"),s=z(t.subarray(n+Yt),"base64url"),new Ne({...Mr,key_ops:["verify"],x:r,y:s});throw new lt(`coordinates were wrong length, got ${t.byteLength}, expected 65, 97 or 133`)}function Zo(e){return Bt([dt(Uint8Array.from([1])),Oo(nt(e.d??"","base64url")),Bt([Pr(e.crv)],160),Bt([vn(new ft(Uint8Array.from([4]),nt(e.x??"","base64url"),nt(e.y??"","base64url")))],161)]).subarray()}function jo(e){return Bt([dt(Uint8Array.from([1])),Bt([Pr(e.crv)],160),Bt([vn(new ft(Uint8Array.from([4]),nt(e.x??"","base64url"),nt(e.y??"","base64url")))],161)]).subarray()}function Pr(e){if(e==="P-256")return $o;if(e==="P-384")return Vo;if(e==="P-521")return Ho;throw new lt(`Invalid curve ${e}`)}async function Go(e="P-256"){const t=await Mo(e);return new Te(t.privateKey)}class Ne{constructor(t){u(this,"type","ECDSA");u(this,"jwk");u(this,"_raw");this.jwk=t}get raw(){return this._raw==null&&(this._raw=jo(this.jwk)),this._raw}toMultihash(){return Bn.digest(Hn(this))}toCID(){return J.createV1(114,this.toMultihash())}toString(){return bt.encode(this.toMultihash().bytes).substring(1)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:It(this.raw,t.raw)}async verify(t,n,r){return Po(this.jwk,n,t,r)}}class Te{constructor(t){u(this,"type","ECDSA");u(this,"jwk");u(this,"publicKey");u(this,"_raw");this.jwk=t,this.publicKey=new Ne({crv:t.crv,ext:t.ext,key_ops:["verify"],kty:"EC",x:t.x,y:t.y})}get raw(){return this._raw==null&&(this._raw=Zo(this.jwk)),this._raw}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:It(this.raw,t.raw)}async sign(t,n){return ko(this.jwk,t,n)}}/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Ge(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function Vt(e,t=""){if(!Number.isSafeInteger(e)||e<0){const n=t&&`"${t}" `;throw new Error(`${n}expected integer >= 0, got ${e}`)}}function H(e,t,n=""){const r=Ge(e),s=e?.length,i=t!==void 0;if(!r||i&&s!==t){const o=n&&`"${n}" `,c=i?` of length ${t}`:"",a=r?`length=${s}`:`type=${typeof e}`;throw new Error(o+"expected Uint8Array"+c+", got "+a)}return e}function $r(e){if(typeof e!="function"||typeof e.create!="function")throw new Error("Hash must wrapped by utils.createHasher");Vt(e.outputLen),Vt(e.blockLen)}function ke(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function Yo(e,t){H(e,void 0,"digestInto() output");const n=t.outputLen;if(e.length<n)throw new Error('"digestInto() output" expected to be of length >='+n)}function Jt(...e){for(let t=0;t<e.length;t++)e[t].fill(0)}function en(e){return new DataView(e.buffer,e.byteOffset,e.byteLength)}function gt(e,t){return e<<32-t|e>>>t}const Vr=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",Xo=Array.from({length:256},(e,t)=>t.toString(16).padStart(2,"0"));function pe(e){if(H(e),Vr)return e.toHex();let t="";for(let n=0;n<e.length;n++)t+=Xo[e[n]];return t}const xt={_0:48,_9:57,A:65,F:70,a:97,f:102};function or(e){if(e>=xt._0&&e<=xt._9)return e-xt._0;if(e>=xt.A&&e<=xt.F)return e-(xt.A-10);if(e>=xt.a&&e<=xt.f)return e-(xt.a-10)}function he(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);if(Vr)return Uint8Array.fromHex(e);const t=e.length,n=t/2;if(t%2)throw new Error("hex string expected, got unpadded hex of length "+t);const r=new Uint8Array(n);for(let s=0,i=0;s<n;s++,i+=2){const o=or(e.charCodeAt(i)),c=or(e.charCodeAt(i+1));if(o===void 0||c===void 0){const a=e[i]+e[i+1];throw new Error('hex string expected, got non-hex character "'+a+'" at index '+i)}r[s]=o*16+c}return r}function mt(...e){let t=0;for(let r=0;r<e.length;r++){const s=e[r];H(s),t+=s.length}const n=new Uint8Array(t);for(let r=0,s=0;r<e.length;r++){const i=e[r];n.set(i,s),s+=i.length}return n}function Hr(e,t={}){const n=(s,i)=>e(i).update(s).digest(),r=e(void 0);return n.outputLen=r.outputLen,n.blockLen=r.blockLen,n.create=s=>e(s),Object.assign(n,t),Object.freeze(n)}function me(e=32){const t=typeof globalThis=="object"?globalThis.crypto:null;if(typeof t?.getRandomValues!="function")throw new Error("crypto.getRandomValues must be defined");return t.getRandomValues(new Uint8Array(e))}const qr=e=>({oid:Uint8Array.from([6,9,96,134,72,1,101,3,4,2,e])});function Wo(e,t,n){return e&t^~e&n}function Jo(e,t,n){return e&t^e&n^t&n}class Fr{constructor(t,n,r,s){u(this,"blockLen");u(this,"outputLen");u(this,"padOffset");u(this,"isLE");u(this,"buffer");u(this,"view");u(this,"finished",!1);u(this,"length",0);u(this,"pos",0);u(this,"destroyed",!1);this.blockLen=t,this.outputLen=n,this.padOffset=r,this.isLE=s,this.buffer=new Uint8Array(t),this.view=en(this.buffer)}update(t){ke(this),H(t);const{view:n,buffer:r,blockLen:s}=this,i=t.length;for(let o=0;o<i;){const c=Math.min(s-this.pos,i-o);if(c===s){const a=en(t);for(;s<=i-o;o+=s)this.process(a,o);continue}r.set(t.subarray(o,o+c),this.pos),this.pos+=c,o+=c,this.pos===s&&(this.process(n,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){ke(this),Yo(t,this),this.finished=!0;const{buffer:n,view:r,blockLen:s,isLE:i}=this;let{pos:o}=this;n[o++]=128,Jt(this.buffer.subarray(o)),this.padOffset>s-o&&(this.process(r,0),o=0);for(let d=o;d<s;d++)n[d]=0;r.setBigUint64(s-8,BigInt(this.length*8),i),this.process(r,0);const c=en(t),a=this.outputLen;if(a%4)throw new Error("_sha2: outputLen must be aligned to 32bit");const l=a/4,b=this.get();if(l>b.length)throw new Error("_sha2: outputLen bigger than state");for(let d=0;d<l;d++)c.setUint32(4*d,b[d],i)}digest(){const{buffer:t,outputLen:n}=this;this.digestInto(t);const r=t.slice(0,n);return this.destroy(),r}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:n,buffer:r,length:s,finished:i,destroyed:o,pos:c}=this;return t.destroyed=o,t.finished=i,t.length=s,t.pos=c,s%n&&t.buffer.set(r),t}clone(){return this._cloneInto()}}const Ut=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),ot=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),Se=BigInt(2**32-1),ar=BigInt(32);function Qo(e,t=!1){return t?{h:Number(e&Se),l:Number(e>>ar&Se)}:{h:Number(e>>ar&Se)|0,l:Number(e&Se)|0}}function ta(e,t=!1){const n=e.length;let r=new Uint32Array(n),s=new Uint32Array(n);for(let i=0;i<n;i++){const{h:o,l:c}=Qo(e[i],t);[r[i],s[i]]=[o,c]}return[r,s]}const cr=(e,t,n)=>e>>>n,ur=(e,t,n)=>e<<32-n|t>>>n,Ft=(e,t,n)=>e>>>n|t<<32-n,zt=(e,t,n)=>e<<32-n|t>>>n,Be=(e,t,n)=>e<<64-n|t>>>n-32,ve=(e,t,n)=>e>>>n-32|t<<64-n;function Et(e,t,n,r){const s=(t>>>0)+(r>>>0);return{h:e+n+(s/2**32|0)|0,l:s|0}}const ea=(e,t,n)=>(e>>>0)+(t>>>0)+(n>>>0),na=(e,t,n,r)=>t+n+r+(e/2**32|0)|0,ra=(e,t,n,r)=>(e>>>0)+(t>>>0)+(n>>>0)+(r>>>0),sa=(e,t,n,r,s)=>t+n+r+s+(e/2**32|0)|0,ia=(e,t,n,r,s)=>(e>>>0)+(t>>>0)+(n>>>0)+(r>>>0)+(s>>>0),oa=(e,t,n,r,s,i)=>t+n+r+s+i+(e/2**32|0)|0,aa=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Rt=new Uint32Array(64);class ca extends Fr{constructor(t){super(64,t,8,!1)}get(){const{A:t,B:n,C:r,D:s,E:i,F:o,G:c,H:a}=this;return[t,n,r,s,i,o,c,a]}set(t,n,r,s,i,o,c,a){this.A=t|0,this.B=n|0,this.C=r|0,this.D=s|0,this.E=i|0,this.F=o|0,this.G=c|0,this.H=a|0}process(t,n){for(let d=0;d<16;d++,n+=4)Rt[d]=t.getUint32(n,!1);for(let d=16;d<64;d++){const A=Rt[d-15],S=Rt[d-2],p=gt(A,7)^gt(A,18)^A>>>3,_=gt(S,17)^gt(S,19)^S>>>10;Rt[d]=_+Rt[d-7]+p+Rt[d-16]|0}let{A:r,B:s,C:i,D:o,E:c,F:a,G:l,H:b}=this;for(let d=0;d<64;d++){const A=gt(c,6)^gt(c,11)^gt(c,25),S=b+A+Wo(c,a,l)+aa[d]+Rt[d]|0,_=(gt(r,2)^gt(r,13)^gt(r,22))+Jo(r,s,i)|0;b=l,l=a,a=c,c=o+S|0,o=i,i=s,s=r,r=S+_|0}r=r+this.A|0,s=s+this.B|0,i=i+this.C|0,o=o+this.D|0,c=c+this.E|0,a=a+this.F|0,l=l+this.G|0,b=b+this.H|0,this.set(r,s,i,o,c,a,l,b)}roundClean(){Jt(Rt)}destroy(){this.set(0,0,0,0,0,0,0,0),Jt(this.buffer)}}class ua extends ca{constructor(){super(32);u(this,"A",Ut[0]|0);u(this,"B",Ut[1]|0);u(this,"C",Ut[2]|0);u(this,"D",Ut[3]|0);u(this,"E",Ut[4]|0);u(this,"F",Ut[5]|0);u(this,"G",Ut[6]|0);u(this,"H",Ut[7]|0)}}const zr=ta(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(e=>BigInt(e))),fa=zr[0],ha=zr[1],Dt=new Uint32Array(80),Nt=new Uint32Array(80);class la extends Fr{constructor(t){super(128,t,16,!1)}get(){const{Ah:t,Al:n,Bh:r,Bl:s,Ch:i,Cl:o,Dh:c,Dl:a,Eh:l,El:b,Fh:d,Fl:A,Gh:S,Gl:p,Hh:_,Hl:y}=this;return[t,n,r,s,i,o,c,a,l,b,d,A,S,p,_,y]}set(t,n,r,s,i,o,c,a,l,b,d,A,S,p,_,y){this.Ah=t|0,this.Al=n|0,this.Bh=r|0,this.Bl=s|0,this.Ch=i|0,this.Cl=o|0,this.Dh=c|0,this.Dl=a|0,this.Eh=l|0,this.El=b|0,this.Fh=d|0,this.Fl=A|0,this.Gh=S|0,this.Gl=p|0,this.Hh=_|0,this.Hl=y|0}process(t,n){for(let w=0;w<16;w++,n+=4)Dt[w]=t.getUint32(n),Nt[w]=t.getUint32(n+=4);for(let w=16;w<80;w++){const B=Dt[w-15]|0,C=Nt[w-15]|0,M=Ft(B,C,1)^Ft(B,C,8)^cr(B,C,7),$=zt(B,C,1)^zt(B,C,8)^ur(B,C,7),x=Dt[w-2]|0,E=Nt[w-2]|0,O=Ft(x,E,19)^Be(x,E,61)^cr(x,E,6),V=zt(x,E,19)^ve(x,E,61)^ur(x,E,6),D=ra($,V,Nt[w-7],Nt[w-16]),N=sa(D,M,O,Dt[w-7],Dt[w-16]);Dt[w]=N|0,Nt[w]=D|0}let{Ah:r,Al:s,Bh:i,Bl:o,Ch:c,Cl:a,Dh:l,Dl:b,Eh:d,El:A,Fh:S,Fl:p,Gh:_,Gl:y,Hh:R,Hl:m}=this;for(let w=0;w<80;w++){const B=Ft(d,A,14)^Ft(d,A,18)^Be(d,A,41),C=zt(d,A,14)^zt(d,A,18)^ve(d,A,41),M=d&S^~d&_,$=A&p^~A&y,x=ia(m,C,$,ha[w],Nt[w]),E=oa(x,R,B,M,fa[w],Dt[w]),O=x|0,V=Ft(r,s,28)^Be(r,s,34)^Be(r,s,39),D=zt(r,s,28)^ve(r,s,34)^ve(r,s,39),N=r&i^r&c^i&c,f=s&o^s&a^o&a;R=_|0,m=y|0,_=S|0,y=p|0,S=d|0,p=A|0,{h:d,l:A}=Et(l|0,b|0,E|0,O|0),l=c|0,b=a|0,c=i|0,a=o|0,i=r|0,o=s|0;const h=ea(O,D,f);r=na(h,E,V,N),s=h|0}({h:r,l:s}=Et(this.Ah|0,this.Al|0,r|0,s|0)),{h:i,l:o}=Et(this.Bh|0,this.Bl|0,i|0,o|0),{h:c,l:a}=Et(this.Ch|0,this.Cl|0,c|0,a|0),{h:l,l:b}=Et(this.Dh|0,this.Dl|0,l|0,b|0),{h:d,l:A}=Et(this.Eh|0,this.El|0,d|0,A|0),{h:S,l:p}=Et(this.Fh|0,this.Fl|0,S|0,p|0),{h:_,l:y}=Et(this.Gh|0,this.Gl|0,_|0,y|0),{h:R,l:m}=Et(this.Hh|0,this.Hl|0,R|0,m|0),this.set(r,s,i,o,c,a,l,b,d,A,S,p,_,y,R,m)}roundClean(){Jt(Dt,Nt)}destroy(){Jt(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}class da extends la{constructor(){super(64);u(this,"Ah",ot[0]|0);u(this,"Al",ot[1]|0);u(this,"Bh",ot[2]|0);u(this,"Bl",ot[3]|0);u(this,"Ch",ot[4]|0);u(this,"Cl",ot[5]|0);u(this,"Dh",ot[6]|0);u(this,"Dl",ot[7]|0);u(this,"Eh",ot[8]|0);u(this,"El",ot[9]|0);u(this,"Fh",ot[10]|0);u(this,"Fl",ot[11]|0);u(this,"Gh",ot[12]|0);u(this,"Gl",ot[13]|0);u(this,"Hh",ot[14]|0);u(this,"Hl",ot[15]|0)}}const Ye=Hr(()=>new ua,qr(1)),ba=Hr(()=>new da,qr(3));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const In=BigInt(0),bn=BigInt(1);function Ht(e,t=""){if(typeof e!="boolean"){const n=t&&`"${t}" `;throw new Error(n+"expected boolean, got type="+typeof e)}return e}function Zr(e){if(typeof e=="bigint"){if(!Ce(e))throw new Error("positive bigint expected, got "+e)}else Vt(e);return e}function Ie(e){const t=Zr(e).toString(16);return t.length&1?"0"+t:t}function jr(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);return e===""?In:BigInt("0x"+e)}function Xe(e){return jr(pe(e))}function qt(e){return jr(pe(le(H(e)).reverse()))}function _n(e,t){Vt(t),e=Zr(e);const n=he(e.toString(16).padStart(t*2,"0"));if(n.length!==t)throw new Error("number too large");return n}function Ln(e,t){return _n(e,t).reverse()}function le(e){return Uint8Array.from(e)}const Ce=e=>typeof e=="bigint"&&In<=e;function ya(e,t,n){return Ce(e)&&Ce(t)&&Ce(n)&&t<=e&&e<n}function de(e,t,n,r){if(!ya(t,n,r))throw new Error("expected valid "+e+": "+n+" <= n < "+r+", got "+t)}function wa(e){let t;for(t=0;e>In;e>>=bn,t+=1);return t}const Un=e=>(bn<<BigInt(e))-bn;function ga(e,t,n){if(Vt(e,"hashLen"),Vt(t,"qByteLen"),typeof n!="function")throw new Error("hmacFn must be a function");const r=y=>new Uint8Array(y),s=Uint8Array.of(),i=Uint8Array.of(0),o=Uint8Array.of(1),c=1e3;let a=r(e),l=r(e),b=0;const d=()=>{a.fill(1),l.fill(0),b=0},A=(...y)=>n(l,mt(a,...y)),S=(y=s)=>{l=A(i,y),a=A(),y.length!==0&&(l=A(o,y),a=A())},p=()=>{if(b++>=c)throw new Error("drbg: tried max amount of iterations");let y=0;const R=[];for(;y<t;){a=A();const m=a.slice();R.push(m),y+=a.length}return mt(...R)};return(y,R)=>{d(),S(y);let m;for(;!(m=R(p()));)S();return d(),m}}function ne(e,t={},n={}){if(!e||typeof e!="object")throw new Error("expected valid options object");function r(i,o,c){const a=e[i];if(c&&a===void 0)return;const l=typeof a;if(l!==o||a===null)throw new Error(`param "${i}" is invalid: expected ${o}, got ${l}`)}const s=(i,o)=>Object.entries(i).forEach(([c,a])=>r(c,a,o));s(t,!1),s(n,!0)}function Pe(e){const t=new WeakMap;return(n,...r)=>{const s=t.get(n);if(s!==void 0)return s;const i=e(n,...r);return t.set(n,i),i}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const ht=BigInt(0),rt=BigInt(1),kt=BigInt(2),Gr=BigInt(3),Yr=BigInt(4),Xr=BigInt(5),pa=BigInt(7),Wr=BigInt(8),ma=BigInt(9),Jr=BigInt(16);function X(e,t){const n=e%t;return n>=ht?n:t+n}function Y(e,t,n){let r=e;for(;t-- >ht;)r*=r,r%=n;return r}function fr(e,t){if(e===ht)throw new Error("invert: expected non-zero number");if(t<=ht)throw new Error("invert: expected positive modulus, got "+t);let n=X(e,t),r=t,s=ht,i=rt;for(;n!==ht;){const c=r/n,a=r%n,l=s-i*c;r=n,n=a,s=i,i=l}if(r!==rt)throw new Error("invert: does not exist");return X(s,t)}function Rn(e,t,n){if(!e.eql(e.sqr(t),n))throw new Error("Cannot find square root")}function Qr(e,t){const n=(e.ORDER+rt)/Yr,r=e.pow(t,n);return Rn(e,r,t),r}function xa(e,t){const n=(e.ORDER-Xr)/Wr,r=e.mul(t,kt),s=e.pow(r,n),i=e.mul(t,s),o=e.mul(e.mul(i,kt),s),c=e.mul(i,e.sub(o,e.ONE));return Rn(e,c,t),c}function Ea(e){const t=We(e),n=ts(e),r=n(t,t.neg(t.ONE)),s=n(t,r),i=n(t,t.neg(r)),o=(e+pa)/Jr;return(c,a)=>{let l=c.pow(a,o),b=c.mul(l,r);const d=c.mul(l,s),A=c.mul(l,i),S=c.eql(c.sqr(b),a),p=c.eql(c.sqr(d),a);l=c.cmov(l,b,S),b=c.cmov(A,d,p);const _=c.eql(c.sqr(b),a),y=c.cmov(l,b,_);return Rn(c,y,a),y}}function ts(e){if(e<Gr)throw new Error("sqrt is not defined for small field");let t=e-rt,n=0;for(;t%kt===ht;)t/=kt,n++;let r=kt;const s=We(e);for(;hr(s,r)===1;)if(r++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(n===1)return Qr;let i=s.pow(r,t);const o=(t+rt)/kt;return function(a,l){if(a.is0(l))return l;if(hr(a,l)!==1)throw new Error("Cannot find square root");let b=n,d=a.mul(a.ONE,i),A=a.pow(l,t),S=a.pow(l,o);for(;!a.eql(A,a.ONE);){if(a.is0(A))return a.ZERO;let p=1,_=a.sqr(A);for(;!a.eql(_,a.ONE);)if(p++,_=a.sqr(_),p===b)throw new Error("Cannot find square root");const y=rt<<BigInt(b-p-1),R=a.pow(d,y);b=p,d=a.sqr(R),A=a.mul(A,d),S=a.mul(S,R)}return S}}function Aa(e){return e%Yr===Gr?Qr:e%Wr===Xr?xa:e%Jr===ma?Ea(e):ts(e)}const Sa=(e,t)=>(X(e,t)&rt)===rt,Ba=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function va(e){const t={ORDER:"bigint",BYTES:"number",BITS:"number"},n=Ba.reduce((r,s)=>(r[s]="function",r),t);return ne(e,n),e}function Ia(e,t,n){if(n<ht)throw new Error("invalid exponent, negatives unsupported");if(n===ht)return e.ONE;if(n===rt)return t;let r=e.ONE,s=t;for(;n>ht;)n&rt&&(r=e.mul(r,s)),s=e.sqr(s),n>>=rt;return r}function es(e,t,n=!1){const r=new Array(t.length).fill(n?e.ZERO:void 0),s=t.reduce((o,c,a)=>e.is0(c)?o:(r[a]=o,e.mul(o,c)),e.ONE),i=e.inv(s);return t.reduceRight((o,c,a)=>e.is0(c)?o:(r[a]=e.mul(o,r[a]),e.mul(o,c)),i),r}function hr(e,t){const n=(e.ORDER-rt)/kt,r=e.pow(t,n),s=e.eql(r,e.ONE),i=e.eql(r,e.ZERO),o=e.eql(r,e.neg(e.ONE));if(!s&&!i&&!o)throw new Error("invalid Legendre symbol result");return s?1:i?0:-1}function _a(e,t){t!==void 0&&Vt(t);const n=t!==void 0?t:e.toString(2).length,r=Math.ceil(n/8);return{nBitLength:n,nByteLength:r}}class La{constructor(t,n={}){u(this,"ORDER");u(this,"BITS");u(this,"BYTES");u(this,"isLE");u(this,"ZERO",ht);u(this,"ONE",rt);u(this,"_lengths");u(this,"_sqrt");u(this,"_mod");if(t<=ht)throw new Error("invalid field: expected ORDER > 0, got "+t);let r;this.isLE=!1,n!=null&&typeof n=="object"&&(typeof n.BITS=="number"&&(r=n.BITS),typeof n.sqrt=="function"&&(this.sqrt=n.sqrt),typeof n.isLE=="boolean"&&(this.isLE=n.isLE),n.allowedLengths&&(this._lengths=n.allowedLengths?.slice()),typeof n.modFromBytes=="boolean"&&(this._mod=n.modFromBytes));const{nBitLength:s,nByteLength:i}=_a(t,r);if(i>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");this.ORDER=t,this.BITS=s,this.BYTES=i,this._sqrt=void 0,Object.preventExtensions(this)}create(t){return X(t,this.ORDER)}isValid(t){if(typeof t!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof t);return ht<=t&&t<this.ORDER}is0(t){return t===ht}isValidNot0(t){return!this.is0(t)&&this.isValid(t)}isOdd(t){return(t&rt)===rt}neg(t){return X(-t,this.ORDER)}eql(t,n){return t===n}sqr(t){return X(t*t,this.ORDER)}add(t,n){return X(t+n,this.ORDER)}sub(t,n){return X(t-n,this.ORDER)}mul(t,n){return X(t*n,this.ORDER)}pow(t,n){return Ia(this,t,n)}div(t,n){return X(t*fr(n,this.ORDER),this.ORDER)}sqrN(t){return t*t}addN(t,n){return t+n}subN(t,n){return t-n}mulN(t,n){return t*n}inv(t){return fr(t,this.ORDER)}sqrt(t){return this._sqrt||(this._sqrt=Aa(this.ORDER)),this._sqrt(this,t)}toBytes(t){return this.isLE?Ln(t,this.BYTES):_n(t,this.BYTES)}fromBytes(t,n=!1){H(t);const{_lengths:r,BYTES:s,isLE:i,ORDER:o,_mod:c}=this;if(r){if(!r.includes(t.length)||t.length>s)throw new Error("Field.fromBytes: expected "+r+" bytes, got "+t.length);const l=new Uint8Array(s);l.set(t,i?0:l.length-t.length),t=l}if(t.length!==s)throw new Error("Field.fromBytes: expected "+s+" bytes, got "+t.length);let a=i?qt(t):Xe(t);if(c&&(a=X(a,o)),!n&&!this.isValid(a))throw new Error("invalid field element: outside of range 0..ORDER");return a}invertBatch(t){return es(this,t)}cmov(t,n,r){return r?n:t}}function We(e,t={}){return new La(e,t)}function ns(e){if(typeof e!="bigint")throw new Error("field order must be bigint");const t=e.toString(2).length;return Math.ceil(t/8)}function rs(e){const t=ns(e);return t+Math.ceil(t/2)}function Ua(e,t,n=!1){H(e);const r=e.length,s=ns(t),i=rs(t);if(r<16||r<i||r>1024)throw new Error("expected "+i+"-1024 bytes of input, got "+r);const o=n?qt(e):Xe(e),c=X(o,t-rt)+rt;return n?Ln(c,s):_n(c,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Qt=BigInt(0),Pt=BigInt(1);function $e(e,t){const n=t.negate();return e?n:t}function fe(e,t){const n=es(e.Fp,t.map(r=>r.Z));return t.map((r,s)=>e.fromAffine(r.toAffine(n[s])))}function ss(e,t){if(!Number.isSafeInteger(e)||e<=0||e>t)throw new Error("invalid window size, expected [1.."+t+"], got W="+e)}function nn(e,t){ss(e,t);const n=Math.ceil(t/e)+1,r=2**(e-1),s=2**e,i=Un(e),o=BigInt(e);return{windows:n,windowSize:r,mask:i,maxNumber:s,shiftBy:o}}function lr(e,t,n){const{windowSize:r,mask:s,maxNumber:i,shiftBy:o}=n;let c=Number(e&s),a=e>>o;c>r&&(c-=i,a+=Pt);const l=t*r,b=l+Math.abs(c)-1,d=c===0,A=c<0,S=t%2!==0;return{nextN:a,offset:b,isZero:d,isNeg:A,isNegF:S,offsetF:l}}const rn=new WeakMap,is=new WeakMap;function sn(e){return is.get(e)||1}function dr(e){if(e!==Qt)throw new Error("invalid wNAF")}class os{constructor(t,n){u(this,"BASE");u(this,"ZERO");u(this,"Fn");u(this,"bits");this.BASE=t.BASE,this.ZERO=t.ZERO,this.Fn=t.Fn,this.bits=n}_unsafeLadder(t,n,r=this.ZERO){let s=t;for(;n>Qt;)n&Pt&&(r=r.add(s)),s=s.double(),n>>=Pt;return r}precomputeWindow(t,n){const{windows:r,windowSize:s}=nn(n,this.bits),i=[];let o=t,c=o;for(let a=0;a<r;a++){c=o,i.push(c);for(let l=1;l<s;l++)c=c.add(o),i.push(c);o=c.double()}return i}wNAF(t,n,r){if(!this.Fn.isValid(r))throw new Error("invalid scalar");let s=this.ZERO,i=this.BASE;const o=nn(t,this.bits);for(let c=0;c<o.windows;c++){const{nextN:a,offset:l,isZero:b,isNeg:d,isNegF:A,offsetF:S}=lr(r,c,o);r=a,b?i=i.add($e(A,n[S])):s=s.add($e(d,n[l]))}return dr(r),{p:s,f:i}}wNAFUnsafe(t,n,r,s=this.ZERO){const i=nn(t,this.bits);for(let o=0;o<i.windows&&r!==Qt;o++){const{nextN:c,offset:a,isZero:l,isNeg:b}=lr(r,o,i);if(r=c,!l){const d=n[a];s=s.add(b?d.negate():d)}}return dr(r),s}getPrecomputes(t,n,r){let s=rn.get(n);return s||(s=this.precomputeWindow(n,t),t!==1&&(typeof r=="function"&&(s=r(s)),rn.set(n,s))),s}cached(t,n,r){const s=sn(t);return this.wNAF(s,this.getPrecomputes(s,t,r),n)}unsafe(t,n,r,s){const i=sn(t);return i===1?this._unsafeLadder(t,n,s):this.wNAFUnsafe(i,this.getPrecomputes(i,t,r),n,s)}createCache(t,n){ss(n,this.bits),is.set(t,n),rn.delete(t)}hasCache(t){return sn(t)!==1}}function Ra(e,t,n,r){let s=t,i=e.ZERO,o=e.ZERO;for(;n>Qt||r>Qt;)n&Pt&&(i=i.add(s)),r&Pt&&(o=o.add(s)),s=s.double(),n>>=Pt,r>>=Pt;return{p1:i,p2:o}}function br(e,t,n){if(t){if(t.ORDER!==e)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return va(t),t}else return We(e,{isLE:n})}function as(e,t,n={},r){if(r===void 0&&(r=e==="edwards"),!t||typeof t!="object")throw new Error(`expected valid ${e} CURVE object`);for(const a of["p","n","h"]){const l=t[a];if(!(typeof l=="bigint"&&l>Qt))throw new Error(`CURVE.${a} must be positive bigint`)}const s=br(t.p,n.Fp,r),i=br(t.n,n.Fn,r),c=["Gx","Gy","a",e==="weierstrass"?"b":"d"];for(const a of c)if(!s.isValid(t[a]))throw new Error(`CURVE.${a} must be valid field element of CURVE.Fp`);return t=Object.freeze(Object.assign({},t)),{CURVE:t,Fp:s,Fn:i}}function Dn(e,t){return function(r){const s=e(r);return{secretKey:s,publicKey:t(s)}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Tt=BigInt(0),tt=BigInt(1),on=BigInt(2),Da=BigInt(8);function Na(e,t,n,r){const s=e.sqr(n),i=e.sqr(r),o=e.add(e.mul(t.a,s),i),c=e.add(e.ONE,e.mul(t.d,e.mul(s,i)));return e.eql(o,c)}function Ta(e,t={}){const n=as("edwards",e,t,t.FpFnLE),{Fp:r,Fn:s}=n;let i=n.CURVE;const{h:o}=i;ne(t,{},{uvRatio:"function"});const c=on<<BigInt(s.BYTES*8)-tt,a=R=>r.create(R),l=t.uvRatio||((R,m)=>{try{return{isValid:!0,value:r.sqrt(r.div(R,m))}}catch{return{isValid:!1,value:Tt}}});if(!Na(r,i,i.Gx,i.Gy))throw new Error("bad curve params: generator point");function b(R,m,w=!1){const B=w?tt:Tt;return de("coordinate "+R,m,B,c),m}function d(R){if(!(R instanceof p))throw new Error("EdwardsPoint expected")}const A=Pe((R,m)=>{const{X:w,Y:B,Z:C}=R,M=R.is0();m==null&&(m=M?Da:r.inv(C));const $=a(w*m),x=a(B*m),E=r.mul(C,m);if(M)return{x:Tt,y:tt};if(E!==tt)throw new Error("invZ was invalid");return{x:$,y:x}}),S=Pe(R=>{const{a:m,d:w}=i;if(R.is0())throw new Error("bad point: ZERO");const{X:B,Y:C,Z:M,T:$}=R,x=a(B*B),E=a(C*C),O=a(M*M),V=a(O*O),D=a(x*m),N=a(O*a(D+E)),f=a(V+a(w*a(x*E)));if(N!==f)throw new Error("bad point: equation left != right (1)");const h=a(B*C),g=a(M*$);if(h!==g)throw new Error("bad point: equation left != right (2)");return!0}),y=class y{constructor(m,w,B,C){u(this,"X");u(this,"Y");u(this,"Z");u(this,"T");this.X=b("x",m),this.Y=b("y",w),this.Z=b("z",B,!0),this.T=b("t",C),Object.freeze(this)}static CURVE(){return i}static fromAffine(m){if(m instanceof y)throw new Error("extended point not allowed");const{x:w,y:B}=m||{};return b("x",w),b("y",B),new y(w,B,tt,a(w*B))}static fromBytes(m,w=!1){const B=r.BYTES,{a:C,d:M}=i;m=le(H(m,B,"point")),Ht(w,"zip215");const $=le(m),x=m[B-1];$[B-1]=x&-129;const E=qt($),O=w?c:r.ORDER;de("point.y",E,Tt,O);const V=a(E*E),D=a(V-tt),N=a(M*V-C);let{isValid:f,value:h}=l(D,N);if(!f)throw new Error("bad point: invalid y coordinate");const g=(h&tt)===tt,v=(x&128)!==0;if(!w&&h===Tt&&v)throw new Error("bad point: x=0 and x_0=1");return v!==g&&(h=a(-h)),y.fromAffine({x:h,y:E})}static fromHex(m,w=!1){return y.fromBytes(he(m),w)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(m=8,w=!0){return _.createCache(this,m),w||this.multiply(on),this}assertValidity(){S(this)}equals(m){d(m);const{X:w,Y:B,Z:C}=this,{X:M,Y:$,Z:x}=m,E=a(w*x),O=a(M*C),V=a(B*x),D=a($*C);return E===O&&V===D}is0(){return this.equals(y.ZERO)}negate(){return new y(a(-this.X),this.Y,this.Z,a(-this.T))}double(){const{a:m}=i,{X:w,Y:B,Z:C}=this,M=a(w*w),$=a(B*B),x=a(on*a(C*C)),E=a(m*M),O=w+B,V=a(a(O*O)-M-$),D=E+$,N=D-x,f=E-$,h=a(V*N),g=a(D*f),v=a(V*f),L=a(N*D);return new y(h,g,L,v)}add(m){d(m);const{a:w,d:B}=i,{X:C,Y:M,Z:$,T:x}=this,{X:E,Y:O,Z:V,T:D}=m,N=a(C*E),f=a(M*O),h=a(x*B*D),g=a($*V),v=a((C+M)*(E+O)-N-f),L=g-h,U=g+h,T=a(f-w*N),I=a(v*L),K=a(U*T),P=a(v*T),Z=a(L*U);return new y(I,K,Z,P)}subtract(m){return this.add(m.negate())}multiply(m){if(!s.isValidNot0(m))throw new Error("invalid scalar: expected 1 <= sc < curve.n");const{p:w,f:B}=_.cached(this,m,C=>fe(y,C));return fe(y,[w,B])[0]}multiplyUnsafe(m,w=y.ZERO){if(!s.isValid(m))throw new Error("invalid scalar: expected 0 <= sc < curve.n");return m===Tt?y.ZERO:this.is0()||m===tt?this:_.unsafe(this,m,B=>fe(y,B),w)}isSmallOrder(){return this.multiplyUnsafe(o).is0()}isTorsionFree(){return _.unsafe(this,i.n).is0()}toAffine(m){return A(this,m)}clearCofactor(){return o===tt?this:this.multiplyUnsafe(o)}toBytes(){const{x:m,y:w}=this.toAffine(),B=r.toBytes(w);return B[B.length-1]|=m&tt?128:0,B}toHex(){return pe(this.toBytes())}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}};u(y,"BASE",new y(i.Gx,i.Gy,tt,a(i.Gx*i.Gy))),u(y,"ZERO",new y(Tt,tt,tt,Tt)),u(y,"Fp",r),u(y,"Fn",s);let p=y;const _=new os(p,s.BITS);return p.BASE.precompute(8),p}function Ca(e,t,n={}){if(typeof t!="function")throw new Error('"hash" function param is required');ne(n,{},{adjustScalarBytes:"function",randomBytes:"function",domain:"function",prehash:"function",mapToCurve:"function"});const{prehash:r}=n,{BASE:s,Fp:i,Fn:o}=e,c=n.randomBytes||me,a=n.adjustScalarBytes||(x=>x),l=n.domain||((x,E,O)=>{if(Ht(O,"phflag"),E.length||O)throw new Error("Contexts/pre-hash are not supported");return x});function b(x){return o.create(qt(x))}function d(x){const E=w.secretKey;H(x,w.secretKey,"secretKey");const O=H(t(x),2*E,"hashedSecretKey"),V=a(O.slice(0,E)),D=O.slice(E,2*E),N=b(V);return{head:V,prefix:D,scalar:N}}function A(x){const{head:E,prefix:O,scalar:V}=d(x),D=s.multiply(V),N=D.toBytes();return{head:E,prefix:O,scalar:V,point:D,pointBytes:N}}function S(x){return A(x).pointBytes}function p(x=Uint8Array.of(),...E){const O=mt(...E);return b(t(l(O,H(x,void 0,"context"),!!r)))}function _(x,E,O={}){x=H(x,void 0,"message"),r&&(x=r(x));const{prefix:V,scalar:D,pointBytes:N}=A(E),f=p(O.context,V,x),h=s.multiply(f).toBytes(),g=p(O.context,h,N,x),v=o.create(f+g*D);if(!o.isValid(v))throw new Error("sign failed: invalid s");const L=mt(h,o.toBytes(v));return H(L,w.signature,"result")}const y={zip215:!0};function R(x,E,O,V=y){const{context:D,zip215:N}=V,f=w.signature;x=H(x,f,"signature"),E=H(E,void 0,"message"),O=H(O,w.publicKey,"publicKey"),N!==void 0&&Ht(N,"zip215"),r&&(E=r(E));const h=f/2,g=x.subarray(0,h),v=qt(x.subarray(h,f));let L,U,T;try{L=e.fromBytes(O,N),U=e.fromBytes(g,N),T=s.multiplyUnsafe(v)}catch{return!1}if(!N&&L.isSmallOrder())return!1;const I=p(D,U.toBytes(),L.toBytes(),E);return U.add(L.multiplyUnsafe(I)).subtract(T).clearCofactor().is0()}const m=i.BYTES,w={secretKey:m,publicKey:m,signature:2*m,seed:m};function B(x=c(w.seed)){return H(x,w.seed,"seed")}function C(x){return Ge(x)&&x.length===o.BYTES}function M(x,E){try{return!!e.fromBytes(x,E)}catch{return!1}}const $={getExtendedPublicKey:A,randomSecretKey:B,isValidSecretKey:C,isValidPublicKey:M,toMontgomery(x){const{y:E}=e.fromBytes(x),O=w.publicKey,V=O===32;if(!V&&O!==57)throw new Error("only defined for 25519 and 448");const D=V?i.div(tt+E,tt-E):i.div(E-tt,E+tt);return i.toBytes(D)},toMontgomerySecret(x){const E=w.secretKey;H(x,E);const O=t(x.subarray(0,E));return a(O).subarray(0,E)}};return Object.freeze({keygen:Dn(B,S),getPublicKey:S,sign:_,verify:R,utils:$,Point:e,lengths:w})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const oe=BigInt(0),Zt=BigInt(1),_e=BigInt(2);function Ka(e){return ne(e,{adjustScalarBytes:"function",powPminus2:"function"}),Object.freeze({...e})}function Oa(e){const t=Ka(e),{P:n,type:r,adjustScalarBytes:s,powPminus2:i,randomBytes:o}=t,c=r==="x25519";if(!c&&r!=="x448")throw new Error("invalid type");const a=o||me,l=c?255:448,b=c?32:56,d=BigInt(c?9:5),A=BigInt(c?121665:39081),S=c?_e**BigInt(254):_e**BigInt(447),p=c?BigInt(8)*_e**BigInt(251)-Zt:BigInt(4)*_e**BigInt(445)-Zt,_=S+p+Zt,y=f=>X(f,n),R=m(d);function m(f){return Ln(y(f),b)}function w(f){const h=le(H(f,b,"uCoordinate"));return c&&(h[31]&=127),y(qt(h))}function B(f){return qt(s(le(H(f,b,"scalar"))))}function C(f,h){const g=O(w(h),B(f));if(g===oe)throw new Error("invalid private or public key received");return m(g)}function M(f){return C(f,R)}const $=M,x=C;function E(f,h,g){const v=y(f*(h-g));return h=y(h-v),g=y(g+v),{x_2:h,x_3:g}}function O(f,h){de("u",f,oe,n),de("scalar",h,S,_);const g=h,v=f;let L=Zt,U=oe,T=f,I=Zt,K=oe;for(let Z=BigInt(l-1);Z>=oe;Z--){const F=g>>Z&Zt;K^=F,{x_2:L,x_3:T}=E(K,L,T),{x_2:U,x_3:I}=E(K,U,I),K=F;const k=L+U,W=y(k*k),Q=L-U,it=y(Q*Q),j=W-it,et=T+I,Ee=T-I,re=y(Ee*k),qn=y(et*Q),Fn=re+qn,zn=re-qn;T=y(Fn*Fn),I=y(v*y(zn*zn)),L=y(W*it),U=y(j*(W+y(A*j)))}({x_2:L,x_3:T}=E(K,L,T)),{x_2:U,x_3:I}=E(K,U,I);const P=i(U);return y(L*P)}const V={secretKey:b,publicKey:b,seed:b},D=(f=a(b))=>(H(f,V.seed,"seed"),f),N={randomSecretKey:D};return Object.freeze({keygen:Dn(D,$),getSharedSecret:x,getPublicKey:$,scalarMult:C,scalarMultBase:M,utils:N,GuBytes:R.slice(),lengths:V})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ma=BigInt(1),yr=BigInt(2),ka=BigInt(3),Pa=BigInt(5),$a=BigInt(8),Je=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"),Va={p:Je,n:BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),h:$a,a:BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),d:BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),Gx:BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),Gy:BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")};function cs(e){const t=BigInt(10),n=BigInt(20),r=BigInt(40),s=BigInt(80),i=Je,c=e*e%i*e%i,a=Y(c,yr,i)*c%i,l=Y(a,Ma,i)*e%i,b=Y(l,Pa,i)*l%i,d=Y(b,t,i)*b%i,A=Y(d,n,i)*d%i,S=Y(A,r,i)*A%i,p=Y(S,s,i)*S%i,_=Y(p,s,i)*S%i,y=Y(_,t,i)*b%i;return{pow_p_5_8:Y(y,yr,i)*e%i,b2:c}}function us(e){return e[0]&=248,e[31]&=127,e[31]|=64,e}const wr=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");function Ha(e,t){const n=Je,r=X(t*t*t,n),s=X(r*r*t,n),i=cs(e*s).pow_p_5_8;let o=X(e*r*i,n);const c=X(t*o*o,n),a=o,l=X(o*wr,n),b=c===e,d=c===X(-e,n),A=c===X(-e*wr,n);return b&&(o=a),(d||A)&&(o=l),Sa(o,n)&&(o=X(-o,n)),{isValid:b||d,value:o}}const qa=Ta(Va,{uvRatio:Ha});function Fa(e){return Ca(qa,ba,Object.assign({adjustScalarBytes:us},e))}const Ve=Fa({}),Ru=(()=>{const e=Je;return Oa({P:e,type:"x25519",powPminus2:t=>{const{pow_p_5_8:n,b2:r}=cs(t);return X(Y(n,ka,e)*r,e)},adjustScalarBytes:us})})();class gr extends Error{constructor(t="An error occurred while signing a message"){super(t),this.name="SigningError"}}class pr extends Error{constructor(t="An error occurred while verifying a message"){super(t),this.name="VerificationError"}}class za extends Error{constructor(t="Missing Web Crypto API"){super(t),this.name="WebCryptoMissingError"}}const yt={get(e=globalThis){const t=e.crypto;if(t?.subtle==null)throw new za("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p/blob/main/packages/crypto/README.md#web-crypto-api");return t}},He=32,At=64,yn=32;let Xt;const fs=(async()=>{try{return await yt.get().subtle.generateKey({name:"Ed25519"},!0,["sign","verify"]),!0}catch{return!1}})();function Za(){const e=Ve.utils.randomSecretKey(),t=Ve.getPublicKey(e);return{privateKey:Qa(e,t),publicKey:t}}async function ja(e,t){let n;e.length===At?n=e.subarray(0,32):n=e;const r={crv:"Ed25519",kty:"OKP",x:z(e.subarray(32),"base64url"),d:z(n,"base64url"),ext:!0,key_ops:["sign"]},s=await yt.get().subtle.importKey("jwk",r,{name:"Ed25519"},!0,["sign"]),i=await yt.get().subtle.sign({name:"Ed25519"},s,t instanceof Uint8Array?t:t.subarray());return new Uint8Array(i,0,i.byteLength)}function Ga(e,t){const n=e.subarray(0,yn);return Ve.sign(t instanceof Uint8Array?t:t.subarray(),n)}async function Ya(e,t){return Xt==null&&(Xt=await fs),Xt?ja(e,t):Ga(e,t)}async function Xa(e,t,n){if(e.buffer instanceof ArrayBuffer){const r=await yt.get().subtle.importKey("raw",e.buffer,{name:"Ed25519"},!1,["verify"]);return await yt.get().subtle.verify({name:"Ed25519"},r,t,n instanceof Uint8Array?n:n.subarray())}throw new TypeError("WebCrypto does not support SharedArrayBuffer for Ed25519 keys")}function Wa(e,t,n){return Ve.verify(t,n instanceof Uint8Array?n:n.subarray(),e)}async function Ja(e,t,n){return Xt==null&&(Xt=await fs),Xt?Xa(e,t,n):Wa(e,t,n)}function Qa(e,t){const n=new Uint8Array(At);for(let r=0;r<yn;r++)n[r]=e[r],n[yn+r]=t[r];return n}function Qe(e){return e==null?!1:typeof e.then=="function"&&typeof e.catch=="function"&&typeof e.finally=="function"}class hs{constructor(t){u(this,"type","Ed25519");u(this,"raw");this.raw=be(t,He)}toMultihash(){return Bn.digest(Hn(this))}toCID(){return J.createV1(114,this.toMultihash())}toString(){return bt.encode(this.toMultihash().bytes).substring(1)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:It(this.raw,t.raw)}verify(t,n,r){r?.signal?.throwIfAborted();const s=Ja(this.raw,n,t);return Qe(s)?s.then(i=>(r?.signal?.throwIfAborted(),i)):s}}class wn{constructor(t,n){u(this,"type","Ed25519");u(this,"raw");u(this,"publicKey");this.raw=be(t,At),this.publicKey=new hs(n)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:It(this.raw,t.raw)}sign(t,n){n?.signal?.throwIfAborted();const r=Ya(this.raw,t);return Qe(r)?r.then(s=>(n?.signal?.throwIfAborted(),s)):(n?.signal?.throwIfAborted(),r)}}function tc(e){if(e.length>At){e=be(e,At+He);const r=e.subarray(0,At),s=e.subarray(At,e.length);return new wn(r,s)}e=be(e,At);const t=e.subarray(0,At),n=e.subarray(He);return new wn(t,n)}function ls(e){return e=be(e,He),new hs(e)}async function ec(){const{privateKey:e,publicKey:t}=Za();return new wn(e,t)}function be(e,t){if(e=Uint8Array.from(e??[]),e.length!==t)throw new lt(`Key must be a Uint8Array of length ${t}, got ${e.length}`);return e}const nc=Math.pow(2,7),rc=Math.pow(2,14),sc=Math.pow(2,21),Nn=Math.pow(2,28),Tn=Math.pow(2,35),Cn=Math.pow(2,42),Kn=Math.pow(2,49),q=128,at=127;function xe(e){if(e<nc)return 1;if(e<rc)return 2;if(e<sc)return 3;if(e<Nn)return 4;if(e<Tn)return 5;if(e<Cn)return 6;if(e<Kn)return 7;if(Number.MAX_SAFE_INTEGER!=null&&e>Number.MAX_SAFE_INTEGER)throw new RangeError("Could not encode varint");return 8}function ds(e,t,n=0){switch(xe(e)){case 8:t[n++]=e&255|q,e/=128;case 7:t[n++]=e&255|q,e/=128;case 6:t[n++]=e&255|q,e/=128;case 5:t[n++]=e&255|q,e/=128;case 4:t[n++]=e&255|q,e>>>=7;case 3:t[n++]=e&255|q,e>>>=7;case 2:t[n++]=e&255|q,e>>>=7;case 1:{t[n++]=e&255,e>>>=7;break}default:throw new Error("unreachable")}return t}function ic(e,t,n=0){switch(xe(e)){case 8:t.set(n++,e&255|q),e/=128;case 7:t.set(n++,e&255|q),e/=128;case 6:t.set(n++,e&255|q),e/=128;case 5:t.set(n++,e&255|q),e/=128;case 4:t.set(n++,e&255|q),e>>>=7;case 3:t.set(n++,e&255|q),e>>>=7;case 2:t.set(n++,e&255|q),e>>>=7;case 1:{t.set(n++,e&255),e>>>=7;break}default:throw new Error("unreachable")}return t}function bs(e,t){let n=e[t],r=0;if(r+=n&at,n<q||(n=e[t+1],r+=(n&at)<<7,n<q)||(n=e[t+2],r+=(n&at)<<14,n<q)||(n=e[t+3],r+=(n&at)<<21,n<q)||(n=e[t+4],r+=(n&at)*Nn,n<q)||(n=e[t+5],r+=(n&at)*Tn,n<q)||(n=e[t+6],r+=(n&at)*Cn,n<q)||(n=e[t+7],r+=(n&at)*Kn,n<q))return r;throw new RangeError("Could not decode varint")}function oc(e,t){let n=e.get(t),r=0;if(r+=n&at,n<q||(n=e.get(t+1),r+=(n&at)<<7,n<q)||(n=e.get(t+2),r+=(n&at)<<14,n<q)||(n=e.get(t+3),r+=(n&at)<<21,n<q)||(n=e.get(t+4),r+=(n&at)*Nn,n<q)||(n=e.get(t+5),r+=(n&at)*Tn,n<q)||(n=e.get(t+6),r+=(n&at)*Cn,n<q)||(n=e.get(t+7),r+=(n&at)*Kn,n<q))return r;throw new RangeError("Could not decode varint")}function Du(e,t,n=0){return t==null&&(t=Ot(xe(e))),t instanceof Uint8Array?ds(e,t,n):ic(e,t,n)}function Nu(e,t=0){return e instanceof Uint8Array?bs(e,t):oc(e,t)}const On=new Float32Array([-0]),Kt=new Uint8Array(On.buffer);function ac(e,t,n){On[0]=e,t[n]=Kt[0],t[n+1]=Kt[1],t[n+2]=Kt[2],t[n+3]=Kt[3]}function cc(e,t){return Kt[0]=e[t],Kt[1]=e[t+1],Kt[2]=e[t+2],Kt[3]=e[t+3],On[0]}const Mn=new Float64Array([-0]),ct=new Uint8Array(Mn.buffer);function uc(e,t,n){Mn[0]=e,t[n]=ct[0],t[n+1]=ct[1],t[n+2]=ct[2],t[n+3]=ct[3],t[n+4]=ct[4],t[n+5]=ct[5],t[n+6]=ct[6],t[n+7]=ct[7]}function fc(e,t){return ct[0]=e[t],ct[1]=e[t+1],ct[2]=e[t+2],ct[3]=e[t+3],ct[4]=e[t+4],ct[5]=e[t+5],ct[6]=e[t+6],ct[7]=e[t+7],Mn[0]}const hc=BigInt(Number.MAX_SAFE_INTEGER),lc=BigInt(Number.MIN_SAFE_INTEGER);class ut{constructor(t,n){u(this,"lo");u(this,"hi");this.lo=t|0,this.hi=n|0}toNumber(t=!1){if(!t&&this.hi>>>31>0){const n=~this.lo+1>>>0;let r=~this.hi>>>0;return n===0&&(r=r+1>>>0),-(n+r*4294967296)}return this.lo+this.hi*4294967296}toBigInt(t=!1){if(t)return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n);if(this.hi>>>31){const n=~this.lo+1>>>0;let r=~this.hi>>>0;return n===0&&(r=r+1>>>0),-(BigInt(n)+(BigInt(r)<<32n))}return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n)}toString(t=!1){return this.toBigInt(t).toString()}zzEncode(){const t=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^t)>>>0,this.lo=(this.lo<<1^t)>>>0,this}zzDecode(){const t=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^t)>>>0,this.hi=(this.hi>>>1^t)>>>0,this}length(){const t=this.lo,n=(this.lo>>>28|this.hi<<4)>>>0,r=this.hi>>>24;return r===0?n===0?t<16384?t<128?1:2:t<2097152?3:4:n<16384?n<128?5:6:n<2097152?7:8:r<128?9:10}static fromBigInt(t){if(t===0n)return $t;if(t<hc&&t>lc)return this.fromNumber(Number(t));const n=t<0n;n&&(t=-t);let r=t>>32n,s=t-(r<<32n);return n&&(r=~r|0n,s=~s|0n,++s>mr&&(s=0n,++r>mr&&(r=0n))),new ut(Number(s),Number(r))}static fromNumber(t){if(t===0)return $t;const n=t<0;n&&(t=-t);let r=t>>>0,s=(t-r)/4294967296>>>0;return n&&(s=~s>>>0,r=~r>>>0,++r>4294967295&&(r=0,++s>4294967295&&(s=0))),new ut(r,s)}static from(t){return typeof t=="number"?ut.fromNumber(t):typeof t=="bigint"?ut.fromBigInt(t):typeof t=="string"?ut.fromBigInt(BigInt(t)):t.low!=null||t.high!=null?new ut(t.low>>>0,t.high>>>0):$t}}const $t=new ut(0,0);$t.toBigInt=function(){return 0n};$t.zzEncode=$t.zzDecode=function(){return this};$t.length=function(){return 1};const mr=4294967296n;function dc(e){let t=0,n=0;for(let r=0;r<e.length;++r)n=e.charCodeAt(r),n<128?t+=1:n<2048?t+=2:(n&64512)===55296&&(e.charCodeAt(r+1)&64512)===56320?(++r,t+=4):t+=3;return t}function bc(e,t,n){if(n-t<1)return"";let s;const i=[];let o=0,c;for(;t<n;)c=e[t++],c<128?i[o++]=c:c>191&&c<224?i[o++]=(c&31)<<6|e[t++]&63:c>239&&c<365?(c=((c&7)<<18|(e[t++]&63)<<12|(e[t++]&63)<<6|e[t++]&63)-65536,i[o++]=55296+(c>>10),i[o++]=56320+(c&1023)):i[o++]=(c&15)<<12|(e[t++]&63)<<6|e[t++]&63,o>8191&&((s??(s=[])).push(String.fromCharCode.apply(String,i)),o=0);return s!=null?(o>0&&s.push(String.fromCharCode.apply(String,i.slice(0,o))),s.join("")):String.fromCharCode.apply(String,i.slice(0,o))}function ys(e,t,n){const r=n;let s,i;for(let o=0;o<e.length;++o)s=e.charCodeAt(o),s<128?t[n++]=s:s<2048?(t[n++]=s>>6|192,t[n++]=s&63|128):(s&64512)===55296&&((i=e.charCodeAt(o+1))&64512)===56320?(s=65536+((s&1023)<<10)+(i&1023),++o,t[n++]=s>>18|240,t[n++]=s>>12&63|128,t[n++]=s>>6&63|128,t[n++]=s&63|128):(t[n++]=s>>12|224,t[n++]=s>>6&63|128,t[n++]=s&63|128);return n-r}function wt(e,t){return RangeError(`index out of range: ${e.pos} + ${t??1} > ${e.len}`)}function Le(e,t){return(e[t-4]|e[t-3]<<8|e[t-2]<<16|e[t-1]<<24)>>>0}class yc{constructor(t){u(this,"buf");u(this,"pos");u(this,"len");u(this,"_slice",Uint8Array.prototype.subarray);this.buf=t,this.pos=0,this.len=t.length}uint32(){let t=4294967295;if(t=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(t=(t|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return t;if((this.pos+=5)>this.len)throw this.pos=this.len,wt(this,10);return t}int32(){return this.uint32()|0}sint32(){const t=this.uint32();return t>>>1^-(t&1)|0}bool(){return this.uint32()!==0}fixed32(){if(this.pos+4>this.len)throw wt(this,4);return Le(this.buf,this.pos+=4)}sfixed32(){if(this.pos+4>this.len)throw wt(this,4);return Le(this.buf,this.pos+=4)|0}float(){if(this.pos+4>this.len)throw wt(this,4);const t=cc(this.buf,this.pos);return this.pos+=4,t}double(){if(this.pos+8>this.len)throw wt(this,4);const t=fc(this.buf,this.pos);return this.pos+=8,t}bytes(){const t=this.uint32(),n=this.pos,r=this.pos+t;if(r>this.len)throw wt(this,t);return this.pos+=t,n===r?new Uint8Array(0):this.buf.subarray(n,r)}string(){const t=this.bytes();return bc(t,0,t.length)}skip(t){if(typeof t=="number"){if(this.pos+t>this.len)throw wt(this,t);this.pos+=t}else do if(this.pos>=this.len)throw wt(this);while(this.buf[this.pos++]&128);return this}skipType(t){switch(t){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(t=this.uint32()&7)!==4;)this.skipType(t);break;case 5:this.skip(4);break;default:throw Error(`invalid wire type ${t} at offset ${this.pos}`)}return this}readLongVarint(){const t=new ut(0,0);let n=0;if(this.len-this.pos>4){for(;n<4;++n)if(t.lo=(t.lo|(this.buf[this.pos]&127)<<n*7)>>>0,this.buf[this.pos++]<128)return t;if(t.lo=(t.lo|(this.buf[this.pos]&127)<<28)>>>0,t.hi=(t.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return t;n=0}else{for(;n<3;++n){if(this.pos>=this.len)throw wt(this);if(t.lo=(t.lo|(this.buf[this.pos]&127)<<n*7)>>>0,this.buf[this.pos++]<128)return t}return t.lo=(t.lo|(this.buf[this.pos++]&127)<<n*7)>>>0,t}if(this.len-this.pos>4){for(;n<5;++n)if(t.hi=(t.hi|(this.buf[this.pos]&127)<<n*7+3)>>>0,this.buf[this.pos++]<128)return t}else for(;n<5;++n){if(this.pos>=this.len)throw wt(this);if(t.hi=(t.hi|(this.buf[this.pos]&127)<<n*7+3)>>>0,this.buf[this.pos++]<128)return t}throw Error("invalid varint encoding")}readFixed64(){if(this.pos+8>this.len)throw wt(this,8);const t=Le(this.buf,this.pos+=4),n=Le(this.buf,this.pos+=4);return new ut(t,n)}int64(){return this.readLongVarint().toBigInt()}int64Number(){return this.readLongVarint().toNumber()}int64String(){return this.readLongVarint().toString()}uint64(){return this.readLongVarint().toBigInt(!0)}uint64Number(){const t=bs(this.buf,this.pos);return this.pos+=xe(t),t}uint64String(){return this.readLongVarint().toString(!0)}sint64(){return this.readLongVarint().zzDecode().toBigInt()}sint64Number(){return this.readLongVarint().zzDecode().toNumber()}sint64String(){return this.readLongVarint().zzDecode().toString()}fixed64(){return this.readFixed64().toBigInt()}fixed64Number(){return this.readFixed64().toNumber()}fixed64String(){return this.readFixed64().toString()}sfixed64(){return this.readFixed64().toBigInt()}sfixed64Number(){return this.readFixed64().toNumber()}sfixed64String(){return this.readFixed64().toString()}}function wc(e){return new yc(e instanceof Uint8Array?e:e.subarray())}function ws(e,t,n){const r=wc(e);return t.decode(r,void 0,n)}function gc(e){let r,s=8192;return function(o){if(o<1||o>4096)return Ot(o);s+o>8192&&(r=Ot(8192),s=0);const c=r.subarray(s,s+=o);return s&7&&(s=(s|7)+1),c}}class ce{constructor(t,n,r){u(this,"fn");u(this,"len");u(this,"next");u(this,"val");this.fn=t,this.len=n,this.next=void 0,this.val=r}}function an(){}class pc{constructor(t){u(this,"head");u(this,"tail");u(this,"len");u(this,"next");this.head=t.head,this.tail=t.tail,this.len=t.len,this.next=t.states}}const mc=gc();function xc(e){return globalThis.Buffer!=null?Ot(e):mc(e)}class gn{constructor(){u(this,"len");u(this,"head");u(this,"tail");u(this,"states");this.len=0,this.head=new ce(an,0,0),this.tail=this.head,this.states=null}_push(t,n,r){return this.tail=this.tail.next=new ce(t,n,r),this.len+=n,this}uint32(t){return this.len+=(this.tail=this.tail.next=new Ac((t=t>>>0)<128?1:t<16384?2:t<2097152?3:t<268435456?4:5,t)).len,this}int32(t){return t<0?this._push(Ue,10,ut.fromNumber(t)):this.uint32(t)}sint32(t){return this.uint32((t<<1^t>>31)>>>0)}uint64(t){const n=ut.fromBigInt(t);return this._push(Ue,n.length(),n)}uint64Number(t){return this._push(ds,xe(t),t)}uint64String(t){return this.uint64(BigInt(t))}int64(t){return this.uint64(t)}int64Number(t){return this.uint64Number(t)}int64String(t){return this.uint64String(t)}sint64(t){const n=ut.fromBigInt(t).zzEncode();return this._push(Ue,n.length(),n)}sint64Number(t){const n=ut.fromNumber(t).zzEncode();return this._push(Ue,n.length(),n)}sint64String(t){return this.sint64(BigInt(t))}bool(t){return this._push(cn,1,t?1:0)}fixed32(t){return this._push(ae,4,t>>>0)}sfixed32(t){return this.fixed32(t)}fixed64(t){const n=ut.fromBigInt(t);return this._push(ae,4,n.lo)._push(ae,4,n.hi)}fixed64Number(t){const n=ut.fromNumber(t);return this._push(ae,4,n.lo)._push(ae,4,n.hi)}fixed64String(t){return this.fixed64(BigInt(t))}sfixed64(t){return this.fixed64(t)}sfixed64Number(t){return this.fixed64Number(t)}sfixed64String(t){return this.fixed64String(t)}float(t){return this._push(ac,4,t)}double(t){return this._push(uc,8,t)}bytes(t){const n=t.length>>>0;return n===0?this._push(cn,1,0):this.uint32(n)._push(Sc,n,t)}string(t){const n=dc(t);return n!==0?this.uint32(n)._push(ys,n,t):this._push(cn,1,0)}fork(){return this.states=new pc(this),this.head=this.tail=new ce(an,0,0),this.len=0,this}reset(){return this.states!=null?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new ce(an,0,0),this.len=0),this}ldelim(){const t=this.head,n=this.tail,r=this.len;return this.reset().uint32(r),r!==0&&(this.tail.next=t.next,this.tail=n,this.len+=r),this}finish(){let t=this.head.next;const n=xc(this.len);let r=0;for(;t!=null;)t.fn(t.val,n,r),r+=t.len,t=t.next;return n}}function cn(e,t,n){t[n]=e&255}function Ec(e,t,n){for(;e>127;)t[n++]=e&127|128,e>>>=7;t[n]=e}class Ac extends ce{constructor(n,r){super(Ec,n,r);u(this,"next");this.next=void 0}}function Ue(e,t,n){for(;e.hi!==0;)t[n++]=e.lo&127|128,e.lo=(e.lo>>>7|e.hi<<25)>>>0,e.hi>>>=7;for(;e.lo>127;)t[n++]=e.lo&127|128,e.lo=e.lo>>>7;t[n++]=e.lo}function ae(e,t,n){t[n]=e&255,t[n+1]=e>>>8&255,t[n+2]=e>>>16&255,t[n+3]=e>>>24}function Sc(e,t,n){t.set(e,n)}globalThis.Buffer!=null&&(gn.prototype.bytes=function(e){const t=e.length>>>0;return this.uint32(t),t>0&&this._push(Bc,t,e),this},gn.prototype.string=function(e){const t=globalThis.Buffer.byteLength(e);return this.uint32(t),t>0&&this._push(vc,t,e),this});function Bc(e,t,n){t.set(e,n)}function vc(e,t,n){e.length<40?ys(e,t,n):t.utf8Write!=null?t.utf8Write(e,n):t.set(nt(e),n)}function Ic(){return new gn}function gs(e,t){const n=Ic();return t.encode(e,n,{lengthDelimited:!1}),n.finish()}var qe;(function(e){e[e.VARINT=0]="VARINT",e[e.BIT64=1]="BIT64",e[e.LENGTH_DELIMITED=2]="LENGTH_DELIMITED",e[e.START_GROUP=3]="START_GROUP",e[e.END_GROUP=4]="END_GROUP",e[e.BIT32=5]="BIT32"})(qe||(qe={}));function ps(e,t,n,r){return{name:e,type:t,encode:n,decode:r}}function _c(e){function t(s){if(e[s.toString()]==null)throw new Error("Invalid enum value");return e[s]}const n=function(i,o){const c=t(i);o.int32(c)},r=function(i){const o=i.int32();return t(o)};return ps("enum",qe.VARINT,n,r)}function ms(e,t){return ps("message",qe.LENGTH_DELIMITED,e,t)}class Tu extends Error{constructor(){super(...arguments);u(this,"code","ERR_MAX_LENGTH");u(this,"name","MaxLengthError")}}class Cu extends Error{constructor(){super(...arguments);u(this,"code","ERR_MAX_SIZE");u(this,"name","MaxSizeError")}}var G;(function(e){e.RSA="RSA",e.Ed25519="Ed25519",e.secp256k1="secp256k1",e.ECDSA="ECDSA"})(G||(G={}));var pn;(function(e){e[e.RSA=0]="RSA",e[e.Ed25519=1]="Ed25519",e[e.secp256k1=2]="secp256k1",e[e.ECDSA=3]="ECDSA"})(pn||(pn={}));(function(e){e.codec=()=>_c(pn)})(G||(G={}));var Mt;(function(e){let t;e.codec=()=>(t==null&&(t=ms((n,r,s={})=>{s.lengthDelimited!==!1&&r.fork(),n.Type!=null&&(r.uint32(8),G.codec().encode(n.Type,r)),n.Data!=null&&(r.uint32(18),r.bytes(n.Data)),s.lengthDelimited!==!1&&r.ldelim()},(n,r,s={})=>{const i={},o=r==null?n.len:n.pos+r;for(;n.pos<o;){const c=n.uint32();switch(c>>>3){case 1:{i.Type=G.codec().decode(n);break}case 2:{i.Data=n.bytes();break}default:{n.skipType(c&7);break}}}return i})),t),e.encode=n=>gs(n,e.codec()),e.decode=(n,r)=>ws(n,e.codec(),r)})(Mt||(Mt={}));var Fe;(function(e){let t;e.codec=()=>(t==null&&(t=ms((n,r,s={})=>{s.lengthDelimited!==!1&&r.fork(),n.Type!=null&&(r.uint32(8),G.codec().encode(n.Type,r)),n.Data!=null&&(r.uint32(18),r.bytes(n.Data)),s.lengthDelimited!==!1&&r.ldelim()},(n,r,s={})=>{const i={},o=r==null?n.len:n.pos+r;for(;n.pos<o;){const c=n.uint32();switch(c>>>3){case 1:{i.Type=G.codec().decode(n);break}case 2:{i.Data=n.bytes();break}default:{n.skipType(c&7);break}}}return i})),t),e.encode=n=>gs(n,e.codec()),e.decode=(n,r)=>ws(n,e.codec(),r)})(Fe||(Fe={}));function Ku(e){if(isNaN(e)||e<=0)throw new lt("random bytes length must be a Number bigger than 0");return me(e)}class kn{constructor(t,n){u(this,"type","RSA");u(this,"jwk");u(this,"_raw");u(this,"_multihash");this.jwk=t,this._multihash=n}get raw(){return this._raw==null&&(this._raw=$n(this.jwk)),this._raw}toMultihash(){return this._multihash}toCID(){return J.createV1(114,this._multihash)}toString(){return bt.encode(this.toMultihash().bytes).substring(1)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:It(this.raw,t.raw)}verify(t,n,r){return Hc(this.jwk,n,t,r)}}class xs{constructor(t,n){u(this,"type","RSA");u(this,"jwk");u(this,"_raw");u(this,"publicKey");this.jwk=t,this.publicKey=n}get raw(){return this._raw==null&&(this._raw=Dc(this.jwk)),this._raw}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:It(this.raw,t.raw)}sign(t,n){return Vc(this.jwk,t,n)}}const Es=8192,Pn=18,Lc=1062,Uc=Uint8Array.from([48,13,6,9,42,134,72,134,247,13,1,1,1,5,0]);function Rc(e){return{n:z(e[1],"base64url"),e:z(e[2],"base64url"),d:z(e[3],"base64url"),p:z(e[4],"base64url"),q:z(e[5],"base64url"),dp:z(e[6],"base64url"),dq:z(e[7],"base64url"),qi:z(e[8],"base64url"),kty:"RSA"}}function Dc(e){if(e.n==null||e.e==null||e.d==null||e.p==null||e.q==null||e.dp==null||e.dq==null||e.qi==null)throw new lt("JWK was missing components");return Bt([dt(Uint8Array.from([0])),dt(nt(e.n,"base64url")),dt(nt(e.e,"base64url")),dt(nt(e.d,"base64url")),dt(nt(e.p,"base64url")),dt(nt(e.q,"base64url")),dt(nt(e.dp,"base64url")),dt(nt(e.dq,"base64url")),dt(nt(e.qi,"base64url"))]).subarray()}function Nc(e){const t=ee(e[1],{offset:0});return{kty:"RSA",n:z(t[0],"base64url"),e:z(t[1],"base64url")}}function $n(e){if(e.n==null||e.e==null)throw new lt("JWK was missing components");return Bt([Uc,vn(Bt([dt(nt(e.n,"base64url")),dt(nt(e.e,"base64url"))]))]).subarray()}function Tc(e){const t=ee(e);return Cc(t)}function Cc(e){const t=Rc(e);return Mc(t)}function Kc(e,t){if(e.byteLength>=Lc)throw new En("Key size is too large");const n=ee(e,{offset:0});return Oc(n,e,t)}function Oc(e,t,n){const r=Nc(e);if(n==null){const s=Ye(Mt.encode({Type:G.RSA,Data:t}));n=te(Pn,s)}return new kn(r,n)}function Mc(e){if(Fc(e)>Es)throw new lt("Key size is too large");const t=Pc(e),n=Ye(Mt.encode({Type:G.RSA,Data:$n(t.publicKey)})),r=te(Pn,n);return new xs(t.privateKey,new kn(t.publicKey,r))}async function kc(e){if(e>Es)throw new lt("Key size is too large");const t=await $c(e),n=Ye(Mt.encode({Type:G.RSA,Data:$n(t.publicKey)})),r=te(Pn,n);return new xs(t.privateKey,new kn(t.publicKey,r))}function Pc(e){if(e==null)throw new lt("Missing key parameter");return{privateKey:e,publicKey:{kty:e.kty,n:e.n,e:e.e}}}async function $c(e,t){const n=await yt.get().subtle.generateKey({name:"RSASSA-PKCS1-v1_5",modulusLength:e,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["sign","verify"]),r=await qc(n);return{privateKey:r[0],publicKey:r[1]}}async function Vc(e,t,n){const r=await yt.get().subtle.importKey("jwk",e,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["sign"]);n?.signal?.throwIfAborted();const s=await yt.get().subtle.sign({name:"RSASSA-PKCS1-v1_5"},r,t instanceof Uint8Array?t:t.subarray());return n?.signal?.throwIfAborted(),new Uint8Array(s,0,s.byteLength)}async function Hc(e,t,n,r){const s=await yt.get().subtle.importKey("jwk",e,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["verify"]);r?.signal?.throwIfAborted();const i=await yt.get().subtle.verify({name:"RSASSA-PKCS1-v1_5"},s,t,n instanceof Uint8Array?n:n.subarray());return r?.signal?.throwIfAborted(),i}async function qc(e,t){if(e.privateKey==null||e.publicKey==null)throw new lt("Private and public key are required");return await Promise.all([yt.get().subtle.exportKey("jwk",e.privateKey),yt.get().subtle.exportKey("jwk",e.publicKey)])}function Fc(e){if(e.kty!=="RSA")throw new lt("invalid key type");if(e.n==null)throw new lt("invalid key modulus");return nt(e.n,"base64url").length*8}class As{constructor(t,n){u(this,"oHash");u(this,"iHash");u(this,"blockLen");u(this,"outputLen");u(this,"finished",!1);u(this,"destroyed",!1);if($r(t),H(n,void 0,"key"),this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const r=this.blockLen,s=new Uint8Array(r);s.set(n.length>r?t.create().update(n).digest():n);for(let i=0;i<s.length;i++)s[i]^=54;this.iHash.update(s),this.oHash=t.create();for(let i=0;i<s.length;i++)s[i]^=106;this.oHash.update(s),Jt(s)}update(t){return ke(this),this.iHash.update(t),this}digestInto(t){ke(this),H(t,this.outputLen,"output"),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:n,iHash:r,finished:s,destroyed:i,blockLen:o,outputLen:c}=this;return t=t,t.finished=s,t.destroyed=i,t.blockLen=o,t.outputLen=c,t.oHash=n._cloneInto(t.oHash),t.iHash=r._cloneInto(t.iHash),t}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Ss=(e,t,n)=>new As(e,t).update(n).digest();Ss.create=(e,t)=>new As(e,t);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const xr=(e,t)=>(e+(e>=0?t:-t)/Bs)/t;function zc(e,t,n){const[[r,s],[i,o]]=t,c=xr(o*e,n),a=xr(-s*e,n);let l=e-c*r-a*i,b=-c*s-a*o;const d=l<St,A=b<St;d&&(l=-l),A&&(b=-b);const S=Un(Math.ceil(wa(n)/2))+Wt;if(l<St||l>=S||b<St||b>=S)throw new Error("splitScalar (endomorphism): failed, k="+e);return{k1neg:d,k1:l,k2neg:A,k2:b}}function mn(e){if(!["compact","recovered","der"].includes(e))throw new Error('Signature format must be "compact", "recovered", or "der"');return e}function un(e,t){const n={};for(let r of Object.keys(t))n[r]=e[r]===void 0?t[r]:e[r];return Ht(n.lowS,"lowS"),Ht(n.prehash,"prehash"),n.format!==void 0&&mn(n.format),n}class Zc extends Error{constructor(t=""){super(t)}}const Ct={Err:Zc,_tlv:{encode:(e,t)=>{const{Err:n}=Ct;if(e<0||e>256)throw new n("tlv.encode: wrong tag");if(t.length&1)throw new n("tlv.encode: unpadded data");const r=t.length/2,s=Ie(r);if(s.length/2&128)throw new n("tlv.encode: long form length too big");const i=r>127?Ie(s.length/2|128):"";return Ie(e)+i+s+t},decode(e,t){const{Err:n}=Ct;let r=0;if(e<0||e>256)throw new n("tlv.encode: wrong tag");if(t.length<2||t[r++]!==e)throw new n("tlv.decode: wrong tlv");const s=t[r++],i=!!(s&128);let o=0;if(!i)o=s;else{const a=s&127;if(!a)throw new n("tlv.decode(long): indefinite length not supported");if(a>4)throw new n("tlv.decode(long): byte length is too big");const l=t.subarray(r,r+a);if(l.length!==a)throw new n("tlv.decode: length bytes not complete");if(l[0]===0)throw new n("tlv.decode(long): zero leftmost byte");for(const b of l)o=o<<8|b;if(r+=a,o<128)throw new n("tlv.decode(long): not minimal encoding")}const c=t.subarray(r,r+o);if(c.length!==o)throw new n("tlv.decode: wrong value length");return{v:c,l:t.subarray(r+o)}}},_int:{encode(e){const{Err:t}=Ct;if(e<St)throw new t("integer: negative integers are not allowed");let n=Ie(e);if(Number.parseInt(n[0],16)&8&&(n="00"+n),n.length&1)throw new t("unexpected DER parsing assertion: unpadded hex");return n},decode(e){const{Err:t}=Ct;if(e[0]&128)throw new t("invalid signature integer: negative");if(e[0]===0&&!(e[1]&128))throw new t("invalid signature integer: unnecessary leading zero");return Xe(e)}},toSig(e){const{Err:t,_int:n,_tlv:r}=Ct,s=H(e,void 0,"signature"),{v:i,l:o}=r.decode(48,s);if(o.length)throw new t("invalid signature: left bytes after parsing");const{v:c,l:a}=r.decode(2,i),{v:l,l:b}=r.decode(2,a);if(b.length)throw new t("invalid signature: left bytes after parsing");return{r:n.decode(c),s:n.decode(l)}},hexFromSig(e){const{_tlv:t,_int:n}=Ct,r=t.encode(2,n.encode(e.r)),s=t.encode(2,n.encode(e.s)),i=r+s;return t.encode(48,i)}},St=BigInt(0),Wt=BigInt(1),Bs=BigInt(2),Re=BigInt(3),jc=BigInt(4);function Gc(e,t={}){const n=as("weierstrass",e,t),{Fp:r,Fn:s}=n;let i=n.CURVE;const{h:o,n:c}=i;ne(t,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object"});const{endo:a}=t;if(a&&(!r.is0(i.a)||typeof a.beta!="bigint"||!Array.isArray(a.basises)))throw new Error('invalid endo: expected "beta": bigint and "basises": array');const l=Is(r,s);function b(){if(!r.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function d(N,f,h){const{x:g,y:v}=f.toAffine(),L=r.toBytes(g);if(Ht(h,"isCompressed"),h){b();const U=!r.isOdd(v);return mt(vs(U),L)}else return mt(Uint8Array.of(4),L,r.toBytes(v))}function A(N){H(N,void 0,"Point");const{publicKey:f,publicKeyUncompressed:h}=l,g=N.length,v=N[0],L=N.subarray(1);if(g===f&&(v===2||v===3)){const U=r.fromBytes(L);if(!r.isValid(U))throw new Error("bad point: is not on curve, wrong x");const T=_(U);let I;try{I=r.sqrt(T)}catch(Z){const F=Z instanceof Error?": "+Z.message:"";throw new Error("bad point: is not on curve, sqrt error"+F)}b();const K=r.isOdd(I);return(v&1)===1!==K&&(I=r.neg(I)),{x:U,y:I}}else if(g===h&&v===4){const U=r.BYTES,T=r.fromBytes(L.subarray(0,U)),I=r.fromBytes(L.subarray(U,U*2));if(!y(T,I))throw new Error("bad point: is not on curve");return{x:T,y:I}}else throw new Error(`bad point: got length ${g}, expected compressed=${f} or uncompressed=${h}`)}const S=t.toBytes||d,p=t.fromBytes||A;function _(N){const f=r.sqr(N),h=r.mul(f,N);return r.add(r.add(h,r.mul(N,i.a)),i.b)}function y(N,f){const h=r.sqr(f),g=_(N);return r.eql(h,g)}if(!y(i.Gx,i.Gy))throw new Error("bad curve params: generator point");const R=r.mul(r.pow(i.a,Re),jc),m=r.mul(r.sqr(i.b),BigInt(27));if(r.is0(r.add(R,m)))throw new Error("bad curve params: a or b");function w(N,f,h=!1){if(!r.isValid(f)||h&&r.is0(f))throw new Error(`bad point coordinate ${N}`);return f}function B(N){if(!(N instanceof E))throw new Error("Weierstrass Point expected")}function C(N){if(!a||!a.basises)throw new Error("no endo");return zc(N,a.basises,s.ORDER)}const M=Pe((N,f)=>{const{X:h,Y:g,Z:v}=N;if(r.eql(v,r.ONE))return{x:h,y:g};const L=N.is0();f==null&&(f=L?r.ONE:r.inv(v));const U=r.mul(h,f),T=r.mul(g,f),I=r.mul(v,f);if(L)return{x:r.ZERO,y:r.ZERO};if(!r.eql(I,r.ONE))throw new Error("invZ was invalid");return{x:U,y:T}}),$=Pe(N=>{if(N.is0()){if(t.allowInfinityPoint&&!r.is0(N.Y))return;throw new Error("bad point: ZERO")}const{x:f,y:h}=N.toAffine();if(!r.isValid(f)||!r.isValid(h))throw new Error("bad point: x or y not field elements");if(!y(f,h))throw new Error("bad point: equation left != right");if(!N.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function x(N,f,h,g,v){return h=new E(r.mul(h.X,N),h.Y,h.Z),f=$e(g,f),h=$e(v,h),f.add(h)}const D=class D{constructor(f,h,g){u(this,"X");u(this,"Y");u(this,"Z");this.X=w("x",f),this.Y=w("y",h,!0),this.Z=w("z",g),Object.freeze(this)}static CURVE(){return i}static fromAffine(f){const{x:h,y:g}=f||{};if(!f||!r.isValid(h)||!r.isValid(g))throw new Error("invalid affine point");if(f instanceof D)throw new Error("projective point not allowed");return r.is0(h)&&r.is0(g)?D.ZERO:new D(h,g,r.ONE)}static fromBytes(f){const h=D.fromAffine(p(H(f,void 0,"point")));return h.assertValidity(),h}static fromHex(f){return D.fromBytes(he(f))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(f=8,h=!0){return V.createCache(this,f),h||this.multiply(Re),this}assertValidity(){$(this)}hasEvenY(){const{y:f}=this.toAffine();if(!r.isOdd)throw new Error("Field doesn't support isOdd");return!r.isOdd(f)}equals(f){B(f);const{X:h,Y:g,Z:v}=this,{X:L,Y:U,Z:T}=f,I=r.eql(r.mul(h,T),r.mul(L,v)),K=r.eql(r.mul(g,T),r.mul(U,v));return I&&K}negate(){return new D(this.X,r.neg(this.Y),this.Z)}double(){const{a:f,b:h}=i,g=r.mul(h,Re),{X:v,Y:L,Z:U}=this;let T=r.ZERO,I=r.ZERO,K=r.ZERO,P=r.mul(v,v),Z=r.mul(L,L),F=r.mul(U,U),k=r.mul(v,L);return k=r.add(k,k),K=r.mul(v,U),K=r.add(K,K),T=r.mul(f,K),I=r.mul(g,F),I=r.add(T,I),T=r.sub(Z,I),I=r.add(Z,I),I=r.mul(T,I),T=r.mul(k,T),K=r.mul(g,K),F=r.mul(f,F),k=r.sub(P,F),k=r.mul(f,k),k=r.add(k,K),K=r.add(P,P),P=r.add(K,P),P=r.add(P,F),P=r.mul(P,k),I=r.add(I,P),F=r.mul(L,U),F=r.add(F,F),P=r.mul(F,k),T=r.sub(T,P),K=r.mul(F,Z),K=r.add(K,K),K=r.add(K,K),new D(T,I,K)}add(f){B(f);const{X:h,Y:g,Z:v}=this,{X:L,Y:U,Z:T}=f;let I=r.ZERO,K=r.ZERO,P=r.ZERO;const Z=i.a,F=r.mul(i.b,Re);let k=r.mul(h,L),W=r.mul(g,U),Q=r.mul(v,T),it=r.add(h,g),j=r.add(L,U);it=r.mul(it,j),j=r.add(k,W),it=r.sub(it,j),j=r.add(h,v);let et=r.add(L,T);return j=r.mul(j,et),et=r.add(k,Q),j=r.sub(j,et),et=r.add(g,v),I=r.add(U,T),et=r.mul(et,I),I=r.add(W,Q),et=r.sub(et,I),P=r.mul(Z,j),I=r.mul(F,Q),P=r.add(I,P),I=r.sub(W,P),P=r.add(W,P),K=r.mul(I,P),W=r.add(k,k),W=r.add(W,k),Q=r.mul(Z,Q),j=r.mul(F,j),W=r.add(W,Q),Q=r.sub(k,Q),Q=r.mul(Z,Q),j=r.add(j,Q),k=r.mul(W,j),K=r.add(K,k),k=r.mul(et,j),I=r.mul(it,I),I=r.sub(I,k),k=r.mul(it,W),P=r.mul(et,P),P=r.add(P,k),new D(I,K,P)}subtract(f){return this.add(f.negate())}is0(){return this.equals(D.ZERO)}multiply(f){const{endo:h}=t;if(!s.isValidNot0(f))throw new Error("invalid scalar: out of range");let g,v;const L=U=>V.cached(this,U,T=>fe(D,T));if(h){const{k1neg:U,k1:T,k2neg:I,k2:K}=C(f),{p:P,f:Z}=L(T),{p:F,f:k}=L(K);v=Z.add(k),g=x(h.beta,P,F,U,I)}else{const{p:U,f:T}=L(f);g=U,v=T}return fe(D,[g,v])[0]}multiplyUnsafe(f){const{endo:h}=t,g=this;if(!s.isValid(f))throw new Error("invalid scalar: out of range");if(f===St||g.is0())return D.ZERO;if(f===Wt)return g;if(V.hasCache(this))return this.multiply(f);if(h){const{k1neg:v,k1:L,k2neg:U,k2:T}=C(f),{p1:I,p2:K}=Ra(D,g,L,T);return x(h.beta,I,K,v,U)}else return V.unsafe(g,f)}toAffine(f){return M(this,f)}isTorsionFree(){const{isTorsionFree:f}=t;return o===Wt?!0:f?f(D,this):V.unsafe(this,c).is0()}clearCofactor(){const{clearCofactor:f}=t;return o===Wt?this:f?f(D,this):this.multiplyUnsafe(o)}isSmallOrder(){return this.multiplyUnsafe(o).is0()}toBytes(f=!0){return Ht(f,"isCompressed"),this.assertValidity(),S(D,this,f)}toHex(f=!0){return pe(this.toBytes(f))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}};u(D,"BASE",new D(i.Gx,i.Gy,r.ONE)),u(D,"ZERO",new D(r.ZERO,r.ONE,r.ZERO)),u(D,"Fp",r),u(D,"Fn",s);let E=D;const O=s.BITS,V=new os(E,t.endo?Math.ceil(O/2):O);return E.BASE.precompute(8),E}function vs(e){return Uint8Array.of(e?2:3)}function Is(e,t){return{secretKey:t.BYTES,publicKey:1+e.BYTES,publicKeyUncompressed:1+2*e.BYTES,publicKeyHasPrefix:!0,signature:2*t.BYTES}}function Yc(e,t={}){const{Fn:n}=e,r=t.randomBytes||me,s=Object.assign(Is(e.Fp,n),{seed:rs(n.ORDER)});function i(S){try{const p=n.fromBytes(S);return n.isValidNot0(p)}catch{return!1}}function o(S,p){const{publicKey:_,publicKeyUncompressed:y}=s;try{const R=S.length;return p===!0&&R!==_||p===!1&&R!==y?!1:!!e.fromBytes(S)}catch{return!1}}function c(S=r(s.seed)){return Ua(H(S,s.seed,"seed"),n.ORDER)}function a(S,p=!0){return e.BASE.multiply(n.fromBytes(S)).toBytes(p)}function l(S){const{secretKey:p,publicKey:_,publicKeyUncompressed:y}=s;if(!Ge(S)||"_lengths"in n&&n._lengths||p===_)return;const R=H(S,void 0,"key").length;return R===_||R===y}function b(S,p,_=!0){if(l(S)===!0)throw new Error("first arg must be private key");if(l(p)===!1)throw new Error("second arg must be public key");const y=n.fromBytes(S);return e.fromBytes(p).multiply(y).toBytes(_)}const d={isValidSecretKey:i,isValidPublicKey:o,randomSecretKey:c},A=Dn(c,a);return Object.freeze({getPublicKey:a,getSharedSecret:b,keygen:A,Point:e,utils:d,lengths:s})}function Xc(e,t,n={}){$r(t),ne(n,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"}),n=Object.assign({},n);const r=n.randomBytes||me,s=n.hmac||((f,h)=>Ss(t,f,h)),{Fp:i,Fn:o}=e,{ORDER:c,BITS:a}=o,{keygen:l,getPublicKey:b,getSharedSecret:d,utils:A,lengths:S}=Yc(e,n),p={prehash:!0,lowS:typeof n.lowS=="boolean"?n.lowS:!0,format:"compact",extraEntropy:!1},_=c*Bs<i.ORDER;function y(f){const h=c>>Wt;return f>h}function R(f,h){if(!o.isValidNot0(h))throw new Error(`invalid signature ${f}: out of range 1..Point.Fn.ORDER`);return h}function m(){if(_)throw new Error('"recovered" sig type is not supported for cofactor >2 curves')}function w(f,h){mn(h);const g=S.signature,v=h==="compact"?g:h==="recovered"?g+1:void 0;return H(f,v)}class B{constructor(h,g,v){u(this,"r");u(this,"s");u(this,"recovery");if(this.r=R("r",h),this.s=R("s",g),v!=null){if(m(),![0,1,2,3].includes(v))throw new Error("invalid recovery id");this.recovery=v}Object.freeze(this)}static fromBytes(h,g=p.format){w(h,g);let v;if(g==="der"){const{r:I,s:K}=Ct.toSig(H(h));return new B(I,K)}g==="recovered"&&(v=h[0],g="compact",h=h.subarray(1));const L=S.signature/2,U=h.subarray(0,L),T=h.subarray(L,L*2);return new B(o.fromBytes(U),o.fromBytes(T),v)}static fromHex(h,g){return this.fromBytes(he(h),g)}assertRecovery(){const{recovery:h}=this;if(h==null)throw new Error("invalid recovery id: must be present");return h}addRecoveryBit(h){return new B(this.r,this.s,h)}recoverPublicKey(h){const{r:g,s:v}=this,L=this.assertRecovery(),U=L===2||L===3?g+c:g;if(!i.isValid(U))throw new Error("invalid recovery id: sig.r+curve.n != R.x");const T=i.toBytes(U),I=e.fromBytes(mt(vs((L&1)===0),T)),K=o.inv(U),P=M(H(h,void 0,"msgHash")),Z=o.create(-P*K),F=o.create(v*K),k=e.BASE.multiplyUnsafe(Z).add(I.multiplyUnsafe(F));if(k.is0())throw new Error("invalid recovery: point at infinify");return k.assertValidity(),k}hasHighS(){return y(this.s)}toBytes(h=p.format){if(mn(h),h==="der")return he(Ct.hexFromSig(this));const{r:g,s:v}=this,L=o.toBytes(g),U=o.toBytes(v);return h==="recovered"?(m(),mt(Uint8Array.of(this.assertRecovery()),L,U)):mt(L,U)}toHex(h){return pe(this.toBytes(h))}}const C=n.bits2int||function(h){if(h.length>8192)throw new Error("input is too large");const g=Xe(h),v=h.length*8-a;return v>0?g>>BigInt(v):g},M=n.bits2int_modN||function(h){return o.create(C(h))},$=Un(a);function x(f){return de("num < 2^"+a,f,St,$),o.toBytes(f)}function E(f,h){return H(f,void 0,"message"),h?H(t(f),void 0,"prehashed message"):f}function O(f,h,g){const{lowS:v,prehash:L,extraEntropy:U}=un(g,p);f=E(f,L);const T=M(f),I=o.fromBytes(h);if(!o.isValidNot0(I))throw new Error("invalid private key");const K=[x(I),x(T)];if(U!=null&&U!==!1){const k=U===!0?r(S.secretKey):U;K.push(H(k,void 0,"extraEntropy"))}const P=mt(...K),Z=T;function F(k){const W=C(k);if(!o.isValidNot0(W))return;const Q=o.inv(W),it=e.BASE.multiply(W).toAffine(),j=o.create(it.x);if(j===St)return;const et=o.create(Q*o.create(Z+j*I));if(et===St)return;let Ee=(it.x===j?0:2)|Number(it.y&Wt),re=et;return v&&y(et)&&(re=o.neg(et),Ee^=1),new B(j,re,_?void 0:Ee)}return{seed:P,k2sig:F}}function V(f,h,g={}){const{seed:v,k2sig:L}=O(f,h,g);return ga(t.outputLen,o.BYTES,s)(v,L).toBytes(g.format)}function D(f,h,g,v={}){const{lowS:L,prehash:U,format:T}=un(v,p);if(g=H(g,void 0,"publicKey"),h=E(h,U),!Ge(f)){const I=f instanceof B?", use sig.toBytes()":"";throw new Error("verify expects Uint8Array signature"+I)}w(f,T);try{const I=B.fromBytes(f,T),K=e.fromBytes(g);if(L&&I.hasHighS())return!1;const{r:P,s:Z}=I,F=M(h),k=o.inv(Z),W=o.create(F*k),Q=o.create(P*k),it=e.BASE.multiplyUnsafe(W).add(K.multiplyUnsafe(Q));return it.is0()?!1:o.create(it.x)===P}catch{return!1}}function N(f,h,g={}){const{prehash:v}=un(g,p);return h=E(h,v),B.fromBytes(f,"recovered").recoverPublicKey(h).toBytes()}return Object.freeze({keygen:l,getPublicKey:b,getSharedSecret:d,utils:A,lengths:S,Point:e,sign:V,verify:D,recoverPublicKey:N,Signature:B,hash:t})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Vn={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},Wc={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},Er=BigInt(2);function Jc(e){const t=Vn.p,n=BigInt(3),r=BigInt(6),s=BigInt(11),i=BigInt(22),o=BigInt(23),c=BigInt(44),a=BigInt(88),l=e*e*e%t,b=l*l*e%t,d=Y(b,n,t)*b%t,A=Y(d,n,t)*b%t,S=Y(A,Er,t)*l%t,p=Y(S,s,t)*S%t,_=Y(p,i,t)*p%t,y=Y(_,c,t)*_%t,R=Y(y,a,t)*y%t,m=Y(R,c,t)*_%t,w=Y(m,n,t)*b%t,B=Y(w,o,t)*p%t,C=Y(B,r,t)*l%t,M=Y(C,Er,t);if(!xn.eql(xn.sqr(M),e))throw new Error("Cannot find square root");return M}const xn=We(Vn.p,{sqrt:Jc}),Qc=Gc(Vn,{Fp:xn,endo:Wc}),vt=Xc(Qc,Ye);function tu(e,t,n){const r=Nr.digest(t instanceof Uint8Array?t:t.subarray());if(Qe(r))return r.then(({digest:s})=>(n?.signal?.throwIfAborted(),vt.sign(s,e,{prehash:!1,format:"der"}))).catch(s=>{throw s.name==="AbortError"?s:new gr(String(s))});try{return vt.sign(r.digest,e,{prehash:!1,format:"der"})}catch(s){throw new gr(String(s))}}function eu(e,t,n,r){const s=Nr.digest(n instanceof Uint8Array?n:n.subarray());if(Qe(s))return s.then(({digest:i})=>(r?.signal?.throwIfAborted(),vt.verify(t,i,e,{prehash:!1,format:"der"}))).catch(i=>{throw i.name==="AbortError"?i:new pr(String(i))});try{return r?.signal?.throwIfAborted(),vt.verify(t,s.digest,e,{prehash:!1,format:"der"})}catch(i){throw new pr(String(i))}}class _s{constructor(t){u(this,"type","secp256k1");u(this,"raw");u(this,"_key");this._key=ou(t),this.raw=su(this._key)}toMultihash(){return Bn.digest(Hn(this))}toCID(){return J.createV1(114,this.toMultihash())}toString(){return bt.encode(this.toMultihash().bytes).substring(1)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:It(this.raw,t.raw)}verify(t,n,r){return eu(this._key,n,t,r)}}class Ls{constructor(t,n){u(this,"type","secp256k1");u(this,"raw");u(this,"publicKey");this.raw=iu(t),this.publicKey=new _s(n??au(t))}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:It(this.raw,t.raw)}sign(t,n){return tu(this.raw,t,n)}}function nu(e){return new Ls(e)}function Us(e){return new _s(e)}async function ru(){const e=cu();return new Ls(e)}function su(e){return vt.Point.fromBytes(e).toBytes()}function iu(e){try{return vt.getPublicKey(e,!0),e}catch(t){throw new An(String(t))}}function ou(e){try{return vt.Point.fromBytes(e),e}catch(t){throw new En(String(t))}}function au(e){try{return vt.getPublicKey(e,!0)}catch(t){throw new An(String(t))}}function cu(){return vt.utils.randomSecretKey()}async function Ou(e,t){if(e==="Ed25519")return ec();if(e==="secp256k1")return ru();if(e==="RSA")return kc(uu());if(e==="ECDSA")return Go(fu());throw new ye}function Mu(e,t){const{Type:n,Data:r}=Mt.decode(e),s=r??new Uint8Array;switch(n){case G.RSA:return Kc(s,t);case G.Ed25519:return ls(s);case G.secp256k1:return Us(s);case G.ECDSA:return kr(s);default:throw new ye}}function ku(e){const{Type:t,Data:n}=Mt.decode(e.digest),r=n??new Uint8Array;switch(t){case G.Ed25519:return ls(r);case G.secp256k1:return Us(r);case G.ECDSA:return kr(r);default:throw new ye}}function Hn(e){return Mt.encode({Type:G[e.type],Data:e.raw})}function Pu(e){const t=Fe.decode(e),n=t.Data??new Uint8Array;switch(t.Type){case G.RSA:return Tc(n);case G.Ed25519:return tc(n);case G.secp256k1:return nu(n);case G.ECDSA:return qo(n);default:throw new ye}}function $u(e){return Fe.encode({Type:G[e.type],Data:e.raw})}function uu(e){return 2048}function fu(e){return"P-256"}export{Eu as $,Ts as A,bu as B,J as C,Vs as D,Du as E,Ot as F,ms as G,gs as H,lt as I,ws as J,Mu as K,Hn as L,ks as M,Tu as N,Cu as O,pu as P,Hs as Q,vr as R,$s as S,vu as T,ye as U,Iu as V,_u as W,Fs as X,Js as Y,Xs as Z,xu as _,zs as a,Au as a0,Ws as a1,qs as a2,Os as a3,Ku as a4,Gn as a5,Gs as a6,js as a7,lu as a8,ti as a9,$u as aA,ni as aa,ei as ab,du as ac,mu as ad,gu as ae,Ou as af,_c as ag,Ae as ah,Uu as ai,$r as aj,Ss as ak,Vt as al,Jt as am,H as an,Ru as ao,Ye as ap,Lu as aq,Cs as ar,Ks as as,Su as at,Ms as au,te as av,Qs as aw,Ys as ax,En as ay,Pu as az,bt as b,ku as c,Zi as d,It as e,nt as f,Zs as g,rr as h,Bn as i,tr as j,ue as k,go as l,xe as m,ds as n,Nu as o,ri as p,yo as q,Lt as r,Nr as s,z as t,Bu as u,ft as v,yu as w,Ps as x,wu as y,Br as z};
