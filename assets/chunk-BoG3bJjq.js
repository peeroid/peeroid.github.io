var hc=Object.defineProperty;var Ls=r=>{throw TypeError(r)};var fc=(r,e,t)=>e in r?hc(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t;var c=(r,e,t)=>fc(r,typeof e!="symbol"?e+"":e,t),ir=(r,e,t)=>e.has(r)||Ls("Cannot "+t);var m=(r,e,t)=>(ir(r,e,"read from private field"),t?t.call(r):e.get(r)),D=(r,e,t)=>e.has(r)?Ls("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(r):e.set(r,t),L=(r,e,t,n)=>(ir(r,e,"write to private field"),n?n.call(r,t):e.set(r,t),t),E=(r,e,t)=>(ir(r,e,"access private method"),t);var Fe=(r,e,t,n)=>({set _(s){L(r,e,s,t)},get _(){return m(r,e,n)}});import{i as Ki,f as F,p as Gi,C as Xt,t as Y,b as Gn,e as Se,d as Xr,I as N,a as mc,c as pc,g as gc,s as yc,U as wc,h as bc,j as Qn,k as Yr,l as vc,m as De,n as Ps,o as Yt,q as Ec,r as Ee,A as Ot,u as pe,T as _e,v as ie,S as Tt,w as Sc,x as _c,y as xc,z as Qi,B as Cc,D as ks,M as Ac,E as Mt,F as Ic,G as Le,H as Pe,J as ke,K as Jr,L as fn,N as Ar,O as Ds,P as Nt,Q as Ir,R as Tc,V as Tr,W as Ms,X as Zr,Y as or,Z as Lc,_ as ji,$ as Pc,a0 as kc,a1 as Cn,a2 as Hi,a3 as Lr,a4 as Xi,a5 as Ns,a6 as Dc,a7 as Mc,a8 as Nc,a9 as Fs,aa as Fc,ab as Rc,ac as Rs,ad as $s,ae as Os,af as $c}from"./chunk-BXMe3XGs.js";import{g as Yi,c as Oc}from"./chunk-TVaZgJ8I.js";const Ji=Symbol.for("nodejs.util.inspect.custom"),Bc=114;var Ci;class es{constructor(e){c(this,"type");c(this,"multihash");c(this,"publicKey");c(this,"string");c(this,Ci,!0);this.type=e.type,this.multihash=e.multihash,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return`PeerId(${this.toString()})`}toString(){return this.string==null&&(this.string=Gn.encode(this.multihash.bytes).slice(1)),this.string}toMultihash(){return this.multihash}toCID(){return Xt.createV1(Bc,this.multihash)}toJSON(){return this.toString()}equals(e){if(e==null)return!1;if(e instanceof Uint8Array)return Se(this.multihash.bytes,e);if(typeof e=="string")return this.toString()===e;if(e?.toMultihash()?.bytes!=null)return Se(this.multihash.bytes,e.toMultihash().bytes);throw new Error("not valid Id")}[(Ci=Gi,Ji)](){return`PeerId(${this.toString()})`}}class Zi extends es{constructor(t){super({...t,type:"RSA"});c(this,"type","RSA");c(this,"publicKey");this.publicKey=t.publicKey}}class eo extends es{constructor(t){super({...t,type:"Ed25519"});c(this,"type","Ed25519");c(this,"publicKey");this.publicKey=t.publicKey}}class to extends es{constructor(t){super({...t,type:"secp256k1"});c(this,"type","secp256k1");c(this,"publicKey");this.publicKey=t.publicKey}}const Uc=2336;var Ai,Ii;class no{constructor(e){c(this,"type","url");c(this,"multihash");c(this,"publicKey");c(this,"url");c(this,Ai,!0);this.url=e.toString(),this.multihash=Ki.digest(F(this.url))}[(Ii=Ji,Ai=Gi,Ii)](){return`PeerId(${this.url})`}toString(){return this.toCID().toString()}toMultihash(){return this.multihash}toCID(){return Xt.createV1(Uc,this.toMultihash())}toJSON(){return this.toString()}equals(e){return e==null?!1:(e instanceof Uint8Array&&(e=Y(e)),e.toString()===this.toString())}}const zc=114,Bs=2336;function mt(r,e){let t;if(r.charAt(0)==="1"||r.charAt(0)==="Q")t=Xr(Gn.decode(`z${r}`));else{if(r.startsWith("k51qzi5uqu5")||r.startsWith("kzwfwjn5ji4")||r.startsWith("k2k4r8")||r.startsWith("bafz"))return ts(Xt.parse(r));throw new N('Please pass a multibase decoder for strings that do not start with "1" or "Q"')}return jn(t)}function ro(r){if(r.type==="Ed25519")return new eo({multihash:r.toCID().multihash,publicKey:r});if(r.type==="secp256k1")return new to({multihash:r.toCID().multihash,publicKey:r});if(r.type==="RSA")return new Zi({multihash:r.toCID().multihash,publicKey:r});throw new wc}function qc(r){return ro(r.publicKey)}function jn(r){if(Wc(r))return new Zi({multihash:r});if(Vc(r))try{const e=pc(r);if(e.type==="Ed25519")return new eo({multihash:r,publicKey:e});if(e.type==="secp256k1")return new to({multihash:r,publicKey:e})}catch{const t=Y(r.digest);return new no(new URL(t))}throw new gc("Supplied PeerID Multihash is invalid")}function ts(r){if(r?.multihash==null||r.version==null||r.version===1&&r.code!==zc&&r.code!==Bs)throw new mc("Supplied PeerID CID is invalid");if(r.code===Bs){const e=Y(r.multihash.digest);return new no(new URL(e))}return jn(r.multihash)}function Vc(r){return r.code===Ki.code}function Wc(r){return r.code===yc.code}class Z extends Error{constructor(){super(...arguments);c(this,"name","InvalidMultiaddrError")}}c(Z,"name","InvalidMultiaddrError");class pt extends Error{constructor(){super(...arguments);c(this,"name","ValidationError")}}c(pt,"name","ValidationError");class so extends Error{constructor(){super(...arguments);c(this,"name","InvalidParametersError")}}c(so,"name","InvalidParametersError");class io extends Error{constructor(){super(...arguments);c(this,"name","UnknownProtocolError")}}c(io,"name","UnknownProtocolError");class Kc{constructor(){c(this,"index",0);c(this,"input","")}new(e){return this.index=0,this.input=e,this}readAtomically(e){const t=this.index,n=e();return n===void 0&&(this.index=t),n}parseWith(e){const t=e();if(this.index===this.input.length)return t}peekChar(){if(!(this.index>=this.input.length))return this.input[this.index]}readChar(){if(!(this.index>=this.input.length))return this.input[this.index++]}readGivenChar(e){return this.readAtomically(()=>{const t=this.readChar();if(t===e)return t})}readSeparator(e,t,n){return this.readAtomically(()=>{if(!(t>0&&this.readGivenChar(e)===void 0))return n()})}readNumber(e,t,n,s){return this.readAtomically(()=>{let i=0,o=0;const a=this.peekChar();if(a===void 0)return;const l=a==="0",u=2**(8*s)-1;for(;;){const d=this.readAtomically(()=>{const h=this.readChar();if(h===void 0)return;const f=Number.parseInt(h,e);if(!Number.isNaN(f))return f});if(d===void 0)break;if(i*=e,i+=d,i>u||(o+=1,t!==void 0&&o>t))return}if(o!==0)return!n&&l&&o>1?void 0:i})}readIPv4Addr(){return this.readAtomically(()=>{const e=new Uint8Array(4);for(let t=0;t<e.length;t++){const n=this.readSeparator(".",t,()=>this.readNumber(10,3,!1,1));if(n===void 0)return;e[t]=n}return e})}readIPv6Addr(){const e=t=>{for(let n=0;n<t.length/2;n++){const s=n*2;if(n<t.length-3){const o=this.readSeparator(":",n,()=>this.readIPv4Addr());if(o!==void 0)return t[s]=o[0],t[s+1]=o[1],t[s+2]=o[2],t[s+3]=o[3],[s+4,!0]}const i=this.readSeparator(":",n,()=>this.readNumber(16,4,!0,2));if(i===void 0)return[s,!1];t[s]=i>>8,t[s+1]=i&255}return[t.length,!1]};return this.readAtomically(()=>{const t=new Uint8Array(16),[n,s]=e(t);if(n===16)return t;if(s||this.readGivenChar(":")===void 0||this.readGivenChar(":")===void 0)return;const i=new Uint8Array(14),o=16-(n+2),[a]=e(i.subarray(0,o));return t.set(i.subarray(0,a),16-a),t})}readIPAddr(){return this.readIPv4Addr()??this.readIPv6Addr()}}const oo=45,Gc=15,gt=new Kc;function ao(r){if(!(r.length>Gc))return gt.new(r).parseWith(()=>gt.readIPv4Addr())}function co(r){if(r.includes("%")&&(r=r.split("%")[0]),!(r.length>oo))return gt.new(r).parseWith(()=>gt.readIPv6Addr())}function Pr(r,e=!1){if(r.includes("%")&&(r=r.split("%")[0]),r.length>oo)return;const t=gt.new(r).parseWith(()=>gt.readIPAddr());if(t)return e&&t.length===4?Uint8Array.from([0,0,0,0,0,0,0,0,0,0,255,255,t[0],t[1],t[2],t[3]]):t}function yt(r){return!!ao(r)}function lo(r){return!!co(r)}const An=4,st=6,uo=273,Qc=33,In=41,ho=42,ns=43,fo=53,mo=54,po=55,go=56,jc=132,Hc=301,Xc=302,yo=400,C=421,Yc=444,Jc=445,Zc=446,el=447,it=448,Tn=449,tl=454,wo=460,bo=461,vo=465,Bt=466,ot=480,nl=481,kr=443,rs=477,Eo=478,rl=479,sl=277,il=275,ol=276,So=280,Ft=281,ss=290,_o=777;function Us(r){return e=>Y(e,r)}function zs(r){return e=>F(e,r)}function kt(r){return new DataView(r.buffer).getUint16(r.byteOffset).toString()}function tt(r){const e=new ArrayBuffer(2);return new DataView(e).setUint16(0,typeof r=="string"?parseInt(r):r),new Uint8Array(e)}function al(r){const e=r.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==16)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);const t=F(e[0],"base32"),n=parseInt(e[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");const s=tt(n);return Qn([t,s],t.length+s.length)}function cl(r){const e=r.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==56)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);const t=Yr.decode(`b${e[0]}`),n=parseInt(e[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");const s=tt(n);return Qn([t,s],t.length+s.length)}function qs(r){const e=r.subarray(0,r.length-2),t=r.subarray(r.length-2),n=Y(e,"base32"),s=kt(t);return`${n}:${s}`}const xo=function(r){r=r.toString().trim();const e=new Uint8Array(4);return r.split(/\./g).forEach((t,n)=>{const s=parseInt(t,10);if(isNaN(s)||s<0||s>255)throw new Z("Invalid byte value in IP address");e[n]=s}),e},ll=function(r){let e=0;r=r.toString().trim();const t=r.split(":",8);let n;for(n=0;n<t.length;n++){const i=yt(t[n]);let o;i&&(o=xo(t[n]),t[n]=Y(o.subarray(0,2),"base16")),o!=null&&++n<8&&t.splice(n,0,Y(o.subarray(2,4),"base16"))}if(t[0]==="")for(;t.length<8;)t.unshift("0");else if(t[t.length-1]==="")for(;t.length<8;)t.push("0");else if(t.length<8){for(n=0;n<t.length&&t[n]!=="";n++);const i=[n,1];for(n=9-t.length;n>0;n--)i.push("0");t.splice.apply(t,i)}const s=new Uint8Array(e+16);for(n=0;n<t.length;n++){t[n]===""&&(t[n]="0");const i=parseInt(t[n],16);if(isNaN(i)||i<0||i>65535)throw new Z("Invalid byte value in IP address");s[e++]=i>>8&255,s[e++]=i&255}return s},ul=function(r){if(r.byteLength!==4)throw new Z("IPv4 address was incorrect length");const e=[];for(let t=0;t<r.byteLength;t++)e.push(r[t]);return e.join(".")},dl=function(r){if(r.byteLength!==16)throw new Z("IPv6 address was incorrect length");const e=[];for(let n=0;n<r.byteLength;n+=2){const s=r[n],i=r[n+1],o=`${s.toString(16).padStart(2,"0")}${i.toString(16).padStart(2,"0")}`;e.push(o)}const t=e.join(":");try{const n=new URL(`http://[${t}]`);return n.hostname.substring(1,n.hostname.length-1)}catch{throw new Z(`Invalid IPv6 address "${t}"`)}};function hl(r){try{const e=new URL(`http://[${r}]`);return e.hostname.substring(1,e.hostname.length-1)}catch{throw new Z(`Invalid IPv6 address "${r}"`)}}const ar=Object.values(bc).map(r=>r.decoder),fl=function(){let r=ar[0].or(ar[1]);return ar.slice(2).forEach(e=>r=r.or(e)),r}();function ml(r){return fl.decode(r)}function pl(r){return e=>r.encoder.encode(e)}function gl(r){if(parseInt(r).toString()!==r)throw new pt("Value must be an integer")}function yl(r){if(r<0)throw new pt("Value must be a positive integer, or zero")}function wl(r){return e=>{if(e>r)throw new pt(`Value must be smaller than or equal to ${r}`)}}function bl(...r){return e=>{for(const t of r)t(e)}}const sn=bl(gl,yl,wl(65535)),W=-1;class vl{constructor(){c(this,"protocolsByCode",new Map);c(this,"protocolsByName",new Map)}getProtocol(e){let t;if(typeof e=="string"?t=this.protocolsByName.get(e):t=this.protocolsByCode.get(e),t==null)throw new io(`Protocol ${e} was unknown`);return t}addProtocol(e){this.protocolsByCode.set(e.code,e),this.protocolsByName.set(e.name,e),e.aliases?.forEach(t=>{this.protocolsByName.set(t,e)})}removeProtocol(e){const t=this.protocolsByCode.get(e);t!=null&&(this.protocolsByCode.delete(t.code),this.protocolsByName.delete(t.name),t.aliases?.forEach(n=>{this.protocolsByName.delete(n)}))}}const xt=new vl,El=[{code:An,name:"ip4",size:32,valueToBytes:xo,bytesToValue:ul,validate:r=>{if(!yt(r))throw new pt(`Invalid IPv4 address "${r}"`)}},{code:st,name:"tcp",size:16,valueToBytes:tt,bytesToValue:kt,validate:sn},{code:uo,name:"udp",size:16,valueToBytes:tt,bytesToValue:kt,validate:sn},{code:Qc,name:"dccp",size:16,valueToBytes:tt,bytesToValue:kt,validate:sn},{code:In,name:"ip6",size:128,valueToBytes:ll,bytesToValue:dl,stringToValue:hl,validate:r=>{if(!lo(r))throw new pt(`Invalid IPv6 address "${r}"`)}},{code:ho,name:"ip6zone",size:W},{code:ns,name:"ipcidr",size:8,bytesToValue:Us("base10"),valueToBytes:zs("base10")},{code:fo,name:"dns",size:W},{code:mo,name:"dns4",size:W},{code:po,name:"dns6",size:W},{code:go,name:"dnsaddr",size:W},{code:jc,name:"sctp",size:16,valueToBytes:tt,bytesToValue:kt,validate:sn},{code:Hc,name:"udt"},{code:Xc,name:"utp"},{code:yo,name:"unix",size:W,stringToValue:r=>decodeURIComponent(r),valueToString:r=>encodeURIComponent(r)},{code:C,name:"p2p",aliases:["ipfs"],size:W,bytesToValue:Us("base58btc"),valueToBytes:r=>r.startsWith("Q")||r.startsWith("1")?zs("base58btc")(r):Xt.parse(r).multihash.bytes},{code:Yc,name:"onion",size:96,bytesToValue:qs,valueToBytes:al},{code:Jc,name:"onion3",size:296,bytesToValue:qs,valueToBytes:cl},{code:Zc,name:"garlic64",size:W},{code:el,name:"garlic32",size:W},{code:it,name:"tls"},{code:Tn,name:"sni",size:W},{code:tl,name:"noise"},{code:wo,name:"quic"},{code:bo,name:"quic-v1"},{code:vo,name:"webtransport"},{code:Bt,name:"certhash",size:W,bytesToValue:pl(vc),valueToBytes:ml},{code:ot,name:"http"},{code:nl,name:"http-path",size:W,stringToValue:r=>`/${decodeURIComponent(r)}`,valueToString:r=>encodeURIComponent(r.substring(1))},{code:kr,name:"https"},{code:rs,name:"ws"},{code:Eo,name:"wss"},{code:rl,name:"p2p-websocket-star"},{code:sl,name:"p2p-stardust"},{code:il,name:"p2p-webrtc-star"},{code:ol,name:"p2p-webrtc-direct"},{code:So,name:"webrtc-direct"},{code:Ft,name:"webrtc"},{code:ss,name:"p2p-circuit"},{code:_o,name:"memory",size:W}];El.forEach(r=>{xt.addProtocol(r)});function Sl(r){const e=[];let t=0;for(;t<r.length;){const n=Yt(r,t),s=xt.getProtocol(n),i=De(n),o=Al(s,r,t+i);let a=0;o>0&&s.size===W&&(a=De(o));const l=i+a+o,u={code:n,name:s.name,bytes:r.subarray(t,t+l)};if(o>0){const d=t+i+a,h=r.subarray(d,d+o);u.value=s.bytesToValue?.(h)??Y(h)}e.push(u),t+=l}return e}function _l(r){let e=0;const t=[];for(const n of r){if(n.bytes==null){const s=xt.getProtocol(n.code),i=De(n.code);let o,a=0,l=0;n.value!=null&&(o=s.valueToBytes?.(n.value)??F(n.value),a=o.byteLength,s.size===W&&(l=De(a)));const u=new Uint8Array(i+l+a);let d=0;Ps(n.code,u,d),d+=i,o!=null&&(s.size===W&&(Ps(a,u,d),d+=l),u.set(o,d)),n.bytes=u}t.push(n.bytes),e+=n.bytes.byteLength}return Qn(t,e)}function xl(r){if(r.charAt(0)!=="/")throw new Z('String multiaddr must start with "/"');const e=[];let t="protocol",n="",s="";for(let i=1;i<r.length;i++){const o=r.charAt(i);o!=="/"&&(t==="protocol"?s+=r.charAt(i):n+=r.charAt(i));const a=i===r.length-1;if(o==="/"||a){const l=xt.getProtocol(s);if(t==="protocol"){if(l.size==null||l.size===0){e.push({code:l.code,name:l.name}),n="",s="",t="protocol";continue}else if(a)throw new Z(`Component ${s} was missing value`);t="value"}else if(t==="value"){const u={code:l.code,name:l.name};if(l.size!=null&&l.size!==0){if(n==="")throw new Z(`Component ${s} was missing value`);u.value=l.stringToValue?.(n)??n}e.push(u),n="",s="",t="protocol"}}}if(s!==""&&n!=="")throw new Z("Incomplete multiaddr");return e}function Cl(r){return`/${r.flatMap(e=>{if(e.value==null)return e.name;const t=xt.getProtocol(e.code);if(t==null)throw new Z(`Unknown protocol code ${e.code}`);return[e.name,t.valueToString?.(e.value)??e.value]}).join("/")}`}function Al(r,e,t){return r.size==null||r.size===0?0:r.size>0?r.size/8:Yt(e,t)}const Il=Symbol.for("nodejs.util.inspect.custom"),Co=Symbol.for("@multiformats/multiaddr");function Tl(r){if(r==null&&(r="/"),Hn(r))return r.getComponents();if(r instanceof Uint8Array)return Sl(r);if(typeof r=="string")return r=r.replace(/\/(\/)+/,"/").replace(/(\/)+$/,""),r===""&&(r="/"),xl(r);if(Array.isArray(r))return r;throw new Z("Must be a string, Uint8Array, Component[], or another Multiaddr")}var Ti,le,ct,lt;const nt=class nt{constructor(e="/",t={}){c(this,Ti,!0);D(this,le);D(this,ct);D(this,lt);L(this,le,Tl(e)),t.validate!==!1&&Ll(this)}get bytes(){return m(this,lt)==null&&L(this,lt,_l(m(this,le))),m(this,lt)}toString(){return m(this,ct)==null&&L(this,ct,Cl(m(this,le))),m(this,ct)}toJSON(){return this.toString()}getComponents(){return[...m(this,le).map(e=>({...e}))]}encapsulate(e){const t=new nt(e);return new nt([...m(this,le),...t.getComponents()],{validate:!1})}decapsulate(e){const t=e.toString(),n=this.toString(),s=n.lastIndexOf(t);if(s<0)throw new so(`Address ${this.toString()} does not contain subaddress: ${t}`);return new nt(n.slice(0,s),{validate:!1})}decapsulateCode(e){let t;for(let n=m(this,le).length-1;n>-1;n--)if(m(this,le)[n].code===e){t=n;break}return new nt(m(this,le).slice(0,t),{validate:!1})}equals(e){return Se(this.bytes,e.bytes)}[(Ti=Co,Il)](){return`Multiaddr(${this.toString()})`}};le=new WeakMap,ct=new WeakMap,lt=new WeakMap;let Dr=nt;function Ll(r){r.getComponents().forEach(e=>{const t=xt.getProtocol(e.code);e.value!=null&&t.validate?.(e.value)})}function Hn(r){return!!r?.[Co]}function z(r){return new Dr(r)}function wt(r){const e=new globalThis.AbortController;function t(){const i=r.filter(o=>o?.aborted===!0).map(o=>o?.reason).pop();e.abort(i);for(const o of r)o?.removeEventListener!=null&&o.removeEventListener("abort",t)}for(const i of r){if(i?.aborted===!0){t();break}i?.addEventListener!=null&&i.addEventListener("abort",t)}function n(){for(const i of r)i?.removeEventListener!=null&&i.removeEventListener("abort",t)}const s=e.signal;return s.clear=n,s}const bt=1e3,vt=bt*60,Et=vt*60,Ge=Et*24,Ut=Ge*7,St=Ge*365.25,zt=St/12;function Pl(r,e){if(typeof r=="string")return kl(r);if(typeof r=="number")return Nl(r,e);throw Error(`Value provided to ms() must be a string or number. value=${JSON.stringify(r)}`)}var Ao=Pl;function kl(r){if(typeof r!="string"||r.length===0||r.length>100)throw Error(`Value provided to ms.parse() must be a string with length between 1 and 99. value=${JSON.stringify(r)}`);let e=/^(?<value>-?\d*\.?\d+) *(?<unit>milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|months?|mo|years?|yrs?|y)?$/i.exec(r);if(!e?.groups)return NaN;let{value:t,unit:n="ms"}=e.groups,s=parseFloat(t),i=n.toLowerCase();switch(i){case"years":case"year":case"yrs":case"yr":case"y":return s*St;case"months":case"month":case"mo":return s*zt;case"weeks":case"week":case"w":return s*Ut;case"days":case"day":case"d":return s*Ge;case"hours":case"hour":case"hrs":case"hr":case"h":return s*Et;case"minutes":case"minute":case"mins":case"min":case"m":return s*vt;case"seconds":case"second":case"secs":case"sec":case"s":return s*bt;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return s;default:throw Error(`Unknown unit "${i}" provided to ms.parse(). value=${JSON.stringify(r)}`)}}function Dl(r){let e=Math.abs(r);return e>=St?`${Math.round(r/St)}y`:e>=zt?`${Math.round(r/zt)}mo`:e>=Ut?`${Math.round(r/Ut)}w`:e>=Ge?`${Math.round(r/Ge)}d`:e>=Et?`${Math.round(r/Et)}h`:e>=vt?`${Math.round(r/vt)}m`:e>=bt?`${Math.round(r/bt)}s`:`${r}ms`}function Ml(r){let e=Math.abs(r);return e>=St?Re(r,e,St,"year"):e>=zt?Re(r,e,zt,"month"):e>=Ut?Re(r,e,Ut,"week"):e>=Ge?Re(r,e,Ge,"day"):e>=Et?Re(r,e,Et,"hour"):e>=vt?Re(r,e,vt,"minute"):e>=bt?Re(r,e,bt,"second"):`${r} ms`}function Nl(r,e){if(typeof r!="number"||!Number.isFinite(r))throw Error("Value provided to ms.format() must be of type number.");return e?.long?Ml(r):Dl(r)}function Re(r,e,t,n){let s=e>=t*1.5;return`${Math.round(r/t)} ${n}${s?"s":""}`}function Fl(r){t.debug=t,t.default=t,t.coerce=l,t.disable=i,t.enable=s,t.enabled=o,t.humanize=Ao,t.destroy=u,Object.keys(r).forEach(d=>{t[d]=r[d]}),t.names=[],t.skips=[],t.formatters={};function e(d){let h=0;for(let f=0;f<d.length;f++)h=(h<<5)-h+d.charCodeAt(f),h|=0;return t.colors[Math.abs(h)%t.colors.length]}t.selectColor=e;function t(d,h){let f,p=null,b,x;function y(...k){if(!y.enabled)return;const B=y,T=Number(new Date),rn=T-(f||T);B.diff=rn,B.prev=f,B.curr=T,f=T,k[0]=t.coerce(k[0]),typeof k[0]!="string"&&k.unshift("%O");let ee=0;k[0]=k[0].replace(/%([a-zA-Z%])/g,(sr,uc)=>{if(sr==="%%")return"%";ee++;const Ts=t.formatters[uc];if(typeof Ts=="function"){const dc=k[ee];sr=Ts.call(B,dc),k.splice(ee,1),ee--}return sr}),t.formatArgs.call(B,k),h?.onLog!=null&&h.onLog(...k),(B.log||t.log).apply(B,k)}return y.namespace=d,y.useColors=t.useColors(),y.color=t.selectColor(d),y.extend=n,y.destroy=t.destroy,Object.defineProperty(y,"enabled",{enumerable:!0,configurable:!1,get:()=>p!==null?p:(b!==t.namespaces&&(b=t.namespaces,x=t.enabled(d)),x),set:k=>{p=k}}),typeof t.init=="function"&&t.init(y),y}function n(d,h){const f=t(this.namespace+(typeof h>"u"?":":h)+d);return f.log=this.log,f}function s(d){t.save(d),t.namespaces=d,t.names=[],t.skips=[];let h;const f=(typeof d=="string"?d:"").split(/[\s,]+/),p=f.length;for(h=0;h<p;h++)f[h]&&(d=f[h].replace(/\*/g,".*?"),d[0]==="-"?t.skips.push(new RegExp("^"+d.substr(1)+"$")):t.names.push(new RegExp("^"+d+"$")))}function i(){const d=[...t.names.map(a),...t.skips.map(a).map(h=>"-"+h)].join(",");return t.enable(""),d}function o(d){if(d[d.length-1]==="*")return!0;let h,f;for(h=0,f=t.skips.length;h<f;h++)if(t.skips[h].test(d))return!1;for(h=0,f=t.names.length;h<f;h++)if(t.names[h].test(d))return!0;return!1}function a(d){return d.toString().substring(2,d.toString().length-2).replace(/\.\*\?$/,"*")}function l(d){return d instanceof Error?d.stack??d.message:d}function u(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")}return t.setupFormatters(t.formatters),t.enable(t.load()),t}var Rl={};const Ln=Vl(),$l=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"];function Ol(){return typeof window<"u"&&window.process&&(window.process.type==="renderer"||window.process.__nwjs)?!0:typeof navigator<"u"&&navigator.userAgent?.toLowerCase().match(/(edge|trident)\/(\d+)/)!=null?!1:typeof document<"u"&&document.documentElement?.style?.WebkitAppearance||typeof window<"u"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator<"u"&&navigator.userAgent?.toLowerCase().match(/firefox\/(\d+)/)!=null&&parseInt(RegExp.$1,10)>=31||typeof navigator<"u"&&navigator.userAgent?.toLowerCase().match(/applewebkit\/(\d+)/)}function Bl(r){if(r[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+r[0]+(this.useColors?"%c ":" ")+"+"+Ao(this.diff),!this.useColors)return;const e="color: "+this.color;r.splice(1,0,e,"color: inherit");let t=0,n=0;r[0].replace(/%[a-zA-Z%]/g,s=>{s!=="%%"&&(t++,s==="%c"&&(n=t))}),r.splice(n,0,e)}const Ul=console.debug??console.log??(()=>{});function zl(r){try{r?Ln?.setItem("debug",r):Ln?.removeItem("debug")}catch{}}function ql(){let r;try{r=Ln?.getItem("debug")}catch{}return!r&&typeof globalThis.process<"u"&&"env"in globalThis.process&&(r=Rl.DEBUG),r}function Vl(){try{return localStorage}catch{}}function Wl(r){r.j=function(e){try{return JSON.stringify(e)}catch(t){return"[UnexpectedJSONParseError]: "+t.message}}}const H=Fl({formatArgs:Bl,save:zl,load:ql,useColors:Ol,setupFormatters:Wl,colors:$l,storage:Ln,log:Ul});H.formatters.b=r=>r==null?"undefined":Gn.baseEncode(r);H.formatters.t=r=>r==null?"undefined":Yr.baseEncode(r);H.formatters.m=r=>r==null?"undefined":Ec.baseEncode(r);H.formatters.p=r=>r==null?"undefined":r.toString();H.formatters.c=r=>r==null?"undefined":r.toString();H.formatters.k=r=>r==null?"undefined":r.toString();H.formatters.a=r=>r==null?"undefined":r.toString();function Vs(r,e=""){const t=Ws(r.message),n=Ws(r.stack);return t!=null&&n!=null?n.includes(t)?`${n.split(`
`).join(`
${e}`)}`:`${t}
${e}${n.split(`
`).join(`
${e}`)}`:n!=null?`${n.split(`
`).join(`
${e}`)}`:t!=null?`${t}`:`${r.toString()}`}function Kl(r){return r instanceof AggregateError||r?.name==="AggregateError"&&Array.isArray(r.errors)}function Io(r,e=""){if(Kl(r)){let t=Vs(r,e);return r.errors.length>0?(e=`${e}    `,t+=`
${e}${r.errors.map(n=>`${Io(n,`${e}`)}`).join(`
${e}`)}`):t+=`
${e}[Error list was empty]`,t.trim()}return Vs(r,e)}H.formatters.e=r=>r==null?"undefined":Io(r);function Gl(r){const e=()=>{};return e.enabled=!1,e.color="",e.diff=0,e.log=()=>{},e.namespace=r,e.destroy=()=>!0,e.extend=()=>e,e}function yp(r,e){return{forComponent(t){return is(`${r}:${t}`,e)}}}function To(r){return{forComponent(e){return is(e,r)}}}function is(r,e){let t=Gl(`${r}:trace`);return H.enabled(`${r}:trace`)&&H.names.map(n=>n.toString()).find(n=>n.includes(":trace"))!=null&&(t=H(`${r}:trace`,e)),Object.assign(H(r,e),{error:H(`${r}:error`,e),trace:t,newScope:n=>is(`${r}:${n}`,e)})}function wp(r){H.enable(r)}function Ws(r){if(r!=null&&(r=r.trim(),r.length!==0))return r}const Ql=["Object","RegExp","Date","Error","Map","Set","WeakMap","WeakSet","ArrayBuffer","SharedArrayBuffer","DataView","Promise","URL","HTMLElement","Int8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","BigInt64Array","BigUint64Array"];function jl(r){if(r===null)return"null";if(r===void 0)return"undefined";if(r===!0||r===!1)return"boolean";const e=typeof r;if(e==="string"||e==="number"||e==="bigint"||e==="symbol")return e;if(e==="function")return"Function";if(Array.isArray(r))return"Array";if(r instanceof Uint8Array)return"Uint8Array";if(r.constructor===Object)return"Object";const t=Hl(r);return t||"Object"}function Hl(r){const e=Object.prototype.toString.call(r).slice(8,-1);if(Ql.includes(e))return e}class g{constructor(e,t,n){this.major=e,this.majorEncoded=e<<5,this.name=t,this.terminal=n}toString(){return`Type[${this.major}].${this.name}`}compare(e){return this.major<e.major?-1:this.major>e.major?1:0}static equals(e,t){return e===t||e.major===t.major&&e.name===t.name}}g.uint=new g(0,"uint",!0);g.negint=new g(1,"negint",!0);g.bytes=new g(2,"bytes",!0);g.string=new g(3,"string",!0);g.array=new g(4,"array",!1);g.map=new g(5,"map",!1);g.tag=new g(6,"tag",!1);g.float=new g(7,"float",!0);g.false=new g(7,"false",!0);g.true=new g(7,"true",!0);g.null=new g(7,"null",!0);g.undefined=new g(7,"undefined",!0);g.break=new g(7,"break",!0);class S{constructor(e,t,n){this.type=e,this.value=t,this.encodedLength=n,this.encodedBytes=void 0,this.byteValue=void 0}toString(){return`Token[${this.type}].${this.value}`}}const Lo=globalThis.process&&!globalThis.process.browser&&globalThis.Buffer&&typeof globalThis.Buffer.isBuffer=="function",Xl=new TextEncoder;function Mr(r){return Lo&&globalThis.Buffer.isBuffer(r)}function Yl(r){return r instanceof Uint8Array?Mr(r)?new Uint8Array(r.buffer,r.byteOffset,r.byteLength):r:Uint8Array.from(r)}const Jl=24,Zl=200,eu=Lo?r=>r.length>=Jl?globalThis.Buffer.from(r):Ks(r):r=>r.length>=Zl?Xl.encode(r):Ks(r);function tu(r,e){if(Mr(r)&&Mr(e))return r.compare(e);for(let t=0;t<r.length;t++)if(r[t]!==e[t])return r[t]<e[t]?-1:1;return 0}function Ks(r){const e=[];let t=0;for(let n=0;n<r.length;n++){let s=r.charCodeAt(n);s<128?e[t++]=s:s<2048?(e[t++]=s>>6|192,e[t++]=s&63|128):(s&64512)===55296&&n+1<r.length&&(r.charCodeAt(n+1)&64512)===56320?(s=65536+((s&1023)<<10)+(r.charCodeAt(++n)&1023),e[t++]=s>>18|240,e[t++]=s>>12&63|128,e[t++]=s>>6&63|128,e[t++]=s&63|128):(s>=55296&&s<=57343&&(s=65533),e[t++]=s>>12|224,e[t++]=s>>6&63|128,e[t++]=s&63|128)}return e}const A="CBOR decode error:",Po="CBOR encode error:";function Ct(r,e,t){if(r.length-e<t)throw new Error(`${A} not enough data for type`)}const V=[24,256,65536,4294967296,BigInt("18446744073709551616")];function je(r,e,t){Ct(r,e,1);const n=r[e];if(t.strict===!0&&n<V[0])throw new Error(`${A} integer encoded in more bytes than necessary (strict decode)`);return n}function He(r,e,t){Ct(r,e,2);const n=r[e]<<8|r[e+1];if(t.strict===!0&&n<V[1])throw new Error(`${A} integer encoded in more bytes than necessary (strict decode)`);return n}function Xe(r,e,t){Ct(r,e,4);const n=r[e]*16777216+(r[e+1]<<16)+(r[e+2]<<8)+r[e+3];if(t.strict===!0&&n<V[2])throw new Error(`${A} integer encoded in more bytes than necessary (strict decode)`);return n}function Ye(r,e,t){Ct(r,e,8);const n=r[e]*16777216+(r[e+1]<<16)+(r[e+2]<<8)+r[e+3],s=r[e+4]*16777216+(r[e+5]<<16)+(r[e+6]<<8)+r[e+7],i=(BigInt(n)<<BigInt(32))+BigInt(s);if(t.strict===!0&&i<V[3])throw new Error(`${A} integer encoded in more bytes than necessary (strict decode)`);if(i<=Number.MAX_SAFE_INTEGER)return Number(i);if(t.allowBigInt===!0)return i;throw new Error(`${A} integers outside of the safe integer range are not supported`)}function nu(r,e,t,n){return new S(g.uint,je(r,e+1,n),2)}function ru(r,e,t,n){return new S(g.uint,He(r,e+1,n),3)}function su(r,e,t,n){return new S(g.uint,Xe(r,e+1,n),5)}function iu(r,e,t,n){return new S(g.uint,Ye(r,e+1,n),9)}function Je(r,e){return ae(r,0,e.value)}function ae(r,e,t){if(t<V[0]){const n=Number(t);r.push([e|n])}else if(t<V[1]){const n=Number(t);r.push([e|24,n])}else if(t<V[2]){const n=Number(t);r.push([e|25,n>>>8,n&255])}else if(t<V[3]){const n=Number(t);r.push([e|26,n>>>24&255,n>>>16&255,n>>>8&255,n&255])}else{const n=BigInt(t);if(n<V[4]){const s=[e|27,0,0,0,0,0,0,0];let i=Number(n&BigInt(4294967295)),o=Number(n>>BigInt(32)&BigInt(4294967295));s[8]=i&255,i=i>>8,s[7]=i&255,i=i>>8,s[6]=i&255,i=i>>8,s[5]=i&255,s[4]=o&255,o=o>>8,s[3]=o&255,o=o>>8,s[2]=o&255,o=o>>8,s[1]=o&255,r.push(s)}else throw new Error(`${A} encountered BigInt larger than allowable range`)}}Je.encodedSize=function(e){return ae.encodedSize(e.value)};ae.encodedSize=function(e){return e<V[0]?1:e<V[1]?2:e<V[2]?3:e<V[3]?5:9};Je.compareTokens=function(e,t){return e.value<t.value?-1:e.value>t.value?1:0};function ou(r,e,t,n){return new S(g.negint,-1-je(r,e+1,n),2)}function au(r,e,t,n){return new S(g.negint,-1-He(r,e+1,n),3)}function cu(r,e,t,n){return new S(g.negint,-1-Xe(r,e+1,n),5)}const os=BigInt(-1),ko=BigInt(1);function lu(r,e,t,n){const s=Ye(r,e+1,n);if(typeof s!="bigint"){const i=-1-s;if(i>=Number.MIN_SAFE_INTEGER)return new S(g.negint,i,9)}if(n.allowBigInt!==!0)throw new Error(`${A} integers outside of the safe integer range are not supported`);return new S(g.negint,os-BigInt(s),9)}function as(r,e){const t=e.value,n=typeof t=="bigint"?t*os-ko:t*-1-1;ae(r,e.type.majorEncoded,n)}as.encodedSize=function(e){const t=e.value,n=typeof t=="bigint"?t*os-ko:t*-1-1;return n<V[0]?1:n<V[1]?2:n<V[2]?3:n<V[3]?5:9};as.compareTokens=function(e,t){return e.value<t.value?1:e.value>t.value?-1:0};function Jt(r,e,t,n){Ct(r,e,t+n);const s=r.slice(e+t,e+t+n);return new S(g.bytes,s,t+n)}function uu(r,e,t,n){return Jt(r,e,1,t)}function du(r,e,t,n){return Jt(r,e,2,je(r,e+1,n))}function hu(r,e,t,n){return Jt(r,e,3,He(r,e+1,n))}function fu(r,e,t,n){return Jt(r,e,5,Xe(r,e+1,n))}function mu(r,e,t,n){const s=Ye(r,e+1,n);if(typeof s=="bigint")throw new Error(`${A} 64-bit integer bytes lengths not supported`);return Jt(r,e,9,s)}function Pn(r){return r.encodedBytes===void 0&&(r.encodedBytes=g.equals(r.type,g.string)?eu(r.value):r.value),r.encodedBytes}function Xn(r,e){const t=Pn(e);ae(r,e.type.majorEncoded,t.length),r.push(t)}Xn.encodedSize=function(e){const t=Pn(e);return ae.encodedSize(t.length)+t.length};Xn.compareTokens=function(e,t){return pu(Pn(e),Pn(t))};function pu(r,e){return r.length<e.length?-1:r.length>e.length?1:tu(r,e)}const Gs=new TextDecoder,gu=32;function yu(r,e,t){if(t-e<gu){let s="";for(let i=e;i<t;i++){const o=r[i];if(o&128)return Gs.decode(r.subarray(e,t));s+=String.fromCharCode(o)}return s}return Gs.decode(r.subarray(e,t))}function Zt(r,e,t,n,s){const i=t+n;Ct(r,e,i);const o=new S(g.string,yu(r,e+t,e+i),i);return s.retainStringBytes===!0&&(o.byteValue=r.slice(e+t,e+i)),o}function wu(r,e,t,n){return Zt(r,e,1,t,n)}function bu(r,e,t,n){return Zt(r,e,2,je(r,e+1,n),n)}function vu(r,e,t,n){return Zt(r,e,3,He(r,e+1,n),n)}function Eu(r,e,t,n){return Zt(r,e,5,Xe(r,e+1,n),n)}function Su(r,e,t,n){const s=Ye(r,e+1,n);if(typeof s=="bigint")throw new Error(`${A} 64-bit integer string lengths not supported`);return Zt(r,e,9,s,n)}const _u=Xn;function At(r,e,t,n){return new S(g.array,n,t)}function xu(r,e,t,n){return At(r,e,1,t)}function Cu(r,e,t,n){return At(r,e,2,je(r,e+1,n))}function Au(r,e,t,n){return At(r,e,3,He(r,e+1,n))}function Iu(r,e,t,n){return At(r,e,5,Xe(r,e+1,n))}function Tu(r,e,t,n){const s=Ye(r,e+1,n);if(typeof s=="bigint")throw new Error(`${A} 64-bit integer array lengths not supported`);return At(r,e,9,s)}function Lu(r,e,t,n){if(n.allowIndefinite===!1)throw new Error(`${A} indefinite length items not allowed`);return At(r,e,1,1/0)}function cs(r,e){ae(r,g.array.majorEncoded,e.value)}cs.compareTokens=Je.compareTokens;cs.encodedSize=function(e){return ae.encodedSize(e.value)};function It(r,e,t,n){return new S(g.map,n,t)}function Pu(r,e,t,n){return It(r,e,1,t)}function ku(r,e,t,n){return It(r,e,2,je(r,e+1,n))}function Du(r,e,t,n){return It(r,e,3,He(r,e+1,n))}function Mu(r,e,t,n){return It(r,e,5,Xe(r,e+1,n))}function Nu(r,e,t,n){const s=Ye(r,e+1,n);if(typeof s=="bigint")throw new Error(`${A} 64-bit integer map lengths not supported`);return It(r,e,9,s)}function Fu(r,e,t,n){if(n.allowIndefinite===!1)throw new Error(`${A} indefinite length items not allowed`);return It(r,e,1,1/0)}function ls(r,e){ae(r,g.map.majorEncoded,e.value)}ls.compareTokens=Je.compareTokens;ls.encodedSize=function(e){return ae.encodedSize(e.value)};function Ru(r,e,t,n){return new S(g.tag,t,1)}function $u(r,e,t,n){return new S(g.tag,je(r,e+1,n),2)}function Ou(r,e,t,n){return new S(g.tag,He(r,e+1,n),3)}function Bu(r,e,t,n){return new S(g.tag,Xe(r,e+1,n),5)}function Uu(r,e,t,n){return new S(g.tag,Ye(r,e+1,n),9)}function us(r,e){ae(r,g.tag.majorEncoded,e.value)}us.compareTokens=Je.compareTokens;us.encodedSize=function(e){return ae.encodedSize(e.value)};const Do=20,Mo=21,No=22,Fo=23;function zu(r,e,t,n){if(n.allowUndefined===!1)throw new Error(`${A} undefined values are not supported`);return n.coerceUndefinedToNull===!0?new S(g.null,null,1):new S(g.undefined,void 0,1)}function qu(r,e,t,n){if(n.allowIndefinite===!1)throw new Error(`${A} indefinite length items not allowed`);return new S(g.break,void 0,1)}function ds(r,e,t){if(t){if(t.allowNaN===!1&&Number.isNaN(r))throw new Error(`${A} NaN values are not supported`);if(t.allowInfinity===!1&&(r===1/0||r===-1/0))throw new Error(`${A} Infinity values are not supported`)}return new S(g.float,r,e)}function Vu(r,e,t,n){return ds(fs(r,e+1),3,n)}function Wu(r,e,t,n){return ds(ms(r,e+1),5,n)}function Ku(r,e,t,n){return ds(Bo(r,e+1),9,n)}function hs(r,e,t){const n=e.value;if(n===!1)r.push([g.float.majorEncoded|Do]);else if(n===!0)r.push([g.float.majorEncoded|Mo]);else if(n===null)r.push([g.float.majorEncoded|No]);else if(n===void 0)r.push([g.float.majorEncoded|Fo]);else{let s,i=!1;(!t||t.float64!==!0)&&($o(n),s=fs(ce,1),n===s||Number.isNaN(n)?(ce[0]=249,r.push(ce.slice(0,3)),i=!0):(Oo(n),s=ms(ce,1),n===s&&(ce[0]=250,r.push(ce.slice(0,5)),i=!0))),i||(Gu(n),s=Bo(ce,1),ce[0]=251,r.push(ce.slice(0,9)))}}hs.encodedSize=function(e,t){const n=e.value;if(n===!1||n===!0||n===null||n===void 0)return 1;if(!t||t.float64!==!0){$o(n);let s=fs(ce,1);if(n===s||Number.isNaN(n))return 3;if(Oo(n),s=ms(ce,1),n===s)return 5}return 9};const Ro=new ArrayBuffer(9),te=new DataView(Ro,1),ce=new Uint8Array(Ro,0);function $o(r){if(r===1/0)te.setUint16(0,31744,!1);else if(r===-1/0)te.setUint16(0,64512,!1);else if(Number.isNaN(r))te.setUint16(0,32256,!1);else{te.setFloat32(0,r);const e=te.getUint32(0),t=(e&2139095040)>>23,n=e&8388607;if(t===255)te.setUint16(0,31744,!1);else if(t===0)te.setUint16(0,(r&2147483648)>>16|n>>13,!1);else{const s=t-127;s<-24?te.setUint16(0,0):s<-14?te.setUint16(0,(e&2147483648)>>16|1<<24+s,!1):te.setUint16(0,(e&2147483648)>>16|s+15<<10|n>>13,!1)}}}function fs(r,e){if(r.length-e<2)throw new Error(`${A} not enough data for float16`);const t=(r[e]<<8)+r[e+1];if(t===31744)return 1/0;if(t===64512)return-1/0;if(t===32256)return NaN;const n=t>>10&31,s=t&1023;let i;return n===0?i=s*2**-24:n!==31?i=(s+1024)*2**(n-25):i=s===0?1/0:NaN,t&32768?-i:i}function Oo(r){te.setFloat32(0,r,!1)}function ms(r,e){if(r.length-e<4)throw new Error(`${A} not enough data for float32`);const t=(r.byteOffset||0)+e;return new DataView(r.buffer,t,4).getFloat32(0,!1)}function Gu(r){te.setFloat64(0,r,!1)}function Bo(r,e){if(r.length-e<8)throw new Error(`${A} not enough data for float64`);const t=(r.byteOffset||0)+e;return new DataView(r.buffer,t,8).getFloat64(0,!1)}hs.compareTokens=Je.compareTokens;function P(r,e,t){throw new Error(`${A} encountered invalid minor (${t}) for major ${r[e]>>>5}`)}function Yn(r){return()=>{throw new Error(`${A} ${r}`)}}const w=[];for(let r=0;r<=23;r++)w[r]=P;w[24]=nu;w[25]=ru;w[26]=su;w[27]=iu;w[28]=P;w[29]=P;w[30]=P;w[31]=P;for(let r=32;r<=55;r++)w[r]=P;w[56]=ou;w[57]=au;w[58]=cu;w[59]=lu;w[60]=P;w[61]=P;w[62]=P;w[63]=P;for(let r=64;r<=87;r++)w[r]=uu;w[88]=du;w[89]=hu;w[90]=fu;w[91]=mu;w[92]=P;w[93]=P;w[94]=P;w[95]=Yn("indefinite length bytes/strings are not supported");for(let r=96;r<=119;r++)w[r]=wu;w[120]=bu;w[121]=vu;w[122]=Eu;w[123]=Su;w[124]=P;w[125]=P;w[126]=P;w[127]=Yn("indefinite length bytes/strings are not supported");for(let r=128;r<=151;r++)w[r]=xu;w[152]=Cu;w[153]=Au;w[154]=Iu;w[155]=Tu;w[156]=P;w[157]=P;w[158]=P;w[159]=Lu;for(let r=160;r<=183;r++)w[r]=Pu;w[184]=ku;w[185]=Du;w[186]=Mu;w[187]=Nu;w[188]=P;w[189]=P;w[190]=P;w[191]=Fu;for(let r=192;r<=215;r++)w[r]=Ru;w[216]=$u;w[217]=Ou;w[218]=Bu;w[219]=Uu;w[220]=P;w[221]=P;w[222]=P;w[223]=P;for(let r=224;r<=243;r++)w[r]=Yn("simple values are not supported");w[244]=P;w[245]=P;w[246]=P;w[247]=zu;w[248]=Yn("simple values are not supported");w[249]=Vu;w[250]=Wu;w[251]=Ku;w[252]=P;w[253]=P;w[254]=P;w[255]=qu;const ge=[];for(let r=0;r<24;r++)ge[r]=new S(g.uint,r,1);for(let r=-1;r>=-24;r--)ge[31-r]=new S(g.negint,r,1);ge[64]=new S(g.bytes,new Uint8Array(0),1);ge[96]=new S(g.string,"",1);ge[128]=new S(g.array,0,1);ge[160]=new S(g.map,0,1);ge[244]=new S(g.false,!1,1);ge[245]=new S(g.true,!0,1);ge[246]=new S(g.null,null,1);function Qu(){const r=[];return r[g.uint.major]=Je,r[g.negint.major]=as,r[g.bytes.major]=Xn,r[g.string.major]=_u,r[g.array.major]=cs,r[g.map.major]=ls,r[g.tag.major]=us,r[g.float.major]=hs,r}Qu();class kn{constructor(e,t){this.obj=e,this.parent=t}includes(e){let t=this;do if(t.obj===e)return!0;while(t=t.parent);return!1}static createCheck(e,t){if(e&&e.includes(t))throw new Error(`${Po} object contains circular references`);return new kn(t,e)}}const Ae={null:new S(g.null,null),undefined:new S(g.undefined,void 0),true:new S(g.true,!0),false:new S(g.false,!1),emptyArray:new S(g.array,0),emptyMap:new S(g.map,0)},Me={number(r,e,t,n){return!Number.isInteger(r)||!Number.isSafeInteger(r)?new S(g.float,r):r>=0?new S(g.uint,r):new S(g.negint,r)},bigint(r,e,t,n){return r>=BigInt(0)?new S(g.uint,r):new S(g.negint,r)},Uint8Array(r,e,t,n){return new S(g.bytes,r)},string(r,e,t,n){return new S(g.string,r)},boolean(r,e,t,n){return r?Ae.true:Ae.false},null(r,e,t,n){return Ae.null},undefined(r,e,t,n){return Ae.undefined},ArrayBuffer(r,e,t,n){return new S(g.bytes,new Uint8Array(r))},DataView(r,e,t,n){return new S(g.bytes,new Uint8Array(r.buffer,r.byteOffset,r.byteLength))},Array(r,e,t,n){if(!r.length)return t.addBreakTokens===!0?[Ae.emptyArray,new S(g.break)]:Ae.emptyArray;n=kn.createCheck(n,r);const s=[];let i=0;for(const o of r)s[i++]=cr(o,t,n);return t.addBreakTokens?[new S(g.array,r.length),s,new S(g.break)]:[new S(g.array,r.length),s]},Object(r,e,t,n){const s=e!=="Object",i=s?r.keys():Object.keys(r),o=s?r.size:i.length;let a;if(o){a=new Array(o),n=kn.createCheck(n,r);const l=!s&&t.ignoreUndefinedProperties;let u=0;for(const d of i){const h=s?r.get(d):r[d];l&&h===void 0||(a[u++]=[cr(d,t,n),cr(h,t,n)])}u<o&&(a.length=u)}return a?.length?(ju(a,t),t.addBreakTokens?[new S(g.map,a.length),a,new S(g.break)]:[new S(g.map,a.length),a]):t.addBreakTokens===!0?[Ae.emptyMap,new S(g.break)]:Ae.emptyMap}};Me.Map=Me.Object;Me.Buffer=Me.Uint8Array;for(const r of"Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" "))Me[`${r}Array`]=Me.DataView;function cr(r,e={},t){const n=jl(r),s=e&&e.typeEncoders&&e.typeEncoders[n]||Me[n];if(typeof s=="function"){const o=s(r,n,e,t);if(o!=null)return o}const i=Me[n];if(!i)throw new Error(`${Po} unsupported type: ${n}`);return i(r,n,e,t)}function ju(r,e){e.mapSorter&&r.sort(e.mapSorter)}g.uint.majorEncoded;g.negint.majorEncoded;g.bytes.majorEncoded;g.string.majorEncoded;g.array.majorEncoded;g.float.majorEncoded|Do;g.float.majorEncoded|Mo;g.float.majorEncoded|No;g.float.majorEncoded|Fo;BigInt(-1);BigInt(1);const Hu={strict:!1,allowIndefinite:!0,allowUndefined:!0,allowBigInt:!0};class Xu{constructor(e,t={}){this._pos=0,this.data=e,this.options=t}pos(){return this._pos}done(){return this._pos>=this.data.length}next(){const e=this.data[this._pos];let t=ge[e];if(t===void 0){const n=w[e];if(!n)throw new Error(`${A} no decoder for major type ${e>>>5} (byte 0x${e.toString(16).padStart(2,"0")})`);const s=e&31;t=n(this.data,this._pos,s,this.options)}return this._pos+=t.encodedLength,t}}const qt=Symbol.for("DONE"),Jn=Symbol.for("BREAK");function Yu(r,e,t){const n=[];for(let s=0;s<r.value;s++){const i=Vt(e,t);if(i===Jn){if(r.value===1/0)break;throw new Error(`${A} got unexpected break to lengthed array`)}if(i===qt)throw new Error(`${A} found array but not enough entries (got ${s}, expected ${r.value})`);n[s]=i}return n}function Ju(r,e,t){const n=t.useMaps===!0,s=t.rejectDuplicateMapKeys===!0,i=n?void 0:{},o=n?new Map:void 0;for(let a=0;a<r.value;a++){const l=Vt(e,t);if(l===Jn){if(r.value===1/0)break;throw new Error(`${A} got unexpected break to lengthed map`)}if(l===qt)throw new Error(`${A} found map but not enough entries (got ${a} [no key], expected ${r.value})`);if(!n&&typeof l!="string")throw new Error(`${A} non-string keys not supported (got ${typeof l})`);if(s&&(n&&o.has(l)||!n&&Object.hasOwn(i,l)))throw new Error(`${A} found repeat map key "${l}"`);const u=Vt(e,t);if(u===qt)throw new Error(`${A} found map but not enough entries (got ${a} [no value], expected ${r.value})`);n?o.set(l,u):i[l]=u}return n?o:i}function Vt(r,e){if(r.done())return qt;const t=r.next();if(g.equals(t.type,g.break))return Jn;if(t.type.terminal)return t.value;if(g.equals(t.type,g.array))return Yu(t,r,e);if(g.equals(t.type,g.map))return Ju(t,r,e);if(g.equals(t.type,g.tag)){if(e.tags&&typeof e.tags[t.value]=="function"){const n=Vt(r,e);return e.tags[t.value](n)}throw new Error(`${A} tag not supported (${t.value})`)}throw new Error("unsupported")}function Zu(r,e){if(!(r instanceof Uint8Array))throw new Error(`${A} data to decode must be a Uint8Array`);e=Object.assign({},Hu,e);const t=Yl(r),n=e.tokenizer||new Xu(t,e),s=Vt(n,e);if(s===qt)throw new Error(`${A} did not find any content to decode`);if(s===Jn)throw new Error(`${A} got unexpected break`);return[s,r.subarray(n.pos())]}function bp(r,e){const[t,n]=Zu(r,e);if(n.length>0)throw new Error(`${A} too many terminals, data makes no sense`);return t}function se(){const r={};return r.promise=new Promise((e,t)=>{r.resolve=e,r.reject=t}),r}var Uo={exports:{}};(function(r){var e=Object.prototype.hasOwnProperty,t="~";function n(){}Object.create&&(n.prototype=Object.create(null),new n().__proto__||(t=!1));function s(l,u,d){this.fn=l,this.context=u,this.once=d||!1}function i(l,u,d,h,f){if(typeof d!="function")throw new TypeError("The listener must be a function");var p=new s(d,h||l,f),b=t?t+u:u;return l._events[b]?l._events[b].fn?l._events[b]=[l._events[b],p]:l._events[b].push(p):(l._events[b]=p,l._eventsCount++),l}function o(l,u){--l._eventsCount===0?l._events=new n:delete l._events[u]}function a(){this._events=new n,this._eventsCount=0}a.prototype.eventNames=function(){var u=[],d,h;if(this._eventsCount===0)return u;for(h in d=this._events)e.call(d,h)&&u.push(t?h.slice(1):h);return Object.getOwnPropertySymbols?u.concat(Object.getOwnPropertySymbols(d)):u},a.prototype.listeners=function(u){var d=t?t+u:u,h=this._events[d];if(!h)return[];if(h.fn)return[h.fn];for(var f=0,p=h.length,b=new Array(p);f<p;f++)b[f]=h[f].fn;return b},a.prototype.listenerCount=function(u){var d=t?t+u:u,h=this._events[d];return h?h.fn?1:h.length:0},a.prototype.emit=function(u,d,h,f,p,b){var x=t?t+u:u;if(!this._events[x])return!1;var y=this._events[x],k=arguments.length,B,T;if(y.fn){switch(y.once&&this.removeListener(u,y.fn,void 0,!0),k){case 1:return y.fn.call(y.context),!0;case 2:return y.fn.call(y.context,d),!0;case 3:return y.fn.call(y.context,d,h),!0;case 4:return y.fn.call(y.context,d,h,f),!0;case 5:return y.fn.call(y.context,d,h,f,p),!0;case 6:return y.fn.call(y.context,d,h,f,p,b),!0}for(T=1,B=new Array(k-1);T<k;T++)B[T-1]=arguments[T];y.fn.apply(y.context,B)}else{var rn=y.length,ee;for(T=0;T<rn;T++)switch(y[T].once&&this.removeListener(u,y[T].fn,void 0,!0),k){case 1:y[T].fn.call(y[T].context);break;case 2:y[T].fn.call(y[T].context,d);break;case 3:y[T].fn.call(y[T].context,d,h);break;case 4:y[T].fn.call(y[T].context,d,h,f);break;default:if(!B)for(ee=1,B=new Array(k-1);ee<k;ee++)B[ee-1]=arguments[ee];y[T].fn.apply(y[T].context,B)}}return!0},a.prototype.on=function(u,d,h){return i(this,u,d,h,!1)},a.prototype.once=function(u,d,h){return i(this,u,d,h,!0)},a.prototype.removeListener=function(u,d,h,f){var p=t?t+u:u;if(!this._events[p])return this;if(!d)return o(this,p),this;var b=this._events[p];if(b.fn)b.fn===d&&(!f||b.once)&&(!h||b.context===h)&&o(this,p);else{for(var x=0,y=[],k=b.length;x<k;x++)(b[x].fn!==d||f&&!b[x].once||h&&b[x].context!==h)&&y.push(b[x]);y.length?this._events[p]=y.length===1?y[0]:y:o(this,p)}return this},a.prototype.removeAllListeners=function(u){var d;return u?(d=t?t+u:u,this._events[d]&&o(this,d)):(this._events=new n,this._eventsCount=0),this},a.prototype.off=a.prototype.removeListener,a.prototype.addListener=a.prototype.on,a.prefixed=t,a.EventEmitter=a,r.exports=a})(Uo);var ed=Uo.exports;const td=Yi(ed);class ps extends Error{constructor(t,n){super(t,n);c(this,"name","TimeoutError");Error.captureStackTrace?.(this,ps)}}const Qs=r=>r.reason??new DOMException("This operation was aborted.","AbortError");function zo(r,e){const{milliseconds:t,fallback:n,message:s,customTimers:i={setTimeout,clearTimeout},signal:o}=e;let a,l;const d=new Promise((h,f)=>{if(typeof t!="number"||Math.sign(t)!==1)throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${t}\``);if(o?.aborted){f(Qs(o));return}if(o&&(l=()=>{f(Qs(o))},o.addEventListener("abort",l,{once:!0})),r.then(h,f),t===Number.POSITIVE_INFINITY)return;const p=new ps;a=i.setTimeout.call(void 0,()=>{if(n){try{h(n())}catch(b){f(b)}return}typeof r.cancel=="function"&&r.cancel(),s===!1?h():s instanceof Error?f(s):(p.message=s??`Promise timed out after ${t} milliseconds`,f(p))},t)}).finally(()=>{d.clear(),l&&o&&o.removeEventListener("abort",l)});return d.clear=()=>{i.clearTimeout.call(void 0,a),a=void 0},d}function nd(r,e,t){let n=0,s=r.length;for(;s>0;){const i=Math.trunc(s/2);let o=n+i;t(r[o],e)<=0?(n=++o,s-=i+1):s=i}return n}var ne,Li;let rd=(Li=class{constructor(){D(this,ne,[])}enqueue(e,t){const{priority:n=0,id:s}=t??{},i={priority:n,id:s,run:e};if(this.size===0||m(this,ne)[this.size-1].priority>=n){m(this,ne).push(i);return}const o=nd(m(this,ne),i,(a,l)=>l.priority-a.priority);m(this,ne).splice(o,0,i)}setPriority(e,t){const n=m(this,ne).findIndex(i=>i.id===e);if(n===-1)throw new ReferenceError(`No promise function with the id "${e}" exists in the queue.`);const[s]=m(this,ne).splice(n,1);this.enqueue(s.run,{priority:t,id:e})}dequeue(){return m(this,ne).shift()?.run}filter(e){return m(this,ne).filter(t=>t.priority===e.priority).map(t=>t.run)}get size(){return m(this,ne).length}},ne=new WeakMap,Li);var ut,ue,de,Te,Ve,dt,fe,Qt,ht,me,be,re,j,K,U,jt,q,We,ve,Kn,Ke,v,mn,qo,Vo,pn,Wo,Ko,Go,Qo,jo,gn,yn,Nr,wn,Fr,Rr,bn,$e,Ho,et,Xo,$r;class sd extends td{constructor(t){super();D(this,v);D(this,ut);D(this,ue);D(this,de,0);D(this,Te);D(this,Ve,!1);D(this,dt,!1);D(this,fe);D(this,Qt,0);D(this,ht,0);D(this,me);D(this,be);D(this,re);D(this,j,[]);D(this,K,0);D(this,U);D(this,jt);D(this,q,0);D(this,We);D(this,ve);D(this,Kn,1n);D(this,Ke,new Map);c(this,"timeout");if(t={carryoverIntervalCount:!1,intervalCap:Number.POSITIVE_INFINITY,interval:0,concurrency:Number.POSITIVE_INFINITY,autoStart:!0,queueClass:rd,strict:!1,...t},!(typeof t.intervalCap=="number"&&t.intervalCap>=1))throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${t.intervalCap?.toString()??""}\` (${typeof t.intervalCap})`);if(t.interval===void 0||!(Number.isFinite(t.interval)&&t.interval>=0))throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${t.interval?.toString()??""}\` (${typeof t.interval})`);if(t.strict&&t.interval===0)throw new TypeError("The `strict` option requires a non-zero `interval`");if(t.strict&&t.intervalCap===Number.POSITIVE_INFINITY)throw new TypeError("The `strict` option requires a finite `intervalCap`");if(L(this,ut,t.carryoverIntervalCount??t.carryoverConcurrencyCount??!1),L(this,ue,t.intervalCap===Number.POSITIVE_INFINITY||t.interval===0),L(this,Te,t.intervalCap),L(this,fe,t.interval),L(this,re,t.strict),L(this,U,new t.queueClass),L(this,jt,t.queueClass),this.concurrency=t.concurrency,t.timeout!==void 0&&!(Number.isFinite(t.timeout)&&t.timeout>0))throw new TypeError(`Expected \`timeout\` to be a positive finite number, got \`${t.timeout}\` (${typeof t.timeout})`);this.timeout=t.timeout,L(this,ve,t.autoStart===!1),E(this,v,Ho).call(this)}get concurrency(){return m(this,We)}set concurrency(t){if(!(typeof t=="number"&&t>=1))throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${t}\` (${typeof t})`);L(this,We,t),E(this,v,bn).call(this)}setPriority(t,n){if(typeof n!="number"||!Number.isFinite(n))throw new TypeError(`Expected \`priority\` to be a finite number, got \`${n}\` (${typeof n})`);m(this,U).setPriority(t,n)}async add(t,n={}){return n={timeout:this.timeout,...n,id:n.id??(Fe(this,Kn)._++).toString()},new Promise((s,i)=>{const o=Symbol(`task-${n.id}`);m(this,U).enqueue(async()=>{Fe(this,q)._++,m(this,Ke).set(o,{id:n.id,priority:n.priority??0,startTime:Date.now(),timeout:n.timeout});let a;try{try{n.signal?.throwIfAborted()}catch(d){throw E(this,v,Xo).call(this),m(this,Ke).delete(o),d}L(this,ht,Date.now());let l=t({signal:n.signal});if(n.timeout&&(l=zo(Promise.resolve(l),{milliseconds:n.timeout,message:`Task timed out after ${n.timeout}ms (queue has ${m(this,q)} running, ${m(this,U).size} waiting)`})),n.signal){const{signal:d}=n;l=Promise.race([l,new Promise((h,f)=>{a=()=>{f(d.reason)},d.addEventListener("abort",a,{once:!0})})])}const u=await l;s(u),this.emit("completed",u)}catch(l){i(l),this.emit("error",l)}finally{a&&n.signal?.removeEventListener("abort",a),m(this,Ke).delete(o),queueMicrotask(()=>{E(this,v,Go).call(this)})}},n),this.emit("add"),E(this,v,wn).call(this)})}async addAll(t,n){return Promise.all(t.map(async s=>this.add(s,n)))}start(){return m(this,ve)?(L(this,ve,!1),E(this,v,bn).call(this),this):this}pause(){L(this,ve,!0)}clear(){L(this,U,new(m(this,jt))),E(this,v,yn).call(this),E(this,v,$r).call(this),this.emit("empty"),m(this,q)===0&&(E(this,v,Nr).call(this),this.emit("idle")),this.emit("next")}async onEmpty(){m(this,U).size!==0&&await E(this,v,$e).call(this,"empty")}async onSizeLessThan(t){m(this,U).size<t||await E(this,v,$e).call(this,"next",()=>m(this,U).size<t)}async onIdle(){m(this,q)===0&&m(this,U).size===0||await E(this,v,$e).call(this,"idle")}async onPendingZero(){m(this,q)!==0&&await E(this,v,$e).call(this,"pendingZero")}async onRateLimit(){this.isRateLimited||await E(this,v,$e).call(this,"rateLimit")}async onRateLimitCleared(){this.isRateLimited&&await E(this,v,$e).call(this,"rateLimitCleared")}onError(){return new Promise((t,n)=>{const s=i=>{this.off("error",s),n(i)};this.on("error",s)})}get size(){return m(this,U).size}sizeBy(t){return m(this,U).filter(t).length}get pending(){return m(this,q)}get isPaused(){return m(this,ve)}get isRateLimited(){return m(this,Ve)}get isSaturated(){return m(this,q)===m(this,We)&&m(this,U).size>0||this.isRateLimited&&m(this,U).size>0}get runningTasks(){return[...m(this,Ke).values()].map(t=>({...t}))}}ut=new WeakMap,ue=new WeakMap,de=new WeakMap,Te=new WeakMap,Ve=new WeakMap,dt=new WeakMap,fe=new WeakMap,Qt=new WeakMap,ht=new WeakMap,me=new WeakMap,be=new WeakMap,re=new WeakMap,j=new WeakMap,K=new WeakMap,U=new WeakMap,jt=new WeakMap,q=new WeakMap,We=new WeakMap,ve=new WeakMap,Kn=new WeakMap,Ke=new WeakMap,v=new WeakSet,mn=function(t){for(;m(this,K)<m(this,j).length;){const s=m(this,j)[m(this,K)];if(s!==void 0&&t-s>=m(this,fe))Fe(this,K)._++;else break}(m(this,K)>100&&m(this,K)>m(this,j).length/2||m(this,K)===m(this,j).length)&&(L(this,j,m(this,j).slice(m(this,K))),L(this,K,0))},qo=function(t){m(this,re)?m(this,j).push(t):Fe(this,de)._++},Vo=function(){m(this,re)?m(this,j).length>m(this,K)&&m(this,j).pop():m(this,de)>0&&Fe(this,de)._--},pn=function(){return m(this,j).length-m(this,K)},Wo=function(){return m(this,ue)?!0:m(this,re)?E(this,v,pn).call(this)<m(this,Te):m(this,de)<m(this,Te)},Ko=function(){return m(this,q)<m(this,We)},Go=function(){Fe(this,q)._--,m(this,q)===0&&this.emit("pendingZero"),E(this,v,wn).call(this),this.emit("next")},Qo=function(){L(this,be,void 0),E(this,v,Rr).call(this),E(this,v,Fr).call(this)},jo=function(t){if(m(this,re)){if(E(this,v,mn).call(this,t),E(this,v,pn).call(this)>=m(this,Te)){const s=m(this,j)[m(this,K)],i=m(this,fe)-(t-s);return E(this,v,gn).call(this,i),!0}return!1}if(m(this,me)===void 0){const n=m(this,Qt)-t;if(n<0){if(m(this,ht)>0){const s=t-m(this,ht);if(s<m(this,fe))return E(this,v,gn).call(this,m(this,fe)-s),!0}L(this,de,m(this,ut)?m(this,q):0)}else return E(this,v,gn).call(this,n),!0}return!1},gn=function(t){m(this,be)===void 0&&L(this,be,setTimeout(()=>{E(this,v,Qo).call(this)},t))},yn=function(){m(this,me)&&(clearInterval(m(this,me)),L(this,me,void 0))},Nr=function(){m(this,be)&&(clearTimeout(m(this,be)),L(this,be,void 0))},wn=function(){if(m(this,U).size===0){if(E(this,v,yn).call(this),this.emit("empty"),m(this,q)===0){if(E(this,v,Nr).call(this),m(this,re)&&m(this,K)>0){const n=Date.now();E(this,v,mn).call(this,n)}this.emit("idle")}return!1}let t=!1;if(!m(this,ve)){const n=Date.now(),s=!E(this,v,jo).call(this,n);if(m(this,v,Wo)&&m(this,v,Ko)){const i=m(this,U).dequeue();m(this,ue)||(E(this,v,qo).call(this,n),E(this,v,et).call(this)),this.emit("active"),i(),s&&E(this,v,Fr).call(this),t=!0}}return t},Fr=function(){m(this,ue)||m(this,me)!==void 0||m(this,re)||(L(this,me,setInterval(()=>{E(this,v,Rr).call(this)},m(this,fe))),L(this,Qt,Date.now()+m(this,fe)))},Rr=function(){m(this,re)||(m(this,de)===0&&m(this,q)===0&&m(this,me)&&E(this,v,yn).call(this),L(this,de,m(this,ut)?m(this,q):0)),E(this,v,bn).call(this),E(this,v,et).call(this)},bn=function(){for(;E(this,v,wn).call(this););},$e=async function(t,n){return new Promise(s=>{const i=()=>{n&&!n()||(this.off(t,i),s())};this.on(t,i)})},Ho=function(){m(this,ue)||(this.on("add",()=>{m(this,U).size>0&&E(this,v,et).call(this)}),this.on("next",()=>{E(this,v,et).call(this)}))},et=function(){m(this,ue)||m(this,dt)||(L(this,dt,!0),queueMicrotask(()=>{L(this,dt,!1),E(this,v,$r).call(this)}))},Xo=function(){m(this,ue)||(E(this,v,Vo).call(this),E(this,v,et).call(this))},$r=function(){const t=m(this,Ve);if(m(this,ue)||m(this,U).size===0){t&&(L(this,Ve,!1),this.emit("rateLimitCleared"));return}let n;if(m(this,re)){const i=Date.now();E(this,v,mn).call(this,i),n=E(this,v,pn).call(this)}else n=m(this,de);const s=n>=m(this,Te);s!==t&&(L(this,Ve,s),this.emit(s?"rateLimit":"rateLimitCleared"))};function id(r){const[e,t]=r[Symbol.asyncIterator]!=null?[r[Symbol.asyncIterator](),Symbol.asyncIterator]:[r[Symbol.iterator](),Symbol.iterator],n=[];return{peek:()=>e.next(),push:s=>{n.push(s)},next:()=>n.length>0?{done:!1,value:n.shift()}:e.next(),[t](){return this}}}async function od(r){if(r.connectionProtector===null&&globalThis.process?.env?.LIBP2P_FORCE_PNET!=null)throw new N("Private network is enforced, but no protector was provided");return r}function Rt(r,e){const t={[Symbol.iterator]:()=>t,next:()=>{const n=r.next(),s=n.value;return n.done===!0||s==null?{done:!0,value:void 0}:{done:!1,value:e(s)}}};return t}function lr(r){const e=Xr(Gn.decode(`z${r}`));return jn(e)}class en{constructor(e){c(this,"map");if(this.map=new Map,e!=null)for(const[t,n]of e.entries())this.map.set(t.toString(),{key:t,value:n})}[Symbol.iterator](){return this.entries()}clear(){this.map.clear()}delete(e){return this.map.delete(e.toString())}entries(){return Rt(this.map.entries(),e=>[e[1].key,e[1].value])}forEach(e){this.map.forEach((t,n)=>{e(t.value,t.key,this)})}get(e){return this.map.get(e.toString())?.value}has(e){return this.map.has(e.toString())}set(e,t){this.map.set(e.toString(),{key:e,value:t})}keys(){return Rt(this.map.values(),e=>e.key)}values(){return Rt(this.map.values(),e=>e.value)}get size(){return this.map.size}}class at{constructor(e){c(this,"set");if(this.set=new Set,e!=null)for(const t of e)this.set.add(t.toString())}get size(){return this.set.size}[Symbol.iterator](){return this.values()}add(e){this.set.add(e.toString())}clear(){this.set.clear()}delete(e){this.set.delete(e.toString())}entries(){return Rt(this.set.entries(),e=>{const t=lr(e[0]);return[t,t]})}forEach(e){this.set.forEach(t=>{const n=lr(t);e(n,n,this)})}has(e){return this.set.has(e.toString())}values(){return Rt(this.set.values(),e=>lr(e))}intersection(e){const t=new at;for(const n of e)this.has(n)&&t.add(n);return t}difference(e){const t=new at;for(const n of this)e.has(n)||t.add(n);return t}union(e){const t=new at;for(const n of e)t.add(n);for(const n of this)t.add(n);return t}}const gs={32:16777619n,64:1099511628211n,128:309485009821345068724781371n,256:374144419156711147060143317175368453031918731002211n,512:35835915874844867368919076489095108449946327955754392558399825615420669938882575126094039892345713852759n,1024:5016456510113118655434598811035278955030765345404790744303017523831112055108147451509157692220295382716162651878526895249385292291816524375083746691371804094271873160484737966720260389217684476157468082573n},Yo={32:2166136261n,64:14695981039346656037n,128:144066263297769815596495629667062367629n,256:100029257958052580907070968620625704837092796014241193945225284501741471925557n,512:9659303129496669498009435400716310466090418745672637896108374329434462657994582932197716438449813051892206539805784495328239340083876191928701583869517785n,1024:14197795064947621068722070641403218320880622795441933960878474914617582723252296732303717722150864096521202355549365628174669108571814760471015076148029755969804077320157692458563003215304957150157403644460363550505412711285966361610267868082893823963790439336411086884584107735010676915n},Jo=new globalThis.TextEncoder;function ad(r,e){const t=gs[e];let n=Yo[e];for(let s=0;s<r.length;s++)n^=BigInt(r[s]),n=BigInt.asUintN(e,n*t);return n}function cd(r,e,t){if(t.length===0)throw new Error("The `utf8Buffer` option must have a length greater than zero");const n=gs[e];let s=Yo[e],i=r;for(;i.length>0;){const o=Jo.encodeInto(i,t);i=i.slice(o.read);for(let a=0;a<o.written;a++)s^=BigInt(t[a]),s=BigInt.asUintN(e,s*n)}return s}function ld(r,{size:e=32,utf8Buffer:t}={}){if(!gs[e])throw new Error("The `size` option must be one of 32, 64, 128, 256, 512, or 1024");if(typeof r=="string"){if(t)return cd(r,e,t);r=Jo.encode(r)}return ad(r,e)}const ys={hash:r=>Number(ld(r,{size:32})),hashV:(r,e)=>ud(ys.hash(r,e))};function ud(r){let e=r.toString(16);return e.length%2===1&&(e=`0${e}`),F(e,"base16")}const Zo=64;class Be{constructor(e,t,n,s=2){c(this,"fp");c(this,"h");c(this,"seed");if(s>Zo)throw new TypeError("Invalid Fingerprint Size");const i=t.hashV(e,n),o=Ee(s);for(let a=0;a<o.length;a++)o[a]=i[a];o.length===0&&(o[0]=7),this.fp=o,this.h=t,this.seed=n}hash(){return this.h.hash(this.fp,this.seed)}equals(e){return e?.fp instanceof Uint8Array?Se(this.fp,e.fp):!1}}function Dn(r,e){return Math.floor(Math.random()*(e-r))+r}class on{constructor(e){c(this,"contents");this.contents=new Array(e).fill(null)}has(e){if(!(e instanceof Be))throw new TypeError("Invalid Fingerprint");return this.contents.some(t=>e.equals(t))}add(e){if(!(e instanceof Be))throw new TypeError("Invalid Fingerprint");for(let t=0;t<this.contents.length;t++)if(this.contents[t]==null)return this.contents[t]=e,!0;return!0}swap(e){if(!(e instanceof Be))throw new TypeError("Invalid Fingerprint");const t=Dn(0,this.contents.length-1),n=this.contents[t];return this.contents[t]=e,n}remove(e){if(!(e instanceof Be))throw new TypeError("Invalid Fingerprint");const t=this.contents.findIndex(n=>e.equals(n));return t>-1?(this.contents[t]=null,!0):!1}}const dd=500;class js{constructor(e){c(this,"bucketSize");c(this,"filterSize");c(this,"fingerprintSize");c(this,"buckets");c(this,"count");c(this,"hash");c(this,"seed");this.filterSize=e.filterSize,this.bucketSize=e.bucketSize??4,this.fingerprintSize=e.fingerprintSize??2,this.count=0,this.buckets=[],this.hash=e.hash??ys,this.seed=e.seed??Dn(0,Math.pow(2,10))}add(e){typeof e=="string"&&(e=F(e));const t=new Be(e,this.hash,this.seed,this.fingerprintSize),n=this.hash.hash(e,this.seed)%this.filterSize,s=(n^t.hash())%this.filterSize;if(this.buckets[n]==null&&(this.buckets[n]=new on(this.bucketSize)),this.buckets[s]==null&&(this.buckets[s]=new on(this.bucketSize)),this.buckets[n].add(t)||this.buckets[s].add(t))return this.count++,!0;const i=[n,s];let o=i[Dn(0,i.length-1)];this.buckets[o]==null&&(this.buckets[o]=new on(this.bucketSize));for(let a=0;a<dd;a++){const l=this.buckets[o].swap(t);if(l!=null&&(o=(o^l.hash())%this.filterSize,this.buckets[o]==null&&(this.buckets[o]=new on(this.bucketSize)),this.buckets[o].add(l)))return this.count++,!0}return!1}has(e){typeof e=="string"&&(e=F(e));const t=new Be(e,this.hash,this.seed,this.fingerprintSize),n=this.hash.hash(e,this.seed)%this.filterSize,s=this.buckets[n]?.has(t)??!1;if(s)return s;const i=(n^t.hash())%this.filterSize;return this.buckets[i]?.has(t)??!1}remove(e){typeof e=="string"&&(e=F(e));const t=new Be(e,this.hash,this.seed,this.fingerprintSize),n=this.hash.hash(e,this.seed)%this.filterSize,s=this.buckets[n]?.remove(t)??!1;if(s)return this.count--,s;const i=(n^t.hash())%this.filterSize,o=this.buckets[i]?.remove(t)??!1;return o&&this.count--,o}get reliable(){return Math.floor(100*(this.count/this.filterSize))<=90}}const hd={1:.5,2:.84,4:.95,8:.98};function fd(r=.001){return r>.002?2:r>1e-5?4:8}function md(r,e=.001){const t=fd(e),n=hd[t],s=Math.round(r/n),i=Math.min(Math.ceil(Math.log2(1/e)+Math.log2(2*t)),Zo);return{filterSize:s,bucketSize:t,fingerprintSize:i}}class pd{constructor(e){c(this,"filterSize");c(this,"bucketSize");c(this,"fingerprintSize");c(this,"scale");c(this,"filterSeries");c(this,"hash");c(this,"seed");this.bucketSize=e.bucketSize??4,this.filterSize=e.filterSize??(1<<18)/this.bucketSize,this.fingerprintSize=e.fingerprintSize??2,this.scale=e.scale??2,this.hash=e.hash??ys,this.seed=e.seed??Dn(0,Math.pow(2,10)),this.filterSeries=[new js({filterSize:this.filterSize,bucketSize:this.bucketSize,fingerprintSize:this.fingerprintSize,hash:this.hash,seed:this.seed})]}add(e){if(typeof e=="string"&&(e=F(e)),this.has(e))return!0;let t=this.filterSeries.find(n=>n.reliable);if(t==null){const n=this.filterSize*Math.pow(this.scale,this.filterSeries.length);t=new js({filterSize:n,bucketSize:this.bucketSize,fingerprintSize:this.fingerprintSize,hash:this.hash,seed:this.seed}),this.filterSeries.push(t)}return t.add(e)}has(e){typeof e=="string"&&(e=F(e));for(let t=0;t<this.filterSeries.length;t++)if(this.filterSeries[t].has(e))return!0;return!1}remove(e){typeof e=="string"&&(e=F(e));for(let t=0;t<this.filterSeries.length;t++)if(this.filterSeries[t].remove(e))return!0;return!1}get count(){return this.filterSeries.reduce((e,t)=>e+t.count,0)}}function ws(r,e=.001,t){return new pd({...md(r,e)})}function R(r){const e=r.getComponents(),t={};let n=0;if(e[n]?.name==="ip6zone"&&(t.zone=`${e[n].value}`,n++),e[n].name==="ip4"||e[n].name==="ip6"||e[n].name==="dns"||e[n].name==="dns4"||e[n].name==="dns6"?(t.type=e[n].name,t.host=e[n].value,n++):e[n].name==="dnsaddr"&&(t.type=e[n].name,t.host=`_dnsaddr.${e[n].value}`,n++),(e[n]?.name==="tcp"||e[n]?.name==="udp")&&(t.protocol=e[n].name==="tcp"?"tcp":"udp",t.port=parseInt(`${e[n].value}`),n++),e[n]?.name==="ipcidr"&&(t.type==="ip4"?t.cidr=parseInt(`${e[n].value}`):t.type==="ip6"&&(t.cidr=`${e[n].value}`),n++),t.type==null||t.host==null)throw new N(`Multiaddr ${r} was not an IPv4, IPv6, DNS, DNS4, DNS6 or DNSADDR address`);return e[n]?.name==="tls"&&e[n+1]?.name==="sni"&&(t.sni=e[n+1].value,n+=2),t}function gd(r,e,t){let n=0;for(const s of r)if(!(n<e)){if(n>t)break;if(s!==255)return!1;n++}return!0}function yd(r,e,t,n){let s=0;for(const i of r)if(!(s<t)){if(s>n)break;if(i!==e[s])return!1;s++}return!0}function wd(r){switch(r.length){case Wt:return r.join(".");case Kt:{const e=[];for(let t=0;t<r.length;t++)t%2===0&&e.push(r[t].toString(16).padStart(2,"0")+r[t+1].toString(16).padStart(2,"0"));return e.join(":")}default:throw new Error("Invalid ip length")}}function bd(r){let e=0;for(let[t,n]of r.entries()){if(n===255){e+=8;continue}for(;n&128;)e++,n=n<<1;if(n&128)return-1;for(let s=t+1;s<r.length;s++)if(r[s]!=0)return-1;break}return e}function vd(r){let e="0x";for(const t of r)e+=(t>>4).toString(16)+(t&15).toString(16);return e}const Wt=4,Kt=16,Ed=new Uint8Array([0,0,0,0,0,0,0,0,0,0,255,255]);function ea(r,e){e.length===Kt&&r.length===Wt&&gd(e,0,11)&&(e=e.slice(12)),e.length===Wt&&r.length===Kt&&yd(r,Ed,0,11)&&(r=r.slice(12));const t=r.length;if(t!=e.length)throw new Error("Failed to mask ip");const n=new Uint8Array(t);for(let s=0;s<t;s++)n[s]=r[s]&e[s];return n}function Sd(r,e){if(typeof e=="string"&&(e=Pr(e)),e==null)throw new Error("Invalid ip");if(e.length!==r.network.length)return!1;for(let t=0;t<e.length;t++)if((r.network[t]&r.mask[t])!==(e[t]&r.mask[t]))return!1;return!0}function _d(r){const[e,t]=r.split("/");if(!e||!t)throw new Error("Failed to parse given CIDR: "+r);let n=Wt,s=ao(e);if(s==null&&(n=Kt,s=co(e),s==null))throw new Error("Failed to parse given CIDR: "+r);const i=parseInt(t,10);if(Number.isNaN(i)||String(i).length!==t.length||i<0||i>n*8)throw new Error("Failed to parse given CIDR: "+r);const o=ta(i,8*n);return{network:ea(s,o),mask:o}}function ta(r,e){if(e!==8*Wt&&e!==8*Kt)throw new Error("Invalid CIDR mask");if(r<0||r>e)throw new Error("Invalid CIDR mask");const t=e/8,n=new Uint8Array(t);for(let s=0;s<t;s++){if(r>=8){n[s]=255,r-=8;continue}n[s]=255-(255>>r),r=0}return n}class na{constructor(e,t){if(t==null)({network:this.network,mask:this.mask}=_d(e));else{const n=Pr(e);if(n==null)throw new Error("Failed to parse network");t=String(t);const s=parseInt(t,10);if(Number.isNaN(s)||String(s).length!==t.length||s<0||s>n.length*8){const i=Pr(t);if(i==null)throw new Error("Failed to parse mask");this.mask=i}else this.mask=ta(s,8*n.length);this.network=ea(n,this.mask)}}contains(e){return Sd({network:this.network,mask:this.mask},e)}toString(){const e=bd(this.mask),t=e!==-1?String(e):vd(this.mask);return wd(this.network)+"/"+t}}function xd(r,e){return new na(r).contains(e)}function Ep(r){try{const e=R(r);switch(e.type){case"ip6":return xd("2000::/3",e.host);default:return!1}}catch{return!1}}function Cd(r){try{const e=R(r);switch(e.type){case"ip4":return e.host.startsWith("169.254.");case"ip6":return e.host.toLowerCase().startsWith("fe80");default:return!1}}catch{return!1}}function Ad(r){return/^127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(r)||/^::1$/.test(r)}function Or(r){try{const e=R(r);switch(e.type){case"ip4":case"ip6":return Ad(e.host);default:return!1}}catch{return!1}}function he(r){try{return R(r),!0}catch{return!1}}var ra;(function(){var r,e,t,n,s,i,o,a;a=function(l){var u,d,h,f;return u=(l&255<<24)>>>24,d=(l&255<<16)>>>16,h=(l&65280)>>>8,f=l&255,[u,d,h,f].join(".")},o=function(l){var u,d,h,f,p,b;for(u=[],h=f=0;f<=3&&l.length!==0;h=++f){if(h>0){if(l[0]!==".")throw new Error("Invalid IP");l=l.substring(1)}b=e(l),p=b[0],d=b[1],l=l.substring(d),u.push(p)}if(l.length!==0)throw new Error("Invalid IP");switch(u.length){case 1:if(u[0]>4294967295)throw new Error("Invalid IP");return u[0]>>>0;case 2:if(u[0]>255||u[1]>16777215)throw new Error("Invalid IP");return(u[0]<<24|u[1])>>>0;case 3:if(u[0]>255||u[1]>255||u[2]>65535)throw new Error("Invalid IP");return(u[0]<<24|u[1]<<16|u[2])>>>0;case 4:if(u[0]>255||u[1]>255||u[2]>255||u[3]>255)throw new Error("Invalid IP");return(u[0]<<24|u[1]<<16|u[2]<<8|u[3])>>>0;default:throw new Error("Invalid IP")}},t=function(l){return l.charCodeAt(0)},n=t("0"),i=t("a"),s=t("A"),e=function(l){var u,d,h,f,p;for(f=0,u=10,d="9",h=0,l.length>1&&l[h]==="0"&&(l[h+1]==="x"||l[h+1]==="X"?(h+=2,u=16):"0"<=l[h+1]&&l[h+1]<="9"&&(h++,u=8,d="7")),p=h;h<l.length;){if("0"<=l[h]&&l[h]<=d)f=f*u+(t(l[h])-n)>>>0;else if(u===16)if("a"<=l[h]&&l[h]<="f")f=f*u+(10+t(l[h])-i)>>>0;else if("A"<=l[h]&&l[h]<="F")f=f*u+(10+t(l[h])-s)>>>0;else break;else break;if(f>4294967295)throw new Error("too large");h++}if(h===p)throw new Error("empty octet");return[f,h]},r=function(){function l(u,d){var h,f,p;if(typeof u!="string")throw new Error("Missing `net' parameter");if(d||(p=u.split("/",2),u=p[0],d=p[1]),d||(d=32),typeof d=="string"&&d.indexOf(".")>-1){try{this.maskLong=o(d)}catch{throw new Error("Invalid mask: "+d)}for(h=f=32;f>=0;h=--f)if(this.maskLong===4294967295<<32-h>>>0){this.bitmask=h;break}}else if(d||d===0)this.bitmask=parseInt(d,10),this.maskLong=0,this.bitmask>0&&(this.maskLong=4294967295<<32-this.bitmask>>>0);else throw new Error("Invalid mask: empty");try{this.netLong=(o(u)&this.maskLong)>>>0}catch{throw new Error("Invalid net address: "+u)}if(!(this.bitmask<=32))throw new Error("Invalid mask for ip4: "+d);this.size=Math.pow(2,32-this.bitmask),this.base=a(this.netLong),this.mask=a(this.maskLong),this.hostmask=a(~this.maskLong),this.first=this.bitmask<=30?a(this.netLong+1):this.base,this.last=this.bitmask<=30?a(this.netLong+this.size-2):a(this.netLong+this.size-1),this.broadcast=this.bitmask<=30?a(this.netLong+this.size-1):void 0}return l.prototype.contains=function(u){return typeof u=="string"&&(u.indexOf("/")>0||u.split(".").length!==4)&&(u=new l(u)),u instanceof l?this.contains(u.base)&&this.contains(u.broadcast||u.last):(o(u)&this.maskLong)>>>0===(this.netLong&this.maskLong)>>>0},l.prototype.next=function(u){return u==null&&(u=1),new l(a(this.netLong+this.size*u),this.mask)},l.prototype.forEach=function(u){var d,h,f;for(f=o(this.first),h=o(this.last),d=0;f<=h;)u(a(f),f,d),d++,f++},l.prototype.toString=function(){return this.base+"/"+this.bitmask},l}(),ra=r}).call(Oc);const Id=["0.0.0.0/8","10.0.0.0/8","100.64.0.0/10","127.0.0.0/8","169.254.0.0/16","172.16.0.0/12","192.0.0.0/24","192.0.0.0/29","192.0.0.8/32","192.0.0.9/32","192.0.0.10/32","192.0.0.170/32","192.0.0.171/32","192.0.2.0/24","192.31.196.0/24","192.52.193.0/24","192.88.99.0/24","192.168.0.0/16","192.175.48.0/24","198.18.0.0/15","198.51.100.0/24","203.0.113.0/24","240.0.0.0/4","255.255.255.255/32"],Td=Id.map(r=>new ra(r));function bs(r){for(const e of Td)if(e.contains(r))return!0;return!1}function Ld(r){return/^::ffff:([0-9a-fA-F]{1,4}):([0-9a-fA-F]{1,4})$/.test(r)}function Pd(r){const e=r.split(":");if(e.length<2)return!1;const t=e[e.length-1].padStart(4,"0"),n=e[e.length-2].padStart(4,"0"),s=`${parseInt(n.substring(0,2),16)}.${parseInt(n.substring(2),16)}.${parseInt(t.substring(0,2),16)}.${parseInt(t.substring(2),16)}`;return bs(s)}function kd(r){return/^::ffff:([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(r)}function Dd(r){const e=r.split(":"),t=e[e.length-1];return bs(t)}function Md(r){return/^::$/.test(r)||/^::1$/.test(r)||/^64:ff9b::([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(r)||/^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^f[c-d]([0-9a-fA-F]{2,2}):/i.test(r)||/^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(r)||/^ff([0-9a-fA-F]{2,2}):/i.test(r)}function vs(r){if(yt(r))return bs(r);if(Ld(r))return Pd(r);if(kd(r))return Dd(r);if(lo(r))return Md(r)}function Gt(r){try{const e=R(r);switch(e.type){case"ip4":case"ip6":return vs(e.host)??!1;default:return e.host==="localhost"}}catch{return!1}}class Hs{constructor(e){c(this,"buffer");c(this,"mask");c(this,"top");c(this,"btm");c(this,"next");if(!(e>0)||e-1&e)throw new Error("Max size for a FixedFIFO should be a power of two");this.buffer=new Array(e),this.mask=e-1,this.top=0,this.btm=0,this.next=null}push(e){return this.buffer[this.top]!==void 0?!1:(this.buffer[this.top]=e,this.top=this.top+1&this.mask,!0)}shift(){const e=this.buffer[this.btm];if(e!==void 0)return this.buffer[this.btm]=void 0,this.btm=this.btm+1&this.mask,e}isEmpty(){return this.buffer[this.btm]===void 0}}class ur{constructor(e={}){c(this,"size");c(this,"hwm");c(this,"head");c(this,"tail");this.hwm=e.splitLimit??16,this.head=new Hs(this.hwm),this.tail=this.head,this.size=0}calculateSize(e){return e?.byteLength!=null?e.byteLength:1}push(e){if(e?.value!=null&&(this.size+=this.calculateSize(e.value)),!this.head.push(e)){const t=this.head;this.head=t.next=new Hs(2*this.head.buffer.length),this.head.push(e)}}shift(){let e=this.tail.shift();if(e===void 0&&this.tail.next!=null){const t=this.tail.next;this.tail.next=null,this.tail=t,e=this.tail.shift()}return e?.value!=null&&(this.size-=this.calculateSize(e.value)),e}isEmpty(){return this.head.isEmpty()}}let Nd=class extends Error{constructor(t,n){super(t??"The operation was aborted");c(this,"type");c(this,"code");this.type="aborted",this.code=n??"ABORT_ERR"}};function tn(r={}){return Fd(t=>{const n=t.shift();if(n==null)return{done:!0};if(n.error!=null)throw n.error;return{done:n.done===!0,value:n.value}},r)}function Fd(r,e){e=e??{};let t=e.onEnd,n=new ur,s,i,o,a=se();const l=async()=>{try{return n.isEmpty()?o?{done:!0}:await new Promise((y,k)=>{i=B=>{i=null,n.push(B);try{y(r(n))}catch(T){k(T)}return s}}):r(n)}finally{n.isEmpty()&&queueMicrotask(()=>{a.resolve(),a=se()})}},u=y=>i!=null?i(y):(n.push(y),s),d=y=>(n=new ur,i!=null?i({error:y}):(n.push({error:y}),s)),h=y=>{if(o)return s;if(e?.objectMode!==!0&&y?.byteLength==null)throw new Error("objectMode was not true but tried to push non-Uint8Array value");return u({done:!1,value:y})},f=y=>o?s:(o=!0,y!=null?d(y):u({done:!0})),p=()=>(n=new ur,f(),{done:!0}),b=y=>(f(y),{done:!0});if(s={[Symbol.asyncIterator](){return this},next:l,return:p,throw:b,push:h,end:f,get readableLength(){return n.size},onEmpty:async y=>{const k=y?.signal;if(k?.throwIfAborted(),n.isEmpty())return;let B,T;k!=null&&(B=new Promise((rn,ee)=>{T=()=>{ee(new Nd)},k.addEventListener("abort",T)}));try{await Promise.race([a.promise,B])}finally{T!=null&&k!=null&&k?.removeEventListener("abort",T)}}},t==null)return s;const x=s;return s={[Symbol.asyncIterator](){return this},next(){return x.next()},throw(y){return x.throw(y),t!=null&&(t(y),t=void 0),{done:!0}},return(){return x.return(),t!=null&&(t(),t=void 0),{done:!0}},push:h,end(y){return x.end(y),t!=null&&(t(y),t=void 0),s},get readableLength(){return x.readableLength},onEmpty:y=>x.onEmpty(y)},s}const Rd=r=>{const e=r.addEventListener||r.on||r.addListener,t=r.removeEventListener||r.off||r.removeListener;if(!e||!t)throw new TypeError("Emitter is not compatible");return{addListener:e.bind(r),removeListener:t.bind(r)}};function $d(r,e,t){let n;const s=new Promise((i,o)=>{if(t={rejectionEvents:["error"],multiArgs:!1,rejectionMultiArgs:!1,resolveImmediately:!1,...t},!(t.count>=0&&(t.count===Number.POSITIVE_INFINITY||Number.isInteger(t.count))))throw new TypeError("The `count` option should be at least 0 or more");t.signal?.throwIfAborted();const a=[e].flat(),l=[],{addListener:u,removeListener:d}=Rd(r),h=async(...p)=>{const b=t.multiArgs?p:p[0];if(t.filter)try{if(!await t.filter(b))return}catch(x){n(),o(x);return}l.push(b),t.count===l.length&&(n(),i(l))},f=(...p)=>{n(),o(t.rejectionMultiArgs?p:p[0])};n=()=>{for(const p of a)d(p,h);for(const p of t.rejectionEvents)a.includes(p)||d(p,f)};for(const p of a)u(p,h);for(const p of t.rejectionEvents)a.includes(p)||u(p,f);t.signal&&t.signal.addEventListener("abort",()=>{f(t.signal.reason)},{once:!0}),t.resolveImmediately&&i(l)});if(s.cancel=n,typeof t.timeout=="number"){const i=zo(s,{milliseconds:t.timeout});return i.cancel=()=>{n(),i.clear()},i}return s}function oe(r,e,t){typeof t=="function"&&(t={filter:t}),t={...t,count:1,resolveImmediately:!1};const n=$d(r,e,t),s=n.then(i=>i[0]);return s.cancel=n.cancel,s}function Mn(r,e){let t;const n=function(){const s=function(){t=void 0,r()};clearTimeout(t),t=setTimeout(s,e)};return n.start=()=>{},n.stop=()=>{clearTimeout(t)},n}class Od extends Error{constructor(t="Rate limit exceeded",n){super(t);c(this,"remainingPoints");c(this,"msBeforeNext");c(this,"consumedPoints");c(this,"isFirstInDuration");this.name="RateLimitError",this.remainingPoints=n.remainingPoints,this.msBeforeNext=n.msBeforeNext,this.consumedPoints=n.consumedPoints,this.isFirstInDuration=n.isFirstInDuration}}var _r;let Bd=(_r=class extends Error{constructor(e="The queue was full"){super(e),this.name="QueueFullError"}},c(_r,"name","QueueFullError"),_r);var xr;let Nn=(xr=class extends Error{constructor(){super(...arguments);c(this,"name","UnexpectedEOFError")}},c(xr,"name","UnexpectedEOFError"),xr);class sa extends Error{constructor(){super(...arguments);c(this,"name","MaxEarlyStreamsError")}}c(sa,"name","MaxEarlyStreamsError");class ia extends Error{constructor(){super(...arguments);c(this,"name","StreamClosedError")}}c(ia,"name","StreamClosedError");function Ud(r){return r.reason}async function xe(r,e,t){if(e==null)return r;const n=t?.translateError??Ud;if(e.aborted)return r.catch(()=>{}),Promise.reject(n(e));let s;try{return await Promise.race([r,new Promise((i,o)=>{s=()=>{o(n(e))},e.addEventListener("abort",s)})])}finally{s!=null&&e.removeEventListener("abort",s)}}let zd=class{constructor(e){c(this,"deferred");c(this,"signal");this.signal=e,this.deferred=se(),this.onAbort=this.onAbort.bind(this),this.signal?.addEventListener("abort",this.onAbort)}onAbort(){this.deferred.reject(this.signal?.reason??new Ot)}cleanup(){this.signal?.removeEventListener("abort",this.onAbort)}};function qd(){return`${parseInt(String(Math.random()*1e9),10).toString()}${Date.now()}`}let Vd=class{constructor(e,t){c(this,"id");c(this,"fn");c(this,"options");c(this,"recipients");c(this,"status");c(this,"timeline");c(this,"controller");this.id=qd(),this.status="queued",this.fn=e,this.options=t,this.recipients=[],this.timeline={created:Date.now()},this.controller=new AbortController,pe(1/0,this.controller.signal),this.onAbort=this.onAbort.bind(this)}abort(e){this.controller.abort(e)}onAbort(){this.recipients.reduce((t,n)=>t&&n.signal?.aborted===!0,!0)&&(this.controller.abort(new Ot),this.cleanup())}async join(e={}){const t=new zd(e.signal);return this.recipients.push(t),e.signal?.addEventListener("abort",this.onAbort),t.deferred.promise}async run(){this.status="running",this.timeline.started=Date.now();try{this.controller.signal.throwIfAborted();const e=await xe(this.fn({...this.options??{},signal:this.controller.signal}),this.controller.signal);this.recipients.forEach(t=>{t.deferred.resolve(e)}),this.status="complete"}catch(e){this.recipients.forEach(t=>{t.deferred.reject(e)}),this.status="errored"}finally{this.timeline.finished=Date.now(),this.cleanup()}}cleanup(){this.recipients.forEach(e=>{e.cleanup(),e.signal?.removeEventListener("abort",this.onAbort)})}},oa=class extends _e{constructor(t={}){super();c(this,"concurrency");c(this,"maxSize");c(this,"queue");c(this,"pending");c(this,"sort");c(this,"paused");this.concurrency=t.concurrency??Number.POSITIVE_INFINITY,this.maxSize=t.maxSize??Number.POSITIVE_INFINITY,this.pending=0,this.paused=!1,t.metricName!=null&&t.metrics?.registerMetricGroup(t.metricName,{calculate:()=>({size:this.queue.length,running:this.pending,queued:this.queue.length-this.pending})}),this.sort=t.sort,this.queue=[],this.emitEmpty=Mn(this.emitEmpty.bind(this),1),this.emitIdle=Mn(this.emitIdle.bind(this),1)}emitEmpty(){this.size===0&&this.safeDispatchEvent("empty")}emitIdle(){this.running===0&&this.safeDispatchEvent("idle")}pause(){this.paused=!0}resume(){this.paused&&(this.paused=!1,this.tryToStartAnother())}tryToStartAnother(){if(this.paused)return!1;if(this.size===0)return this.emitEmpty(),this.running===0&&this.emitIdle(),!1;if(this.pending<this.concurrency){let t;for(const n of this.queue)if(n.status==="queued"){t=n;break}return t==null?!1:(this.safeDispatchEvent("active"),this.pending++,t.run().finally(()=>{for(let n=0;n<this.queue.length;n++)if(this.queue[n]===t){this.queue.splice(n,1);break}this.pending--,this.tryToStartAnother(),this.safeDispatchEvent("next")}),!0)}return!1}enqueue(t){this.queue.push(t),this.sort!=null&&this.queue.sort(this.sort)}async add(t,n){if(n?.signal?.throwIfAborted(),this.size===this.maxSize)throw new Bd;const s=new Vd(t,n);return this.enqueue(s),this.safeDispatchEvent("add"),this.tryToStartAnother(),s.join(n).then(i=>(this.safeDispatchEvent("completed",{detail:i}),this.safeDispatchEvent("success",{detail:{job:s,result:i}}),i)).catch(i=>{if(s.status==="queued"){for(let o=0;o<this.queue.length;o++)if(this.queue[o]===s){this.queue.splice(o,1);break}}throw this.safeDispatchEvent("failure",{detail:{job:s,error:i}}),i})}clear(){this.queue.splice(0,this.queue.length)}abort(){this.queue.forEach(t=>{t.abort(new Ot)}),this.clear()}async onEmpty(t){this.size!==0&&await oe(this,"empty",t)}async onSizeLessThan(t,n){this.size<t||await oe(this,"next",{...n,filter:()=>this.size<t})}async onIdle(t){this.pending===0&&this.size===0||await oe(this,"idle",t)}get size(){return this.queue.length}get queued(){return this.queue.length-this.pending}get running(){return this.pending}async*toGenerator(t){t?.signal?.throwIfAborted();const n=tn({objectMode:!0}),s=u=>{u!=null?this.abort():this.clear(),n.end(u)},i=u=>{u.detail!=null&&n.push(u.detail)},o=u=>{s(u.detail.error)},a=()=>{s()},l=()=>{s(new Ot("Queue aborted"))};this.addEventListener("completed",i),this.addEventListener("failure",o),this.addEventListener("idle",a),t?.signal?.addEventListener("abort",l);try{yield*n}finally{this.removeEventListener("completed",i),this.removeEventListener("failure",o),this.removeEventListener("idle",a),t?.signal?.removeEventListener("abort",l),s()}}};const Wd=Math.pow(2,20)*4;class aa extends _e{constructor(t){super();c(this,"status");c(this,"timeline");c(this,"inactivityTimeout");c(this,"maxReadBufferLength");c(this,"maxWriteBufferLength");c(this,"log");c(this,"direction");c(this,"maxMessageSize");c(this,"readStatus");c(this,"writeStatus");c(this,"remoteReadStatus");c(this,"remoteWriteStatus");c(this,"writableNeedsDrain");c(this,"readBuffer");c(this,"writeBuffer");c(this,"sendingData");c(this,"onDrainPromise");this.status="open",this.log=t.log,this.direction=t.direction??"outbound",this.inactivityTimeout=t.inactivityTimeout??12e4,this.maxReadBufferLength=t.maxReadBufferLength??Wd,this.maxWriteBufferLength=t.maxWriteBufferLength,this.maxMessageSize=t.maxMessageSize,this.readBuffer=new ie,this.writeBuffer=new ie,this.readStatus="readable",this.remoteReadStatus="readable",this.writeStatus="writable",this.remoteWriteStatus="writable",this.sendingData=!1,this.writableNeedsDrain=!1,this.timeline={open:Date.now()},this.processSendQueue=this.processSendQueue.bind(this);const n=()=>{this.writableNeedsDrain&&(this.log.trace("drain event received, continue sending data"),this.writableNeedsDrain=!1,this.processSendQueue()),this.onDrainPromise?.resolve()};this.addEventListener("drain",n);const s=i=>{this.onDrainPromise?.reject(i.error??new ia)};this.addEventListener("close",s)}get readBufferLength(){return this.readBuffer.byteLength}get writeBufferLength(){return this.writeBuffer.byteLength}async onDrain(t){return this.writableNeedsDrain!==!0?Promise.resolve():(this.onDrainPromise==null&&(this.onDrainPromise=Promise.withResolvers()),xe(this.onDrainPromise.promise,t?.signal))}async*[Symbol.asyncIterator](){if(this.readStatus!=="readable"&&this.readStatus!=="paused")return;const t=tn(),n=o=>{t.push(o.data)};this.addEventListener("message",n);const s=o=>{t.end(o.error)};this.addEventListener("close",s);const i=()=>{t.end()};this.addEventListener("remoteCloseWrite",i);try{yield*t}finally{this.removeEventListener("message",n),this.removeEventListener("close",s),this.removeEventListener("remoteCloseWrite",i)}}isReadable(){return this.status==="open"}send(t){if(this.writeStatus==="closed"||this.writeStatus==="closing")throw new Tt(`Cannot write to a stream that is ${this.writeStatus}`);return this.log.trace("append %d bytes to write buffer",t.byteLength),this.writeBuffer.append(t),this.processSendQueue()}abort(t){if(!(this.status==="aborted"||this.status==="reset"||this.status==="closed")){this.log.error("abort with error - %e",t),this.status="aborted",this.readBuffer.byteLength>0&&this.readBuffer.consume(this.readBuffer.byteLength),this.writeBuffer.byteLength>0&&(this.writeBuffer.consume(this.writeBuffer.byteLength),this.safeDispatchEvent("idle")),this.writeStatus="closed",this.remoteWriteStatus="closed",this.readStatus="closed",this.remoteReadStatus="closed",this.timeline.close=Date.now();try{this.sendReset(t)}catch(n){this.log("failed to send reset to remote - %e",n)}this.dispatchEvent(new Sc(t))}}pause(){if(this.readStatus==="closed"||this.readStatus==="closing")throw new Tt("Cannot pause a stream that is closing/closed");this.readStatus!=="paused"&&(this.readStatus="paused",this.sendPause())}resume(){if(this.readStatus==="closed"||this.readStatus==="closing")throw new Tt("Cannot resume a stream that is closing/closed");this.readStatus!=="readable"&&(this.readStatus="readable",this.dispatchReadBuffer(),this.sendResume())}push(t){if(this.readStatus==="closed"||this.readStatus==="closing")throw new Tt(`Cannot push data onto a stream that is ${this.readStatus}`);if(t.byteLength!==0){if(this.readBuffer.append(t),this.readStatus==="paused"||this.listenerCount("message")===0){this.checkReadBufferLength();return}setTimeout(()=>{this.dispatchReadBuffer()},0)}}unshift(t){if(this.readStatus==="closed"||this.readStatus==="closing")throw new Tt(`Cannot push data onto a stream that is ${this.readStatus}`);if(t.byteLength!==0){if(this.readBuffer.prepend(t),this.readStatus==="paused"||this.listenerCount("message")===0){this.checkReadBufferLength();return}setTimeout(()=>{this.dispatchReadBuffer()},0)}}onData(t){if(t.byteLength!==0){if(this.readStatus==="closing"||this.readStatus==="closed"){this.log("ignoring data - read status %s",this.readStatus);return}this.readBuffer.append(t),this.dispatchReadBuffer()}}addEventListener(...t){super.addEventListener.apply(this,t),t[0]==="message"&&this.readBuffer.byteLength>0&&queueMicrotask(()=>{this.dispatchReadBuffer()})}onRemoteReset(){this.log("remote reset"),this.status="reset",this.writeStatus="closed",this.remoteWriteStatus="closed",this.remoteReadStatus="closed",this.timeline.close=Date.now(),this.readBuffer.byteLength===0&&(this.readStatus="closed");const t=new _c;this.dispatchEvent(new xc(t))}onTransportClosed(t){this.log("transport closed"),this.readStatus==="readable"&&this.readBuffer.byteLength===0&&(this.log("close readable end after transport closed and read buffer is empty"),this.readStatus="closed"),this.remoteReadStatus!=="closed"&&(this.remoteReadStatus="closed"),this.remoteWriteStatus!=="closed"&&(this.remoteWriteStatus="closed"),this.writeStatus!=="closed"&&(this.writeStatus="closed"),t!=null?this.abort(t):(this.status==="open"||this.status==="closing")&&(this.timeline.close=Date.now(),this.status="closed",this.writeStatus="closed",this.remoteWriteStatus="closed",this.remoteReadStatus="closed",this.dispatchEvent(new Qi))}onRemoteCloseWrite(){this.remoteWriteStatus!=="closed"&&(this.log.trace("on remote close write"),this.remoteWriteStatus="closed",this.safeDispatchEvent("remoteCloseWrite"),this.writeStatus==="closed"&&this.onTransportClosed())}onRemoteCloseRead(){this.log.trace("on remote close read"),this.remoteReadStatus="closed",this.writeBuffer.byteLength>0&&(this.writeBuffer.consume(this.writeBuffer.byteLength),this.safeDispatchEvent("idle"))}processSendQueue(){if(this.writableNeedsDrain)return this.log.trace("not processing send queue as drain is required"),this.checkWriteBufferLength(),!1;if(this.writeBuffer.byteLength===0)return this.log.trace("not processing send queue as no bytes to send"),!0;if(this.sendingData)return this.log.trace("not processing send queue as already sending data"),!0;this.sendingData=!0,this.log.trace("processing send queue with %d queued bytes",this.writeBuffer.byteLength);try{let t=!0;const n=this.writeBuffer.byteLength;let s=0;for(;this.writeBuffer.byteLength>0;){const i=Math.min(this.maxMessageSize??this.writeBuffer.byteLength,this.writeBuffer.byteLength);if(i===0){t=!1;break}const o=this.writeBuffer.sublist(0,i),a=new ie(o);this.writeBuffer.consume(o.byteLength);const l=this.sendData(o);if(t=l.canSendMore,s+=l.sentBytes,l.sentBytes!==a.byteLength&&(a.consume(l.sentBytes),this.writeBuffer.prepend(a)),!t)break}return t||(this.log.trace("sent %d/%d bytes, pausing sending because underlying stream is full, %d bytes left in the write buffer",s,n,this.writeBuffer.byteLength),this.writableNeedsDrain=!0,this.checkWriteBufferLength()),this.writeBuffer.byteLength===0&&this.safeDispatchEvent("idle"),t}finally{this.sendingData=!1}}dispatchReadBuffer(){try{if(this.listenerCount("message")===0){this.log.trace("not dispatching pause buffer as there are no listeners for the message event");return}if(this.readBuffer.byteLength===0){this.log.trace("not dispatching pause buffer as there is no data to dispatch");return}if(this.readStatus==="paused"){this.log.trace("not dispatching pause buffer we are paused");return}if(this.readStatus==="closing"||this.readStatus==="closed"){this.log("dropping %d bytes because the readable end is %s",this.readBuffer.byteLength,this.readStatus),this.readBuffer.consume(this.readBuffer.byteLength);return}const t=this.readBuffer.sublist();this.readBuffer.consume(t.byteLength),this.dispatchEvent(new Cc(t))}finally{this.readBuffer.byteLength===0&&this.remoteWriteStatus==="closed"&&(this.log("close readable end after dispatching read buffer and remote writable end is closed"),this.readStatus="closed"),this.checkReadBufferLength()}}checkReadBufferLength(){this.readBuffer.byteLength>this.maxReadBufferLength&&this.abort(new ks(`Read buffer length of ${this.readBuffer.byteLength} exceeded limit of ${this.maxReadBufferLength}, read status is ${this.readStatus}`))}checkWriteBufferLength(){this.maxWriteBufferLength!=null&&this.writeBuffer.byteLength>this.maxWriteBufferLength&&this.abort(new ks(`Write buffer length of ${this.writeBuffer.byteLength} exceeded limit of ${this.maxWriteBufferLength}, write status is ${this.writeStatus}`))}onMuxerNeedsDrain(){this.writableNeedsDrain=!0}onMuxerDrain(){this.safeDispatchEvent("drain")}}class Tp extends aa{constructor(t){super(t);c(this,"remoteAddr");c(this,"metricPrefix");c(this,"metrics");this.metricPrefix=t.metricPrefix??"",this.metrics=t.metrics,this.remoteAddr=t.remoteAddr,this.addEventListener("close",n=>{this.metrics?.increment({[`${this.metricPrefix}end`]:!0}),n.error!=null?n.local?this.metrics?.increment({[`${this.metricPrefix}abort`]:!0}):this.metrics?.increment({[`${this.metricPrefix}reset`]:!0}):n.local?this.metrics?.increment({[`${this.metricPrefix}_local_close`]:!0}):this.metrics?.increment({[`${this.metricPrefix}_remote_close`]:!0})})}async close(t){this.status==="open"&&(this.status="closing",this.writeStatus="closing",this.remoteWriteStatus="closing",this.remoteReadStatus="closing",(this.sendingData||this.writeBuffer.byteLength>0)&&(this.log("waiting for write queue to become idle before closing writable end of stream, %d unsent bytes",this.writeBuffer.byteLength),await oe(this,"idle",{...t,rejectionEvents:["close"]})),this.writableNeedsDrain&&(this.log("waiting for write queue to drain before closing writable end of stream, %d unsent bytes",this.writeBuffer.byteLength),await oe(this,"drain",{...t,rejectionEvents:["close"]})),await this.sendClose(t),this.onTransportClosed())}}function Kd(r){return r==null?!1:typeof r.then=="function"&&typeof r.catch=="function"&&typeof r.finally=="function"}class Lp extends _e{constructor(t,n){super();c(this,"streams");c(this,"protocol");c(this,"status");c(this,"log");c(this,"maConn");c(this,"streamOptions");c(this,"earlyStreams");c(this,"maxEarlyStreams");c(this,"metrics");this.maConn=t,this.protocol=n.protocol,this.streams=[],this.earlyStreams=[],this.status="open",this.log=t.log.newScope(n.name),this.streamOptions=n.streamOptions,this.maxEarlyStreams=n.maxEarlyStreams??10,this.metrics=n.metrics;const s=a=>{try{this.onData(a.data)}catch(l){this.abort(l),this.maConn.abort(l)}};this.maConn.addEventListener("message",s);const i=()=>{this.log("underlying stream drained, signal %d streams to continue writing",this.streams.length),this.streams.forEach(a=>{a.onMuxerDrain()})};this.maConn.addEventListener("drain",i);const o=()=>{this.log("underlying stream closed with status %s and %d streams",this.status,this.streams.length),this.onTransportClosed()};this.maConn.addEventListener("close",o)}send(t){const n=this.maConn.send(t);return n===!1&&(this.log("underlying stream saturated, signal %d streams to pause writing",this.streams.length),this.streams.forEach(s=>{s.onMuxerNeedsDrain()})),n}async close(t){this.status==="closed"||this.status==="closing"||(this.status="closing",await xe(Promise.all([...this.streams].map(async n=>{await n.close(t)})),t?.signal),this.status="closed")}abort(t){this.status!=="closed"&&(this.status="closing",[...this.streams].forEach(n=>{n.abort(t)}),this.status="closed")}onTransportClosed(t){this.status="closing";try{[...this.streams].forEach(n=>{n.onTransportClosed(t)})}catch(n){this.abort(n)}this.status="closed"}async createStream(t){if(this.status!=="open")throw new Ac;let n=this.onCreateStream({...this.streamOptions,...t});return Kd(n)&&(n=await n),this.streams.push(n),this.cleanUpStream(n),n}onRemoteStream(t){if(this.streams.push(t),this.cleanUpStream(t),this.listenerCount("stream")===0){this.earlyStreams.push(t),this.earlyStreams.length>this.maxEarlyStreams&&this.abort(new sa(`Too many early streams were opened - ${this.earlyStreams.length}/${this.maxEarlyStreams}`));return}this.safeDispatchEvent("stream",{detail:t})}cleanUpStream(t){const n=s=>{const i=this.streams.findIndex(o=>o===t);i!==-1&&this.streams.splice(i,1),s.error!=null?s.local?this.metrics?.increment({[`${t.direction}_stream_reset`]:!0}):this.metrics?.increment({[`${t.direction}_stream_abort`]:!0}):this.metrics?.increment({[`${t.direction}_stream_end`]:!0})};t.addEventListener("close",n),this.metrics?.increment({[`${t.direction}_stream`]:!0})}addEventListener(...t){super.addEventListener.apply(this,t),t[0]==="stream"&&this.earlyStreams.length>0&&queueMicrotask(()=>{this.earlyStreams.forEach(n=>{this.safeDispatchEvent("stream",{detail:n})}),this.earlyStreams=[]})}}class Pp extends aa{constructor(t){super(t);c(this,"id");c(this,"protocol");this.id=t.id,this.protocol=t.protocol??""}async close(t){this.writeStatus==="closing"||this.writeStatus==="closed"||(this.writeStatus="closing",(this.sendingData||this.writeBuffer.byteLength>0)&&(this.log("waiting for write queue to become idle before closing writable end of stream, %d unsent bytes",this.writeBuffer.byteLength),await oe(this,"idle",{...t,rejectionEvents:["close"]})),this.writableNeedsDrain&&(this.log("waiting for write queue to drain before closing writable end of stream, %d unsent bytes, sending %s",this.writeBuffer.byteLength,this.sendingData),await oe(this,"drain",{...t,rejectionEvents:["close"]}),this.log("write queue drained, closing writable end of stream, %d unsent bytes, sending %s",this.writeBuffer.byteLength,this.sendingData)),await this.sendCloseWrite(t),this.writeStatus="closed",this.log("closed writable end gracefully"),this.remoteWriteStatus==="closed"&&this.onTransportClosed())}async closeRead(t){this.readStatus==="closing"||this.readStatus==="closed"||(this.readBuffer.byteLength>0&&this.readBuffer.consume(this.readBuffer.byteLength),this.readStatus="closing",await this.sendCloseRead(t),this.readStatus="closed",this.log("closed readable end gracefully"))}}class dr{constructor(e){c(this,"movingAverage");c(this,"variance");c(this,"deviation");c(this,"forecast");c(this,"timeSpan");c(this,"previousTime");this.timeSpan=e,this.movingAverage=0,this.variance=0,this.deviation=0,this.forecast=0}alpha(e,t){return 1-Math.exp(-(e-t)/this.timeSpan)}push(e,t=Date.now()){if(this.previousTime!=null){const n=this.alpha(t,this.previousTime),s=e-this.movingAverage,i=n*s;this.movingAverage=n*e+(1-n)*this.movingAverage,this.variance=(1-n)*(this.variance+s*i),this.deviation=Math.sqrt(this.variance),this.forecast=this.movingAverage+n*s}else this.movingAverage=e;this.previousTime=t}}const Gd=1.2,Qd=2,jd=5e3,Hd=6e4,Xd=5e3;class Yd{constructor(e={}){c(this,"success");c(this,"failure");c(this,"next");c(this,"metric");c(this,"timeoutMultiplier");c(this,"failureMultiplier");c(this,"minTimeout");c(this,"maxTimeout");const t=e.interval??Xd;this.success=new dr(t),this.failure=new dr(t),this.next=new dr(t),this.failureMultiplier=e.failureMultiplier??Qd,this.timeoutMultiplier=e.timeoutMultiplier??Gd,this.minTimeout=e.minTimeout??jd,this.maxTimeout=e.maxTimeout??Hd,e.metricName!=null&&(this.metric=e.metrics?.registerMetricGroup(e.metricName))}getTimeoutSignal(e={}){let t=Math.round(this.next.movingAverage*(e.timeoutFactor??this.timeoutMultiplier));t<this.minTimeout&&(t=this.minTimeout),t>this.maxTimeout&&(t=this.maxTimeout);const n=AbortSignal.timeout(t),s=wt([e.signal,n]);return s.start=Date.now(),s.timeout=t,s}cleanUp(e){const t=Date.now()-e.start;e.aborted?(this.failure.push(t),this.next.push(t*this.failureMultiplier),this.metric?.update({failureMovingAverage:this.failure.movingAverage,failureDeviation:this.failure.deviation,failureForecast:this.failure.forecast,failureVariance:this.failure.variance,failure:t})):(this.success.push(t),this.next.push(t),this.metric?.update({successMovingAverage:this.success.movingAverage,successDeviation:this.success.deviation,successForecast:this.success.forecast,successVariance:this.success.variance,success:t}))}}class Jd{constructor(){c(this,"readNext");c(this,"haveNext");c(this,"ended");c(this,"nextResult");c(this,"error");this.ended=!1,this.readNext=se(),this.haveNext=se()}[Symbol.asyncIterator](){return this}async next(){if(this.nextResult==null&&await this.haveNext.promise,this.nextResult==null)throw new Error("HaveNext promise resolved but nextResult was undefined");const e=this.nextResult;return this.nextResult=void 0,this.readNext.resolve(),this.readNext=se(),e}async throw(e){return this.ended=!0,this.error=e,e!=null&&(this.haveNext.promise.catch(()=>{}),this.haveNext.reject(e)),{done:!0,value:void 0}}async return(){const e={done:!0,value:void 0};return this.ended=!0,this.nextResult=e,this.haveNext.resolve(),e}async push(e,t){await this._push(e,t)}async end(e,t){e!=null?await this.throw(e):await this._push(void 0,t)}async _push(e,t){if(e!=null&&this.ended)throw this.error??new Error("Cannot push value onto an ended pushable");for(;this.nextResult!=null;)await this.readNext.promise;e!=null?this.nextResult={done:!1,value:e}:(this.ended=!0,this.nextResult={done:!0,value:void 0}),this.haveNext.resolve(),this.haveNext=se(),await xe(this.readNext.promise,t?.signal,t)}}function Zd(){return new Jd}function eh(r){return r[Symbol.asyncIterator]!=null}async function th(r,e,t){try{await Promise.all(r.map(async n=>{for await(const s of n)await e.push(s,{signal:t}),t.throwIfAborted()})),await e.end(void 0,{signal:t})}catch(n){await e.end(n,{signal:t}).catch(()=>{})}}async function*nh(r){const e=new AbortController,t=Zd();th(r,t,e.signal).catch(()=>{});try{yield*t}finally{e.abort()}}function*rh(r){for(const e of r)yield*e}function Fn(...r){const e=[];for(const t of r)eh(t)||e.push(t);return e.length===r.length?rh(e):nh(r)}function sh(r,...e){if(r==null)throw new Error("Empty pipeline");if(hr(r)){const n=r;r=()=>n.source}else if(la(r)||ca(r)){const n=r;r=()=>n}const t=[r,...e];if(t.length>1&&hr(t[t.length-1])&&(t[t.length-1]=t[t.length-1].sink),t.length>2)for(let n=1;n<t.length-1;n++)hr(t[n])&&(t[n]=oh(t[n]));return ih(...t)}const ih=(...r)=>{let e;for(;r.length>0;)e=r.shift()(e);return e},ca=r=>r?.[Symbol.asyncIterator]!=null,la=r=>r?.[Symbol.iterator]!=null,hr=r=>r==null?!1:r.sink!=null&&r.source!=null,oh=r=>e=>{const t=r.sink(e);if(t?.then!=null){const n=tn({objectMode:!0});t.then(()=>{n.end()},o=>{n.end(o)});let s;const i=r.source;if(ca(i))s=async function*(){yield*i,n.end()};else if(la(i))s=function*(){yield*i,n.end()};else throw new Error("Unknown duplex source type - must be Iterable or AsyncIterable");return Fn(n,s())}return r.source},ah=4194304;class Br extends Error{constructor(){super(...arguments);c(this,"name","UnwrappedError")}}c(Br,"name","UnwrappedError");let ua=class extends Error{constructor(){super(...arguments);c(this,"name","InvalidMessageLengthError");c(this,"code","ERR_INVALID_MSG_LENGTH")}},ch=class extends Error{constructor(){super(...arguments);c(this,"name","InvalidDataLengthError");c(this,"code","ERR_MSG_DATA_TOO_LONG")}},lh=class extends Error{constructor(){super(...arguments);c(this,"name","InvalidDataLengthLengthError");c(this,"code","ERR_MSG_LENGTH_TOO_LONG")}};function uh(r){return typeof r?.closeRead=="function"}function dh(r){return typeof r?.close=="function"}function fr(r){return uh(r)?r.remoteWriteStatus!=="writable"&&r.readBufferLength===0:dh(r)?r.status!=="open":!1}function hh(r){return r?.addEventListener!=null&&r?.removeEventListener!=null&&r?.send!=null&&r?.push!=null&&r?.log!=null}function da(r,e){const t=e?.maxBufferSize??ah,n=new ie;let s,i=!1;if(!hh(r))throw new N("Argument should be a Stream or a Multiaddr");const o=d=>{if(n.append(d.data),n.byteLength>t){const h=n.byteLength;n.consume(n.byteLength),s?.reject(new Error(`Read buffer overflow - ${h} > ${t}`))}s?.resolve()};r.addEventListener("message",o);const a=d=>{d.error!=null?s?.reject(d.error):s?.resolve()};r.addEventListener("close",a);const l=()=>{s?.resolve()};r.addEventListener("remoteCloseWrite",l);const u={readBuffer:n,async read(d){if(i===!0)throw new Br("Stream was unwrapped");if(fr(r)){if(d?.bytes==null)return null;if(n.byteLength<d.bytes)throw r.log.error("closed after reading %d/%d bytes",n.byteLength,d.bytes),new Nn(`Unexpected EOF - stream closed after reading ${n.byteLength}/${d.bytes} bytes`)}const h=d?.bytes??1;for(s=Promise.withResolvers();;){if(n.byteLength>=h){s.resolve();break}if(await xe(s.promise,d?.signal),fr(r)){if(n.byteLength===0&&d?.bytes==null)return null;break}s=Promise.withResolvers()}const f=d?.bytes??n.byteLength;if(n.byteLength<f){if(fr(r))throw r.log.error("closed while reading %d/%d bytes",n.byteLength,f),new Nn(`Unexpected EOF - stream closed while reading ${n.byteLength}/${f} bytes`);return u.read(d)}const p=n.sublist(0,f);return n.consume(f),p},async write(d,h){if(i===!0)throw new Br("Stream was unwrapped");r.send(d)||await oe(r,"drain",{signal:h?.signal,rejectionEvents:["close"]})},unwrap(){return i||(i=!0,r.removeEventListener("message",o),r.removeEventListener("close",a),r.removeEventListener("remoteCloseWrite",l),n.byteLength>0&&(r.log("stream unwrapped with %d unread bytes",n.byteLength),r.push(n))),r}};return u}function Es(r,e={}){const t=da(r,e);e.maxDataLength!=null&&e.maxLengthLength==null&&(e.maxLengthLength=De(e.maxDataLength));const n=e?.lengthDecoder??Yt,s=e?.lengthEncoder??Mt;return{async read(o){let a=-1;const l=new ie;for(;;){const d=await t.read({...o,bytes:1});if(d==null)break;l.append(d);try{a=n(l)}catch(h){if(h instanceof RangeError)continue;throw h}if(a<0)throw new ua("Invalid message length");if(e?.maxLengthLength!=null&&l.byteLength>e.maxLengthLength)throw new lh(`Message length length too long - ${l.byteLength} > ${e.maxLengthLength}`);if(a>-1)break}if(e?.maxDataLength!=null&&a>e.maxDataLength)throw new ch(`Message length too long - ${a} > ${e.maxDataLength}`);const u=await t.read({...o,bytes:a});if(u==null)throw r.log.error("tried to read %d bytes but the stream closed",a),new Nn(`Unexpected EOF - tried to read ${a} bytes but the stream closed`);if(u.byteLength!==a)throw r.log.error("read %d/%d bytes before the stream closed",u.byteLength,a),new Nn(`Unexpected EOF - read ${u.byteLength}/${a} bytes before the stream closed`);return u},async write(o,a){await t.write(new ie(s(o.byteLength),o),a)},async writeV(o,a){const l=new ie(...o.flatMap(u=>[s(u.byteLength),u]));await t.write(l,a)},unwrap(){return t.unwrap()}}}function Np(r,e){const t=Es(r,e),n={read:async(s,i)=>{const o=await t.read(i);return s.decode(o)},write:async(s,i,o)=>{await t.write(i.encode(s),o)},writeV:async(s,i,o)=>{await t.writeV(s.map(a=>i.encode(a)),o)},pb:s=>({read:async i=>n.read(s,i),write:async(i,o)=>n.write(i,s,o),writeV:async(i,o)=>n.writeV(i,s,o),unwrap:()=>n}),unwrap:()=>t.unwrap()};return n}function fh(r){return r?.addEventListener!=null}function mh(r){const e=tn();let t;const n=o=>{e.push(o.data)},s=()=>{e.end(),r.removeEventListener("message",n),r.removeEventListener("close",i),r.removeEventListener("remoteCloseWrite",s)},i=o=>{e.end(o.error),o.error!=null&&t?.reject(o.error),r.removeEventListener("message",n),r.removeEventListener("close",i),r.removeEventListener("remoteCloseWrite",s)};return r.addEventListener("message",n),r.addEventListener("close",i,{once:!0}),r.addEventListener("remoteCloseWrite",s,{once:!0}),{source:e,async sink(o){async function*a(){yield*o}const l=a();for(;;){t=Promise.withResolvers();const{done:u,value:d}=await Promise.race([l.next(),t.promise]);if(r.writeStatus==="closing"||r.writeStatus==="closed"||(d!=null&&(r.send(d)||await Promise.race([oe(r,"drain",{rejectionEvents:["close"]})])),u===!0))break}await r.close()}}}function Fp(...r){const e=r.map(t=>fh(t)?mh(t):t);return sh(...e)}const ph=1024*1024*4,gh=1024*1024*4;class Rp{constructor(e={}){c(this,"buffer");c(this,"maxBufferSize");c(this,"lengthDecoder");c(this,"maxDataLength");c(this,"encodingLength");this.buffer=new ie,this.maxBufferSize=e.maxBufferSize??ph,this.maxDataLength=e.maxDataLength??gh,this.lengthDecoder=e.lengthDecoder??Yt,this.encodingLength=e.encodingLength??De}*decode(e){if(this.buffer.append(e),this.buffer.byteLength>this.maxBufferSize)throw new N(`Buffer length limit exceeded - ${this.buffer.byteLength}/${this.maxBufferSize}`);for(;;){let t;try{t=this.lengthDecoder(this.buffer)}catch(i){if(i instanceof RangeError)break;throw i}if(t<0||t>this.maxDataLength)throw new ua("Invalid message length");const n=this.encodingLength(t),s=n+t;if(this.buffer.byteLength>=s){const i=this.buffer.sublist(n,s);this.buffer.consume(s),i.byteLength>0&&(yield i)}else break}}}const yh=8,Ss=1024*1024*4;class wh extends Error{constructor(){super(...arguments);c(this,"name","InvalidMessageLengthError");c(this,"code","ERR_INVALID_MSG_LENGTH")}}class ha extends Error{constructor(){super(...arguments);c(this,"name","InvalidDataLengthError");c(this,"code","ERR_MSG_DATA_TOO_LONG")}}class bh extends Error{constructor(){super(...arguments);c(this,"name","InvalidDataLengthLengthError");c(this,"code","ERR_MSG_LENGTH_TOO_LONG")}}class Xs extends Error{constructor(){super(...arguments);c(this,"name","UnexpectedEOFError");c(this,"code","ERR_UNEXPECTED_EOF")}}function fa(r){return r[Symbol.asyncIterator]!=null}function ma(r,e){if(r.byteLength>e)throw new ha("Message length too long")}const Zn=r=>{const e=De(r),t=Ic(e);return Mt(r,t),Zn.bytes=e,t};Zn.bytes=0;function pa(r,e){e=e??{};const t=e.lengthEncoder??Zn,n=e?.maxDataLength??Ss;function*s(i){ma(i,n);const o=t(i.byteLength);o instanceof Uint8Array?yield o:yield*o,i instanceof Uint8Array?yield i:yield*i}return fa(r)?async function*(){for await(const i of r)yield*s(i)}():function*(){for(const i of r)yield*s(i)}()}pa.single=(r,e)=>{e=e??{};const t=e.lengthEncoder??Zn,n=e?.maxDataLength??Ss;return ma(r,n),new ie(t(r.byteLength),r)};var Oe;(function(r){r[r.LENGTH=0]="LENGTH",r[r.DATA=1]="DATA"})(Oe||(Oe={}));const _s=r=>{const e=Yt(r);return _s.bytes=De(e),e};_s.bytes=0;function Ys(r,e){const t=new ie;let n=Oe.LENGTH,s=-1;const i=e?.lengthDecoder??_s,o=e?.maxLengthLength??yh,a=e?.maxDataLength??Ss;function*l(){for(;t.byteLength>0;){if(n===Oe.LENGTH)try{if(s=i(t),s<0)throw new wh("Invalid message length");if(s>a)throw new ha("Message length too long");const u=i.bytes;t.consume(u),e?.onLength!=null&&e.onLength(s),n=Oe.DATA}catch(u){if(u instanceof RangeError){if(t.byteLength>o)throw new bh("Message length length too long");break}throw u}if(n===Oe.DATA){if(t.byteLength<s)break;const u=t.sublist(0,s);t.consume(s),e?.onData!=null&&e.onData(u),yield u,n=Oe.LENGTH}}}return fa(r)?async function*(){for await(const u of r)t.append(u),yield*l();if(t.byteLength>0)throw new Xs("Unexpected end of input")}():function*(){for(const u of r)t.append(u),yield*l();if(t.byteLength>0)throw new Xs("Unexpected end of input")}()}Ys.fromReader=(r,e)=>{let t=1;const n=async function*(){for(;;)try{const{done:i,value:o}=await r.next(t);if(i===!0)return;o!=null&&(yield o)}catch(i){if(i.code==="ERR_UNDER_READ")return{done:!0,value:null};throw i}finally{t=1}}();return Ys(n,{...e??{},onLength:i=>{t=i}})};const Js=2147483647,ga=Symbol.for("sindresorhus/unlimited-timeout#brand");function vh(r,e,...t){if(typeof r!="function")throw new TypeError("Expected callback to be a function");e??(e=0),e=Number(e);let n=!1;const s={[ga]:!0,id:void 0,cleared:!1,ref(){return n=!1,s.id?.ref?.(),s},unref(){return n=!0,s.id?.unref?.(),s}};if(e===Number.POSITIVE_INFINITY||e>Number.MAX_SAFE_INTEGER)return s;(!Number.isFinite(e)||e<0)&&(e=0);const i=performance.now()+e,o=a=>{s.cleared||(a<=Js?(s.id=globalThis.setTimeout(()=>{s.cleared||r(...t)},a),n&&s.id?.unref?.()):(s.id=globalThis.setTimeout(()=>{const l=performance.now(),u=Math.max(0,i-l);o(u)},Js),n&&s.id?.unref?.()))};return o(e),s}function Eh(r){!r||typeof r!="object"||!r[ga]||(r.cleared=!0,r.id!==void 0&&(globalThis.clearTimeout(r.id),r.id=void 0))}const Sh=new WeakMap;function _h({clearTimeout:r,setTimeout:e}={}){return(t,{value:n,signal:s}={})=>{if(s?.aborted)return Promise.reject(s.reason);let i,o,a;const l=r??clearTimeout,u=()=>{l(i),a(s.reason)},d=()=>{s&&s.removeEventListener("abort",u)},h=new Promise((f,p)=>{o=()=>{d(),f(n)},a=p,i=(e??setTimeout)(o,t)});return s&&s.addEventListener("abort",u,{once:!0}),Sh.set(h,()=>{l(i),i=null,o()}),h}}const $p=_h({setTimeout:vh,clearTimeout:Eh});class xh extends oa{has(e){return this.find(e)!=null}find(e){return this.queue.find(t=>e.equals(t.options.peerId))}}class Ch extends oa{constructor(e={}){super({...e,sort:(t,n)=>t.options.priority>n.options.priority?-1:t.options.priority<n.options.priority?1:0})}}class Ah{constructor(e={}){c(this,"memoryStorage");c(this,"points");c(this,"duration");c(this,"blockDuration");c(this,"keyPrefix");this.points=e.points??4,this.duration=e.duration??1,this.blockDuration=e.blockDuration??0,this.keyPrefix=e.keyPrefix??"rlflx",this.memoryStorage=new Ih}consume(e,t=1,n={}){const s=this.getKey(e),i=this._getKeySecDuration(n);let o=this.memoryStorage.incrby(s,t,i);if(o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o.consumedPoints>this.points)throw this.blockDuration>0&&o.consumedPoints<=this.points+t&&(o=this.memoryStorage.set(s,o.consumedPoints,this.blockDuration)),new Od("Rate limit exceeded",o);return o}penalty(e,t=1,n={}){const s=this.getKey(e),i=this._getKeySecDuration(n),o=this.memoryStorage.incrby(s,t,i);return o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o}reward(e,t=1,n={}){const s=this.getKey(e),i=this._getKeySecDuration(n),o=this.memoryStorage.incrby(s,-t,i);return o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o}block(e,t){const n=t*1e3,s=this.points+1;return this.memoryStorage.set(this.getKey(e),s,t),{remainingPoints:0,msBeforeNext:n===0?-1:n,consumedPoints:s,isFirstInDuration:!1}}set(e,t,n=0){const s=(n>=0?n:this.duration)*1e3;return this.memoryStorage.set(this.getKey(e),t,n),{remainingPoints:0,msBeforeNext:s===0?-1:s,consumedPoints:t,isFirstInDuration:!1}}get(e){const t=this.memoryStorage.get(this.getKey(e));return t!=null&&(t.remainingPoints=Math.max(this.points-t.consumedPoints,0)),t}delete(e){this.memoryStorage.delete(this.getKey(e))}_getKeySecDuration(e){return e?.customDuration!=null&&e.customDuration>=0?e.customDuration:this.duration}getKey(e){return this.keyPrefix.length>0?`${this.keyPrefix}:${e}`:e}parseKey(e){return e.substring(this.keyPrefix.length)}}class Ih{constructor(){c(this,"storage");this.storage=new Map}incrby(e,t,n){const s=this.storage.get(e);if(s!=null){const i=s.expiresAt!=null?s.expiresAt.getTime()-new Date().getTime():-1;return s.expiresAt==null||i>0?(s.value+=t,{remainingPoints:0,msBeforeNext:i,consumedPoints:s.value,isFirstInDuration:!1}):this.set(e,t,n)}return this.set(e,t,n)}set(e,t,n){const s=n*1e3,i=this.storage.get(e);i!=null&&clearTimeout(i.timeoutId);const o={value:t,expiresAt:s>0?new Date(Date.now()+s):void 0};return this.storage.set(e,o),s>0&&(o.timeoutId=setTimeout(()=>{this.storage.delete(e)},s),o.timeoutId.unref!=null&&o.timeoutId.unref()),{remainingPoints:0,msBeforeNext:s===0?-1:s,consumedPoints:o.value,isFirstInDuration:!0}}get(e){const t=this.storage.get(e);if(t!=null)return{remainingPoints:0,msBeforeNext:t.expiresAt!=null?t.expiresAt.getTime()-new Date().getTime():-1,consumedPoints:t.value,isFirstInDuration:!1}}delete(e){const t=this.storage.get(e);return t!=null?(t.timeoutId!=null&&clearTimeout(t.timeoutId),this.storage.delete(e),!0):!1}}function Op(r,e,t){let n,s,i=!1;function o(){const u={signal:s.signal};if(t?.timeout!=null){const d=wt([s.signal,AbortSignal.timeout(t.timeout)]);u.signal=d}i=!0,Promise.resolve().then(async()=>{await r(u)}).catch(()=>{}).finally(()=>{i=!1,!s.signal.aborted&&(n=setTimeout(o,e))})}const a=Mn(o,t?.debounce??100);let l=!1;return{setInterval:u=>{e!==u&&(e=u,n!=null&&(clearTimeout(n),n=setTimeout(o,e)))},setTimeout:u=>{t??(t={}),t.timeout=u},run:()=>{i||(clearTimeout(n),a())},start:()=>{l||(l=!0,s=new AbortController,pe(1/0,s.signal),t?.runImmediately===!0?queueMicrotask(()=>{o()}):n=setTimeout(o,e))},stop:()=>{clearTimeout(n),s?.abort(),l=!1}}}class Th extends Map{constructor(t){super();c(this,"metric");const{name:n,metrics:s}=t;this.metric=s.registerMetric(n),this.updateComponentMetric()}set(t,n){return super.set(t,n),this.updateComponentMetric(),this}delete(t){const n=super.delete(t);return this.updateComponentMetric(),n}clear(){super.clear(),this.updateComponentMetric()}updateComponentMetric(){this.metric.update(this.size)}}function Ce(r){const{name:e,metrics:t}=r;let n;return t!=null?n=new Th({name:e,metrics:t}):n=new Map,n}class Lh{constructor(e,t){c(this,"filter");this.filter=ws(e,t)}has(e){return this.filter.has(e.toMultihash().bytes)}add(e){this.filter.add(e.toMultihash().bytes)}remove(e){this.filter.remove?.(e.toMultihash().bytes)}}function Bp(r,e=.001){return new Lh(r,e)}class Ph extends en{constructor(t){super();c(this,"metric");const{name:n,metrics:s}=t;this.metric=s.registerMetric(n),this.updateComponentMetric()}set(t,n){return super.set(t,n),this.updateComponentMetric(),this}delete(t){const n=super.delete(t);return this.updateComponentMetric(),n}clear(){super.clear(),this.updateComponentMetric()}updateComponentMetric(){this.metric.update(this.size)}}function kh(r){const{name:e,metrics:t}=r;let n;return t!=null?n=new Ph({name:e,metrics:t}):n=new en,n}var Rn;(function(r){let e;r.codec=()=>(e==null&&(e=Le((t,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),t.publicKey!=null&&t.publicKey.byteLength>0&&(n.uint32(10),n.bytes(t.publicKey)),t.payloadType!=null&&t.payloadType.byteLength>0&&(n.uint32(18),n.bytes(t.payloadType)),t.payload!=null&&t.payload.byteLength>0&&(n.uint32(26),n.bytes(t.payload)),t.signature!=null&&t.signature.byteLength>0&&(n.uint32(42),n.bytes(t.signature)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={publicKey:Ee(0),payloadType:Ee(0),payload:Ee(0),signature:Ee(0)},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.publicKey=t.bytes();break}case 2:{i.payloadType=t.bytes();break}case 3:{i.payload=t.bytes();break}case 5:{i.signature=t.bytes();break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>Pe(t,r.codec()),r.decode=(t,n)=>ke(t,r.codec(),n)})(Rn||(Rn={}));class Dh extends Error{constructor(e="Invalid signature"){super(e),this.name="InvalidSignatureError"}}const Ie=class Ie{constructor(e){c(this,"publicKey");c(this,"payloadType");c(this,"payload");c(this,"signature");c(this,"marshaled");const{publicKey:t,payloadType:n,payload:s,signature:i}=e;this.publicKey=t,this.payloadType=n,this.payload=s,this.signature=i}marshal(){return this.marshaled==null&&(this.marshaled=Rn.encode({publicKey:fn(this.publicKey),payloadType:this.payloadType,payload:this.payload.subarray(),signature:this.signature})),this.marshaled}equals(e){return e==null?!1:Se(this.marshal(),e.marshal())}async validate(e,t){const n=Zs(e,this.payloadType,this.payload);return this.publicKey.verify(n.subarray(),this.signature,t)}};c(Ie,"createFromProtobuf",e=>{const t=Rn.decode(e),n=Jr(t.publicKey);return new Ie({publicKey:n,payloadType:t.payloadType,payload:t.payload,signature:t.signature})}),c(Ie,"seal",async(e,t,n)=>{if(t==null)throw new Error("Missing private key");const s=e.domain,i=e.codec,o=e.marshal(),a=Zs(s,i,o),l=await t.sign(a.subarray(),n);return new Ie({publicKey:t.publicKey,payloadType:i,payload:o,signature:l})}),c(Ie,"openAndCertify",async(e,t,n)=>{const s=Ie.createFromProtobuf(e);if(!await s.validate(t,n))throw new Dh("Envelope signature is not valid for the given domain");return s});let $n=Ie;const Zs=(r,e,t)=>{const n=F(r),s=Mt(n.byteLength),i=Mt(e.length),o=Mt(t.length);return new ie(s,n,i,e,o,t)},Mh="libp2p-peer-record",Nh=Uint8Array.from([3,1]);var On;(function(r){(function(t){let n;t.codec=()=>(n==null&&(n=Le((s,i,o={})=>{o.lengthDelimited!==!1&&i.fork(),s.multiaddr!=null&&s.multiaddr.byteLength>0&&(i.uint32(10),i.bytes(s.multiaddr)),o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{const a={multiaddr:Ee(0)},l=i==null?s.len:s.pos+i;for(;s.pos<l;){const u=s.uint32();switch(u>>>3){case 1:{a.multiaddr=s.bytes();break}default:{s.skipType(u&7);break}}}return a})),n),t.encode=s=>Pe(s,t.codec()),t.decode=(s,i)=>ke(s,t.codec(),i)})(r.AddressInfo||(r.AddressInfo={}));let e;r.codec=()=>(e==null&&(e=Le((t,n,s={})=>{if(s.lengthDelimited!==!1&&n.fork(),t.peerId!=null&&t.peerId.byteLength>0&&(n.uint32(10),n.bytes(t.peerId)),t.seq!=null&&t.seq!==0n&&(n.uint32(16),n.uint64(t.seq)),t.addresses!=null)for(const i of t.addresses)n.uint32(26),r.AddressInfo.codec().encode(i,n);s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={peerId:Ee(0),seq:0n,addresses:[]},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.peerId=t.bytes();break}case 2:{i.seq=t.uint64();break}case 3:{if(s.limits?.addresses!=null&&i.addresses.length===s.limits.addresses)throw new Ar('Decode error - map field "addresses" had too many elements');i.addresses.push(r.AddressInfo.codec().decode(t,t.uint32(),{limits:s.limits?.addresses$}));break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>Pe(t,r.codec()),r.decode=(t,n)=>ke(t,r.codec(),n)})(On||(On={}));function Fh(r,e){const t=(n,s)=>n.toString().localeCompare(s.toString());return r.length!==e.length?!1:(e.sort(t),r.sort(t).every((n,s)=>e[s].equals(n)))}const we=class we{constructor(e){c(this,"peerId");c(this,"multiaddrs");c(this,"seqNumber");c(this,"domain",we.DOMAIN);c(this,"codec",we.CODEC);c(this,"marshaled");const{peerId:t,multiaddrs:n,seqNumber:s}=e;this.peerId=t,this.multiaddrs=n??[],this.seqNumber=s??BigInt(Date.now())}marshal(){return this.marshaled==null&&(this.marshaled=On.encode({peerId:this.peerId.toMultihash().bytes,seq:BigInt(this.seqNumber),addresses:this.multiaddrs.map(e=>({multiaddr:e.bytes}))})),this.marshaled}equals(e){return!(!(e instanceof we)||!this.peerId.equals(e.peerId)||this.seqNumber!==e.seqNumber||!Fh(this.multiaddrs,e.multiaddrs))}};c(we,"createFromProtobuf",e=>{const t=On.decode(e),n=jn(Xr(t.peerId)),s=(t.addresses??[]).map(o=>z(o.multiaddr)),i=t.seq;return new we({peerId:n,multiaddrs:s,seqNumber:i})}),c(we,"DOMAIN",Mh),c(we,"CODEC",Nh);let $t=we;function Rh(r){return r[Symbol.asyncIterator]!=null}function Ur(r){if(Rh(r))return(async()=>{const t=[];for await(const n of r)t.push(n);return t})();const e=[];for(const t of r)e.push(t);return e}var Cr;let _t=(Cr=class extends Error{constructor(t="The operation was aborted",...n){super(t,...n);c(this,"name","AbortError")}},c(Cr,"name","AbortError"),Cr);async function mr(r,e,t,n){const s=new _t(n?.errorMessage);n?.errorCode!=null&&(s.code=n.errorCode);const i=n?.errorEvent??"error";return t?.aborted===!0?Promise.reject(s):new Promise((o,a)=>{function l(){gr(t,"abort",h),gr(r,e,u),gr(r,i,d)}const u=f=>{try{if(n?.filter?.(f)===!1)return}catch(p){l(),a(p);return}l(),o(f)},d=f=>{if(l(),f instanceof Error){a(f);return}a(f.detail??n?.error??new Error(`The "${n?.errorEvent}" event was emitted but the event had no '.detail' field. Pass an 'error' option to race-event to change this message.`))},h=()=>{l(),a(s)};pr(t,"abort",h),pr(r,e,u),pr(r,i,d)})}function pr(r,e,t){r!=null&&(ya(r)?r.addEventListener(e,t):r.addListener(e,t))}function gr(r,e,t){r!=null&&(ya(r)?r.removeEventListener(e,t):r.removeListener(e,t))}function ya(r){return typeof r.addEventListener=="function"&&typeof r.removeEventListener=="function"}class wa extends Error{constructor(e="The queue was full"){super(e),this.name="QueueFullError"}}c(wa,"name","QueueFullError");class $h{constructor(e){c(this,"deferred");c(this,"signal");this.signal=e,this.deferred=Promise.withResolvers(),this.onAbort=this.onAbort.bind(this),this.signal?.addEventListener("abort",this.onAbort)}onAbort(){this.deferred.reject(this.signal?.reason??new _t)}cleanup(){this.signal?.removeEventListener("abort",this.onAbort)}}function Oh(){return`${parseInt(String(Math.random()*1e9),10).toString()}${Date.now()}`}class Bh{constructor(e,t){c(this,"id");c(this,"fn");c(this,"options");c(this,"recipients");c(this,"status");c(this,"timeline");c(this,"controller");this.id=Oh(),this.status="queued",this.fn=e,this.options=t,this.recipients=[],this.timeline={created:Date.now()},this.controller=new AbortController,pe(1/0,this.controller.signal),this.onAbort=this.onAbort.bind(this)}abort(e){this.controller.abort(e)}onAbort(){this.recipients.reduce((t,n)=>t&&n.signal?.aborted===!0,!0)&&(this.controller.abort(new _t),this.cleanup())}async join(e={}){const t=new $h(e.signal);return this.recipients.push(t),e.signal?.addEventListener("abort",this.onAbort),t.deferred.promise}async run(){this.status="running",this.timeline.started=Date.now();try{this.controller.signal.throwIfAborted();const e=await xe(this.fn({...this.options??{},signal:this.controller.signal}),this.controller.signal);this.recipients.forEach(t=>{t.deferred.resolve(e)}),this.status="complete"}catch(e){this.recipients.forEach(t=>{t.deferred.reject(e)}),this.status="errored"}finally{this.timeline.finished=Date.now(),this.cleanup()}}cleanup(){this.recipients.forEach(e=>{e.cleanup(),e.signal?.removeEventListener("abort",this.onAbort)})}}function ei(r,e){let t;const n=function(){const s=function(){t=void 0,r()};clearTimeout(t),t=setTimeout(s,e)};return n.start=()=>{},n.stop=()=>{clearTimeout(t)},n}class ti extends _e{constructor(t={}){super();c(this,"concurrency");c(this,"maxSize");c(this,"queue");c(this,"pending");c(this,"sort");c(this,"autoStart");this.concurrency=t.concurrency??Number.POSITIVE_INFINITY,this.maxSize=t.maxSize??Number.POSITIVE_INFINITY,this.pending=0,this.autoStart=t.autoStart??!0,this.sort=t.sort,this.queue=[],this.emitEmpty=ei(this.emitEmpty.bind(this),1),this.emitIdle=ei(this.emitIdle.bind(this),1)}[Symbol.asyncIterator](){return this.toGenerator()}emitEmpty(){this.size===0&&this.safeDispatchEvent("empty")}emitIdle(){this.running===0&&this.safeDispatchEvent("idle")}tryToStartAnother(){if(this.size===0)return this.emitEmpty(),this.running===0&&this.emitIdle(),!1;if(this.pending<this.concurrency){let t;for(const n of this.queue)if(n.status==="queued"){t=n;break}return t==null?!1:(this.safeDispatchEvent("active"),this.pending++,t.run().finally(()=>{for(let n=0;n<this.queue.length;n++)if(this.queue[n]===t){this.queue.splice(n,1);break}this.pending--,this.safeDispatchEvent("next"),this.autoStart&&this.tryToStartAnother()}),!0)}return!1}enqueue(t){this.queue.push(t),this.sort!=null&&this.queue.sort(this.sort)}start(){this.autoStart===!1&&(this.autoStart=!0,this.tryToStartAnother())}pause(){this.autoStart=!1}async add(t,n){if(n?.signal?.throwIfAborted(),this.size===this.maxSize)throw new wa;const s=new Bh(t,n);return this.enqueue(s),this.safeDispatchEvent("add"),this.autoStart&&this.tryToStartAnother(),s.join(n).then(i=>(this.safeDispatchEvent("success",{detail:{job:s,result:i}}),i)).catch(i=>{if(s.status==="queued"){for(let o=0;o<this.queue.length;o++)if(this.queue[o]===s){this.queue.splice(o,1);break}}throw this.safeDispatchEvent("failure",{detail:{job:s,error:i}}),i})}clear(){this.queue.splice(0,this.queue.length)}abort(){this.queue.forEach(t=>{t.abort(new _t)}),this.clear()}async onEmpty(t){this.size!==0&&await mr(this,"empty",t?.signal)}async onSizeLessThan(t,n){this.size<t||await mr(this,"next",n?.signal,{filter:()=>this.size<t})}async onIdle(t){this.pending===0&&this.size===0||await mr(this,"idle",t?.signal)}get size(){return this.queue.length}get queued(){return this.queue.length-this.pending}get running(){return this.pending}async*toGenerator(t){t?.signal?.throwIfAborted();const n=tn({objectMode:!0}),s=u=>{u!=null?this.abort():this.clear(),n.end(u)},i=u=>{u.detail!=null&&n.push(u.detail.result)},o=u=>{s(u.detail.error)},a=()=>{s()},l=()=>{s(new _t("Queue aborted"))};this.addEventListener("success",i),this.addEventListener("failure",o),this.addEventListener("idle",a),t?.signal?.addEventListener("abort",l);try{yield*n}finally{this.removeEventListener("success",i),this.removeEventListener("failure",o),this.removeEventListener("idle",a),t?.signal?.removeEventListener("abort",l),s()}}}const ba="lock:worker:request-read",va="lock:worker:abort-read-request",Ea="lock:worker:release-read",Sa="lock:master:grant-read",_a="lock:master:error-read",xa="lock:worker:request-write",Ca="lock:worker:abort-write-request",Aa="lock:worker:release-write",Ia="lock:master:grant-write",Ta="lock:master:error-write",La="lock:worker:finalize",Pa="mortice",Uh={singleProcess:!1},ni=(r,e,t,n,s,i,o,a,l)=>u=>{if(u.data==null)return;const d={type:u.data.type,name:u.data.name,identifier:u.data.identifier};d.type===s&&r.safeDispatchEvent(t,{detail:{name:d.name,identifier:d.identifier,handler:async()=>{e.postMessage({type:l,name:d.name,identifier:d.identifier}),await new Promise(h=>{const f=p=>{if(p?.data==null)return;const b={type:p.data.type,name:p.data.name,identifier:p.data.identifier};b.type===a&&b.identifier===d.identifier&&(e.removeEventListener("message",f),h())};e.addEventListener("message",f)})},onError:h=>{e.postMessage({type:o,name:d.name,identifier:d.identifier,error:{message:h.message,name:h.name,stack:h.stack}})}}}),d.type===i&&r.safeDispatchEvent(n,{detail:{name:d.name,identifier:d.identifier}}),d.type===La&&r.safeDispatchEvent("finalizeRequest",{detail:{name:d.name}})},zh=(r=10)=>Math.random().toString().substring(2,r+2);class qh{constructor(e){c(this,"name");c(this,"channel");this.name=e,this.channel=new BroadcastChannel(Pa)}readLock(e){return this.sendRequest(ba,va,Sa,_a,Ea,e)}writeLock(e){return this.sendRequest(xa,Ca,Ia,Ta,Aa,e)}finalize(){this.channel.postMessage({type:La,name:this.name}),this.channel.close()}async sendRequest(e,t,n,s,i,o){o?.signal?.throwIfAborted();const a=zh();return this.channel.postMessage({type:e,identifier:a,name:this.name}),new Promise((l,u)=>{const d=()=>{this.channel.postMessage({type:t,identifier:a,name:this.name})};o?.signal?.addEventListener("abort",d,{once:!0});const h=f=>{if(f.data?.identifier===a&&(f.data?.type===n&&(this.channel.removeEventListener("message",h),o?.signal?.removeEventListener("abort",d),l(()=>{this.channel.postMessage({type:i,identifier:a,name:this.name})})),f.data.type===s)){this.channel.removeEventListener("message",h),o?.signal?.removeEventListener("abort",d);const p=new Error;f.data.error!=null&&(p.message=f.data.error.message,p.name=f.data.error.name,p.stack=f.data.error.stack),u(p)}};this.channel.addEventListener("message",h)})}}const Vh=r=>{if(r=Object.assign({},Uh,r),!!globalThis.document||r.singleProcess){const t=new BroadcastChannel(Pa),n=new _e;return t.addEventListener("message",ni(n,t,"requestReadLock","abortReadLockRequest",ba,va,_a,Ea,Sa)),t.addEventListener("message",ni(n,t,"requestWriteLock","abortWriteLockRequest",xa,Ca,Ta,Aa,Ia)),n}return new qh(r.name)},Ue=new Map;let Lt;function ka(r){return typeof r?.readLock=="function"&&typeof r?.writeLock=="function"}function Wh(r){if(Lt==null&&(Lt=Vh(r),!ka(Lt))){const e=Lt;e.addEventListener("requestReadLock",t=>{const n=t.detail.name,s=t.detail.identifier,i=Ue.get(n);if(i==null)return;const o=new AbortController,a=l=>{l.detail.name!==n||l.detail.identifier!==s||o.abort()};e.addEventListener("abortReadLockRequest",a),i.readLock({signal:o.signal}).then(async l=>{await t.detail.handler().finally(()=>{l()})}).catch(l=>{t.detail.onError(l)}).finally(()=>{e.removeEventListener("abortReadLockRequest",a)})}),e.addEventListener("requestWriteLock",t=>{const n=t.detail.name,s=t.detail.identifier,i=Ue.get(n);if(i==null)return;const o=new AbortController,a=l=>{l.detail.name!==n||l.detail.identifier!==s||o.abort()};e.addEventListener("abortWriteLockRequest",a),i.writeLock({signal:o.signal}).then(async l=>{await t.detail.handler().finally(()=>{l()})}).catch(l=>{t.detail.onError(l)}).finally(()=>{e.removeEventListener("abortWriteLockRequest",a)})}),e.addEventListener("finalizeRequest",t=>{const n=t.detail.name,s=Ue.get(n);s?.finalize()})}return Lt}async function yr(r,e){let t,n;const s=new Promise((o,a)=>{t=o,n=a}),i=()=>{n(new _t)};return e?.signal?.addEventListener("abort",i,{once:!0}),r.add(async()=>{await new Promise(o=>{t(()=>{e?.signal?.removeEventListener("abort",i),o()})})},{signal:e?.signal}).catch(o=>{n(o)}),s}const Kh=(r,e)=>{let t=Ue.get(r);if(t!=null)return t;const n=Wh(e);if(ka(n))return t=n,Ue.set(r,t),t;const s=new ti({concurrency:1});let i;return t={async readLock(o){if(i!=null)return yr(i,o);i=new ti({concurrency:e.concurrency,autoStart:!1});const a=i,l=yr(i,o);return s.add(async()=>{a.start(),await a.onIdle().then(()=>{i===a&&(i=null)})}),l},async writeLock(o){return i=null,yr(s,o)},finalize:()=>{Ue.delete(r)},queue:s},Ue.set(r,t),e.autoFinalize===!0&&s.addEventListener("idle",()=>{t.finalize()},{once:!0}),t},Gh={name:"lock",concurrency:1/0,singleProcess:!1,autoFinalize:!1};function Qh(r){const e=Object.assign({},Gh,r);return Kh(e.name,e)}const jh=36e5,Hh=216e5;var ze;(function(r){(function(t){let n;t.codec=()=>(n==null&&(n=Le((s,i,o={})=>{o.lengthDelimited!==!1&&i.fork(),s.key!=null&&s.key!==""&&(i.uint32(10),i.string(s.key)),s.value!=null&&s.value.byteLength>0&&(i.uint32(18),i.bytes(s.value)),o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{const a={key:"",value:Ee(0)},l=i==null?s.len:s.pos+i;for(;s.pos<l;){const u=s.uint32();switch(u>>>3){case 1:{a.key=s.string();break}case 2:{a.value=s.bytes();break}default:{s.skipType(u&7);break}}}return a})),n),t.encode=s=>Pe(s,t.codec()),t.decode=(s,i)=>ke(s,t.codec(),i)})(r.Peer$metadataEntry||(r.Peer$metadataEntry={})),function(t){let n;t.codec=()=>(n==null&&(n=Le((s,i,o={})=>{o.lengthDelimited!==!1&&i.fork(),s.key!=null&&s.key!==""&&(i.uint32(10),i.string(s.key)),s.value!=null&&(i.uint32(18),Un.codec().encode(s.value,i)),o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{const a={key:""},l=i==null?s.len:s.pos+i;for(;s.pos<l;){const u=s.uint32();switch(u>>>3){case 1:{a.key=s.string();break}case 2:{a.value=Un.codec().decode(s,s.uint32(),{limits:o.limits?.value});break}default:{s.skipType(u&7);break}}}return a})),n),t.encode=s=>Pe(s,t.codec()),t.decode=(s,i)=>ke(s,t.codec(),i)}(r.Peer$tagsEntry||(r.Peer$tagsEntry={}));let e;r.codec=()=>(e==null&&(e=Le((t,n,s={})=>{if(s.lengthDelimited!==!1&&n.fork(),t.addresses!=null)for(const i of t.addresses)n.uint32(10),Bn.codec().encode(i,n);if(t.protocols!=null)for(const i of t.protocols)n.uint32(18),n.string(i);if(t.publicKey!=null&&(n.uint32(34),n.bytes(t.publicKey)),t.peerRecordEnvelope!=null&&(n.uint32(42),n.bytes(t.peerRecordEnvelope)),t.metadata!=null&&t.metadata.size!==0)for(const[i,o]of t.metadata.entries())n.uint32(50),r.Peer$metadataEntry.codec().encode({key:i,value:o},n);if(t.tags!=null&&t.tags.size!==0)for(const[i,o]of t.tags.entries())n.uint32(58),r.Peer$tagsEntry.codec().encode({key:i,value:o},n);t.updated!=null&&(n.uint32(64),n.uint64Number(t.updated)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={addresses:[],protocols:[],metadata:new Map,tags:new Map},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{if(s.limits?.addresses!=null&&i.addresses.length===s.limits.addresses)throw new Ar('Decode error - map field "addresses" had too many elements');i.addresses.push(Bn.codec().decode(t,t.uint32(),{limits:s.limits?.addresses$}));break}case 2:{if(s.limits?.protocols!=null&&i.protocols.length===s.limits.protocols)throw new Ar('Decode error - map field "protocols" had too many elements');i.protocols.push(t.string());break}case 4:{i.publicKey=t.bytes();break}case 5:{i.peerRecordEnvelope=t.bytes();break}case 6:{if(s.limits?.metadata!=null&&i.metadata.size===s.limits.metadata)throw new Ds('Decode error - map field "metadata" had too many elements');const l=r.Peer$metadataEntry.codec().decode(t,t.uint32());i.metadata.set(l.key,l.value);break}case 7:{if(s.limits?.tags!=null&&i.tags.size===s.limits.tags)throw new Ds('Decode error - map field "tags" had too many elements');const l=r.Peer$tagsEntry.codec().decode(t,t.uint32(),{limits:{value:s.limits?.tags$value}});i.tags.set(l.key,l.value);break}case 8:{i.updated=t.uint64Number();break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>Pe(t,r.codec()),r.decode=(t,n)=>ke(t,r.codec(),n)})(ze||(ze={}));var Bn;(function(r){let e;r.codec=()=>(e==null&&(e=Le((t,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),t.multiaddr!=null&&t.multiaddr.byteLength>0&&(n.uint32(10),n.bytes(t.multiaddr)),t.isCertified!=null&&(n.uint32(16),n.bool(t.isCertified)),t.observed!=null&&(n.uint32(24),n.uint64Number(t.observed)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={multiaddr:Ee(0)},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.multiaddr=t.bytes();break}case 2:{i.isCertified=t.bool();break}case 3:{i.observed=t.uint64Number();break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>Pe(t,r.codec()),r.decode=(t,n)=>ke(t,r.codec(),n)})(Bn||(Bn={}));var Un;(function(r){let e;r.codec=()=>(e==null&&(e=Le((t,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),t.value!=null&&t.value!==0&&(n.uint32(8),n.uint32(t.value)),t.expiry!=null&&(n.uint32(16),n.uint64(t.expiry)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={value:0},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.value=t.uint32();break}case 2:{i.expiry=t.uint64();break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>Pe(t,r.codec()),r.decode=(t,n)=>ke(t,r.codec(),n)})(Un||(Un={}));function Xh(r,e){if(r.publicKey!=null||e.publicKey==null)return r;let t;r.type==="RSA"&&(t=r.toMultihash());const n=Jr(e.publicKey,t);return ro(n)}function Yh(r,e,t){const n=ze.decode(e);return Dt(r,n,t)}function Dt(r,e,t){const n=new Map,s=BigInt(Date.now());for(const[i,o]of e.tags.entries())o.expiry!=null&&o.expiry<s||n.set(i,o);return{...e,id:Xh(r,e),addresses:e.addresses.filter(({observed:i})=>i!=null&&i>Date.now()-t).map(({multiaddr:i,isCertified:o})=>({multiaddr:z(i),isCertified:o??!1})),metadata:e.metadata,peerRecordEnvelope:e.peerRecordEnvelope??void 0,tags:n}}function Jh(r,e){return Zh(r.addresses,e.addresses)&&ef(r.protocols,e.protocols)&&tf(r.publicKey,e.publicKey)&&nf(r.peerRecordEnvelope,e.peerRecordEnvelope)&&rf(r.metadata,e.metadata)&&sf(r.tags,e.tags)}function Zh(r,e){return Ma(r,e,(t,n)=>!(t.isCertified!==n.isCertified||!Se(t.multiaddr,n.multiaddr)))}function ef(r,e){return Ma(r,e,(t,n)=>t===n)}function tf(r,e){return Da(r,e)}function nf(r,e){return Da(r,e)}function rf(r,e){return Na(r,e,(t,n)=>Se(t,n))}function sf(r,e){return Na(r,e,(t,n)=>t.value===n.value&&t.expiry===n.expiry)}function Da(r,e){return r==null&&e==null?!0:r!=null&&e!=null?Se(r,e):!1}function Ma(r,e,t){if(r.length!==e.length)return!1;for(let n=0;n<r.length;n++)if(!t(r[n],e[n]))return!1;return!0}function Na(r,e,t){if(r.size!==e.size)return!1;for(const[n,s]of r.entries()){const i=e.get(n);if(i==null||!t(s,i))return!1}return!0}const ye="/",Fa=new TextEncoder().encode(ye),an=Fa[0];class G{constructor(e,t){c(this,"_buf");if(typeof e=="string")this._buf=F(e);else if(e instanceof Uint8Array)this._buf=e;else throw new Error("Invalid key, should be String of Uint8Array");if(t==null&&(t=!0),t&&this.clean(),this._buf.byteLength===0||this._buf[0]!==an)throw new Error("Invalid key")}toString(e="utf8"){return Y(this._buf,e)}uint8Array(){return this._buf}get[Symbol.toStringTag](){return`Key(${this.toString()})`}static withNamespaces(e){return new G(e.join(ye))}static random(){return new G(Math.random().toString().substring(2))}static asKey(e){return e instanceof Uint8Array||typeof e=="string"?new G(e):typeof e.uint8Array=="function"?new G(e.uint8Array()):null}clean(){if((this._buf==null||this._buf.byteLength===0)&&(this._buf=Fa),this._buf[0]!==an){const e=new Uint8Array(this._buf.byteLength+1);e.fill(an,0,1),e.set(this._buf,1),this._buf=e}for(;this._buf.byteLength>1&&this._buf[this._buf.byteLength-1]===an;)this._buf=this._buf.subarray(0,-1)}less(e){const t=this.list(),n=e.list();for(let s=0;s<t.length;s++){if(n.length<s+1)return!1;const i=t[s],o=n[s];if(i<o)return!0;if(i>o)return!1}return t.length<n.length}reverse(){return G.withNamespaces(this.list().slice().reverse())}namespaces(){return this.list()}baseNamespace(){const e=this.namespaces();return e[e.length-1]}list(){return this.toString().split(ye).slice(1)}type(){return of(this.baseNamespace())}name(){return af(this.baseNamespace())}instance(e){return new G(this.toString()+":"+e)}path(){let e=this.parent().toString();return e.endsWith(ye)||(e+=ye),e+=this.type(),new G(e)}parent(){const e=this.list();return e.length===1?new G(ye):new G(e.slice(0,-1).join(ye))}child(e){return this.toString()===ye?e:e.toString()===ye?this:new G(this.toString()+e.toString(),!1)}isAncestorOf(e){return e.toString()===this.toString()?!1:e.toString().startsWith(this.toString())}isDecendantOf(e){return e.toString()===this.toString()?!1:this.toString().startsWith(e.toString())}isTopLevel(){return this.list().length===1}concat(...e){return G.withNamespaces([...this.namespaces(),...cf(e.map(t=>t.namespaces()))])}}function of(r){const e=r.split(":");return e.length<2?"":e.slice(0,-1).join(":")}function af(r){const e=r.split(":");return e[e.length-1]}function cf(r){return[].concat(...r)}const Ra="/peers/";function cn(r){if(!Nt(r)||r.type==null)throw new N("Invalid PeerId");const e=r.toCID().toString();return new G(`${Ra}${e}`)}async function lf(r,e,t,n,s){const i=new Map;for(const o of t){if(o==null)continue;if(o.multiaddr instanceof Uint8Array&&(o.multiaddr=z(o.multiaddr)),!Hn(o.multiaddr))throw new N("Multiaddr was invalid");if(!await e(r,o.multiaddr,s))continue;const a=o.isCertified??!1,l=o.multiaddr.toString(),u=i.get(l);u!=null?o.isCertified=u.isCertified||a:i.set(l,{multiaddr:o.multiaddr,isCertified:a})}return[...i.values()].sort((o,a)=>o.multiaddr.toString().localeCompare(a.multiaddr.toString())).map(({isCertified:o,multiaddr:a})=>{const l=a.getComponents().find(u=>u.code===C)?.value;return r.equals(l)&&(a=a.decapsulate(z(`/p2p/${r}`))),{isCertified:o,multiaddr:a.bytes}})}async function wr(r,e,t,n){if(e==null)throw new N("Invalid PeerData");if(e.publicKey!=null&&r.publicKey!=null&&!e.publicKey.equals(r.publicKey))throw new N("publicKey bytes do not match peer id publicKey bytes");const s=n.existingPeer?.peer;if(s!=null&&!r.equals(s.id))throw new N("peer id did not match existing peer id");let i=s?.addresses??[],o=new Set(s?.protocols??[]),a=s?.metadata??new Map,l=s?.tags??new Map,u=s?.peerRecordEnvelope;if(t==="patch"){if((e.multiaddrs!=null||e.addresses!=null)&&(i=[],e.multiaddrs!=null&&i.push(...e.multiaddrs.map(f=>({isCertified:!1,multiaddr:f}))),e.addresses!=null&&i.push(...e.addresses)),e.protocols!=null&&(o=new Set(e.protocols)),e.metadata!=null){const f=e.metadata instanceof Map?[...e.metadata.entries()]:Object.entries(e.metadata);a=ln(f,{validate:ri})}if(e.tags!=null){const f=e.tags instanceof Map?[...e.tags.entries()]:Object.entries(e.tags);l=ln(f,{validate:si,map:ii})}e.peerRecordEnvelope!=null&&(u=e.peerRecordEnvelope)}if(t==="merge"){if(e.multiaddrs!=null&&i.push(...e.multiaddrs.map(f=>({isCertified:!1,multiaddr:f}))),e.addresses!=null&&i.push(...e.addresses),e.protocols!=null&&(o=new Set([...o,...e.protocols])),e.metadata!=null){const f=e.metadata instanceof Map?[...e.metadata.entries()]:Object.entries(e.metadata);for(const[p,b]of f)b==null?a.delete(p):a.set(p,b);a=ln([...a.entries()],{validate:ri})}if(e.tags!=null){const f=e.tags instanceof Map?[...e.tags.entries()]:Object.entries(e.tags),p=new Map(l);for(const[b,x]of f)x==null?p.delete(b):p.set(b,x);l=ln([...p.entries()],{validate:si,map:ii})}e.peerRecordEnvelope!=null&&(u=e.peerRecordEnvelope)}let d;s?.id.publicKey!=null?d=fn(s.id.publicKey):e.publicKey!=null?d=fn(e.publicKey):r.publicKey!=null&&(d=fn(r.publicKey));const h={addresses:await lf(r,n.addressFilter??(async()=>!0),i,n.existingPeer?.peerPB.addresses,n),protocols:[...o.values()].sort((f,p)=>f.localeCompare(p)),metadata:a,tags:l,publicKey:d,peerRecordEnvelope:u};return h.addresses.forEach(f=>{f.observed=n.existingPeer?.peerPB.addresses?.find(p=>Se(p.multiaddr,p.multiaddr))?.observed??Date.now()}),r.type!=="RSA"&&delete h.publicKey,h}function ln(r,e){const t=new Map;for(const[n,s]of r)s!=null&&e.validate(n,s);for(const[n,s]of r.sort(([i],[o])=>i.localeCompare(o)))s!=null&&t.set(n,e.map?.(n,s)??s);return t}function ri(r,e){if(typeof r!="string")throw new N("Metadata key must be a string");if(!(e instanceof Uint8Array))throw new N("Metadata value must be a Uint8Array")}function si(r,e){if(typeof r!="string")throw new N("Tag name must be a string");if(e.value!=null){if(parseInt(`${e.value}`,10)!==e.value)throw new N("Tag value must be an integer");if(e.value<0||e.value>100)throw new N("Tag value must be between 0-100")}if(e.ttl!=null){if(parseInt(`${e.ttl}`,10)!==e.ttl)throw new N("Tag ttl must be an integer");if(e.ttl<0)throw new N("Tag ttl must be between greater than 0")}}function ii(r,e){let t;e.expiry!=null&&(t=e.expiry),e.ttl!=null&&(t=BigInt(Date.now()+Number(e.ttl)));const n={value:e.value??0};return t!=null&&(n.expiry=t),n}function $a(r){const e=r.toString().split("/")[2],t=Xt.parse(e,Yr);return ts(t)}function br(r,e,t){const n=$a(r);return Yh(n,e,t)}function uf(r,e){return{prefix:Ra,filters:(r.filters??[]).map(t=>({key:n,value:s})=>t(br(n,s,e))),orders:(r.orders??[]).map(t=>(n,s)=>t(br(n.key,n.value,e),br(s.key,s.value,e)))}}var X,vn,En,Sn;class df{constructor(e,t={}){D(this,X);c(this,"peerId");c(this,"datastore");c(this,"locks");c(this,"addressFilter");c(this,"log");c(this,"maxAddressAge");c(this,"maxPeerAge");this.log=e.logger.forComponent("libp2p:peer-store"),this.peerId=e.peerId,this.datastore=e.datastore,this.addressFilter=t.addressFilter,this.locks=kh({name:"libp2p_peer_store_locks",metrics:e.metrics}),this.maxAddressAge=t.maxAddressAge??jh,this.maxPeerAge=t.maxPeerAge??Hh}getLock(e){let t=this.locks.get(e);return t==null&&(t={refs:0,lock:Qh({name:e.toString(),singleProcess:!0})},this.locks.set(e,t)),t.refs++,t}maybeRemoveLock(e,t){t.refs--,t.refs===0&&(t.lock.finalize(),this.locks.delete(e))}async getReadLock(e,t){const n=this.getLock(e);try{const s=await n.lock.readLock(t);return()=>{s(),this.maybeRemoveLock(e,n)}}catch(s){throw this.maybeRemoveLock(e,n),s}}async getWriteLock(e,t){const n=this.getLock(e);try{const s=await n.lock.writeLock(t);return()=>{s(),this.maybeRemoveLock(e,n)}}catch(s){throw this.maybeRemoveLock(e,n),s}}async has(e,t){try{return await this.load(e,t),!0}catch(n){if(n.name!=="NotFoundError")throw n}return!1}async delete(e,t){this.peerId.equals(e)||await this.datastore.delete(cn(e),t)}async load(e,t){const n=cn(e),s=await this.datastore.get(n,t),i=ze.decode(s);if(E(this,X,Sn).call(this,e,i))throw await this.datastore.delete(n,t),new Ir;return Dt(e,i,this.peerId.equals(e)?1/0:this.maxAddressAge)}async save(e,t,n){const s=await E(this,X,vn).call(this,e,n),i=await wr(e,t,"patch",{...n,addressFilter:this.addressFilter});return E(this,X,En).call(this,e,i,s)}async patch(e,t,n){const s=await E(this,X,vn).call(this,e,n),i=await wr(e,t,"patch",{...n,addressFilter:this.addressFilter,existingPeer:s});return E(this,X,En).call(this,e,i,s)}async merge(e,t,n){const s=await E(this,X,vn).call(this,e,n),i=await wr(e,t,"merge",{addressFilter:this.addressFilter,existingPeer:s});return E(this,X,En).call(this,e,i,s)}async*all(e){for await(const{key:t,value:n}of this.datastore.query(uf(e??{},this.maxAddressAge),e)){const s=$a(t);if(s.equals(this.peerId))continue;const i=ze.decode(n);if(E(this,X,Sn).call(this,s,i)){await this.datastore.delete(t,e);continue}yield Dt(s,i,this.peerId.equals(s)?1/0:this.maxAddressAge)}}}X=new WeakSet,vn=async function(e,t){try{const n=cn(e),s=await this.datastore.get(n,t),i=ze.decode(s);if(E(this,X,Sn).call(this,e,i))throw await this.datastore.delete(n,t),new Ir;return{peerPB:i,peer:Dt(e,i,this.maxAddressAge)}}catch(n){n.name!=="NotFoundError"&&this.log.error("invalid peer data found in peer store - %e",n)}},En=async function(e,t,n,s){t.updated=Date.now();const i=ze.encode(t);return await this.datastore.put(cn(e),i,s),{peer:Dt(e,t,this.maxAddressAge),previous:n?.peer,updated:n==null||!Jh(t,n.peerPB)}},Sn=function(e,t){if(t.updated==null)return!0;if(this.peerId.equals(e))return!1;const n=t.updated<Date.now()-this.maxPeerAge,s=Date.now()-this.maxAddressAge,i=t.addresses.filter(o=>o.observed!=null&&o.observed>s);return n&&i.length===0};var Pi,ft,_n;Pi=Symbol.toStringTag;class hf{constructor(e,t={}){D(this,ft);c(this,"store");c(this,"events");c(this,"peerId");c(this,"log");c(this,Pi,"@libp2p/peer-store");this.log=e.logger.forComponent("libp2p:peer-store"),this.events=e.events,this.peerId=e.peerId,this.store=new df(e,t)}async forEach(e,t){for await(const n of this.store.all(t))e(n)}async all(e){return Ur(this.store.all(e))}async delete(e,t){const n=await this.store.getReadLock(e,t);try{await this.store.delete(e,t)}finally{n()}}async has(e,t){const n=await this.store.getReadLock(e,t);try{return await this.store.has(e,t)}finally{this.log.trace("has release read lock"),n?.()}}async get(e,t){const n=await this.store.getReadLock(e,t);try{return await this.store.load(e,t)}finally{n?.()}}async getInfo(e,t){const n=await this.get(e,t);return{id:n.id,multiaddrs:n.addresses.map(({multiaddr:s})=>s)}}async save(e,t,n){const s=await this.store.getWriteLock(e,n);try{const i=await this.store.save(e,t,n);return E(this,ft,_n).call(this,e,i),i.peer}finally{s?.()}}async patch(e,t,n){const s=await this.store.getWriteLock(e,n);try{const i=await this.store.patch(e,t,n);return E(this,ft,_n).call(this,e,i),i.peer}finally{s?.()}}async merge(e,t,n){const s=await this.store.getWriteLock(e,n);try{const i=await this.store.merge(e,t,n);return E(this,ft,_n).call(this,e,i),i.peer}finally{s?.()}}async consumePeerRecord(e,t,n){const s=Nt(t)?t:Nt(t?.expectedPeer)?t.expectedPeer:void 0,i=Nt(t)||t===void 0?n:t,o=await $n.openAndCertify(e,$t.DOMAIN,i),a=ts(o.publicKey.toCID());if(s?.equals(a)===!1)return this.log("envelope peer id was not the expected peer id - expected: %p received: %p",s,a),!1;const l=$t.createFromProtobuf(o.payload);let u;try{u=await this.get(a,i)}catch(d){if(d.name!=="NotFoundError")throw d}if(u?.peerRecordEnvelope!=null){const d=$n.createFromProtobuf(u.peerRecordEnvelope),h=$t.createFromProtobuf(d.payload);if(h.seqNumber>=l.seqNumber)return this.log("sequence number was lower or equal to existing sequence number - stored: %d received: %d",h.seqNumber,l.seqNumber),!1}return await this.patch(l.peerId,{peerRecordEnvelope:e,addresses:l.multiaddrs.map(d=>({isCertified:!0,multiaddr:d}))},i),!0}}ft=new WeakSet,_n=function(e,t){t.updated&&(this.peerId.equals(e)?this.events.safeDispatchEvent("self:peer:update",{detail:t}):this.events.safeDispatchEvent("peer:update",{detail:t}))};function ff(r,e={}){return new hf(r,e)}const rt=class rt extends Error{constructor(t="Not Found"){super(t);c(this,"name",rt.name);c(this,"code",rt.code)}};c(rt,"name","NotFoundError"),c(rt,"code","ERR_NOT_FOUND");let zr=rt;function mf(r){return r[Symbol.asyncIterator]!=null}function oi(r){if(mf(r))return(async()=>{for await(const e of r);})();for(const e of r);}function pf(r){return r[Symbol.asyncIterator]!=null}function Ze(r,e){let t=0;if(pf(r))return async function*(){for await(const l of r)await e(l,t++)&&(yield l)}();const n=id(r),{value:s,done:i}=n.next();if(i===!0)return function*(){}();const o=e(s,t++);if(typeof o.then=="function")return async function*(){await o&&(yield s);for(const l of n)await e(l,t++)&&(yield l)}();const a=e;return function*(){o===!0&&(yield s);for(const l of n)a(l,t++)&&(yield l)}()}function gf(r){return r[Symbol.asyncIterator]!=null}function ai(r,e){return gf(r)?async function*(){yield*(await Ur(r)).sort(e)}():function*(){yield*Ur(r).sort(e)}()}function yf(r){return r[Symbol.asyncIterator]!=null}function ci(r,e){return yf(r)?async function*(){let t=0;if(!(e<1)){for await(const n of r)if(yield n,t++,t===e)return}}():function*(){let t=0;if(!(e<1)){for(const n of r)if(yield n,t++,t===e)return}}()}class wf{put(e,t,n){return Promise.reject(new Error(".put is not implemented"))}get(e,t){return Promise.reject(new Error(".get is not implemented"))}has(e,t){return Promise.reject(new Error(".has is not implemented"))}delete(e,t){return Promise.reject(new Error(".delete is not implemented"))}async*putMany(e,t={}){for await(const{key:n,value:s}of e)await this.put(n,s,t),yield n}async*getMany(e,t={}){for await(const n of e)yield{key:n,value:await this.get(n,t)}}async*deleteMany(e,t={}){for await(const n of e)await this.delete(n,t),yield n}batch(){let e=[],t=[];return{put(n,s){e.push({key:n,value:s})},delete(n){t.push(n)},commit:async n=>{await oi(this.putMany(e,n)),e=[],await oi(this.deleteMany(t,n)),t=[]}}}async*_all(e,t){throw new Error("._all is not implemented")}async*_allKeys(e,t){throw new Error("._allKeys is not implemented")}query(e,t){let n=this._all(e,t);if(e.prefix!=null){const s=e.prefix;n=Ze(n,i=>i.key.toString().startsWith(s))}if(Array.isArray(e.filters)&&(n=e.filters.reduce((s,i)=>Ze(s,i),n)),Array.isArray(e.orders)&&(n=e.orders.reduce((s,i)=>ai(s,i),n)),e.offset!=null){let s=0;const i=e.offset;n=Ze(n,()=>s++>=i)}return e.limit!=null&&(n=ci(n,e.limit)),n}queryKeys(e,t){let n=this._allKeys(e,t);if(e.prefix!=null){const s=e.prefix;n=Ze(n,i=>i.toString().startsWith(s))}if(Array.isArray(e.filters)&&(n=e.filters.reduce((s,i)=>Ze(s,i),n)),Array.isArray(e.orders)&&(n=e.orders.reduce((s,i)=>ai(s,i),n)),e.offset!=null){const s=e.offset;let i=0;n=Ze(n,()=>i++>=s)}return e.limit!=null&&(n=ci(n,e.limit)),n}}class bf extends wf{constructor(){super();c(this,"data");this.data=new Map}put(t,n,s){return s?.signal?.throwIfAborted(),this.data.set(t.toString(),n),t}get(t,n){n?.signal?.throwIfAborted();const s=this.data.get(t.toString());if(s==null)throw new zr;return s}has(t,n){return n?.signal?.throwIfAborted(),this.data.has(t.toString())}delete(t,n){n?.signal?.throwIfAborted(),this.data.delete(t.toString())}*_all(t,n){n?.signal?.throwIfAborted();for(const[s,i]of this.data.entries())yield{key:new G(s),value:i},n?.signal?.throwIfAborted()}*_allKeys(t,n){n?.signal?.throwIfAborted();for(const s of this.data.keys())yield new G(s),n?.signal?.throwIfAborted()}}const $=r=>({match:e=>{const t=e[0];return t==null||t.code!==r||t.value!=null?!1:e.slice(1)}}),_=(r,e)=>({match:t=>{const n=t[0];return n?.code!==r||n.value==null||e!=null&&n.value!==e?!1:t.slice(1)}}),vf=r=>({match:e=>r.match(e)===!1?e:!1}),I=r=>({match:e=>{const t=r.match(e);return t===!1?e:t}}),Q=(...r)=>({match:e=>{let t;for(const n of r){const s=n.match(e);s!==!1&&(t==null||s.length<t.length)&&(t=s)}return t??!1}}),M=(...r)=>({match:e=>{for(const t of r){const n=t.match(e);if(n===!1)return!1;e=n}return e}});function O(...r){function e(s){if(s==null)return!1;let i=s.getComponents();for(const o of r){const a=o.match(i);if(a===!1)return!1;i=a}return i}function t(s){return e(s)!==!1}function n(s){const i=e(s);return i===!1?!1:i.length===0}return{matchers:r,matches:t,exactMatch:n}}const Ef=_(C),Sf=O(Ef),er=_(mo),tr=_(po),nr=_(go),xs=_(fo);O(er,I(_(C)));O(tr,I(_(C)));O(nr,I(_(C)));const zp=O(Q(xs,nr,er,tr),I(_(C))),Oa=M(_(An),I(_(ns))),Ba=M(I(_(ho)),_(In),I(_(ns))),Cs=Q(Oa,Ba),Qe=Q(Cs,xs,er,tr,nr),qp=O(Q(Cs,M(Q(xs,nr,er,tr),I(_(C))))),li=O(Oa),ui=O(Ba),Vp=O(Cs),As=M(Qe,_(st)),nn=M(Qe,_(uo)),qr=O(M(As,I(_(C))));O(nn);const Is=M(nn,$(wo),I(_(C))),rr=M(nn,$(bo),I(_(C))),_f=Q(Is,rr);O(Is);const xf=O(rr),Vr=Q(Qe,As,nn,Is,rr),Ua=Q(M(Vr,$(rs),I(_(C)))),zn=O(Ua),za=Q(M(Vr,$(Eo),I(_(C))),M(Vr,$(it),I(_(Tn)),$(rs),I(_(C)))),Wr=O(za),qa=M(nn,$(So),I(_(Bt)),I(_(Bt)),I(_(C))),di=O(qa),Va=M(rr,$(vo),I(_(Bt)),I(_(Bt)),I(_(C))),hi=O(Va),qn=Q(Ua,za,M(As,I(_(C))),M(_f,I(_(C))),M(Qe,I(_(C))),qa,Va,_(C)),Wp=O(qn),Cf=M(I(qn),$(ss),vf($(Ft)),I(_(C))),Vn=O(Cf),Af=Q(M(qn,$(ss),$(Ft),I(_(C))),M(qn,$(Ft),I(_(C))),M($(Ft),I(_(C)))),fi=O(Af),If=Q(M(Qe,_(st),$(ot),I(_(C))),M(Qe,$(ot),I(_(C))));O(If);const Tf=M(Qe,Q(M(_(st,"443"),$(ot)),M(_(st),$(kr)),M(_(st),$(it),$(ot)),M($(it),$(ot)),$(it),$(kr)),I(_(C)));O(Tf);const Lf=Q(M(_(_o),I(_(C))));O(Lf);const Pf=Q(M(_(yo),I(_(C))));O(Pf);const mi=864e13;class kf{constructor(e,t={}){c(this,"log");c(this,"mappings");this.log=e.logger.forComponent("libp2p:address-manager:dns-mappings"),this.mappings=Ce({name:"libp2p_address_manager_dns_mappings",metrics:e.metrics})}has(e){const t=R(e);let n=t.host;(t.type==="ip4"||t.type==="ip6")&&t.sni!=null&&(n=t.sni);for(const s of this.mappings.values())if(s.domain===n)return!0;return!1}add(e,t){t.forEach(n=>{this.log("add DNS mapping %s to %s",n,e);const s=vs(n)===!0;this.mappings.set(n,{domain:e,verified:s,expires:s?mi-Date.now():0,lastVerified:s?mi-Date.now():void 0})})}remove(e){const t=R(e);if(t.type!=="ip4"&&t.type!=="ip6")return!1;let n=!1;for(const[s,i]of this.mappings.entries())i.domain===t.sni&&(this.log("removing %s to %s DNS mapping %e",s,i.domain),this.mappings.delete(s),n=n||i.verified);return n}getAll(e){const t=[];for(let n=0;n<e.length;n++){const s=e[n].multiaddr;if(!he(s))continue;const i=R(s);for(const[o,a]of this.mappings.entries()){if(i.host!==o)continue;const l=this.maybeAddSNIComponent(s,a.domain);l!=null&&(e.splice(n,1),n--,t.push({multiaddr:l,verified:a.verified,type:"dns-mapping",expires:a.expires,lastVerified:a.lastVerified}))}}return t}maybeAddSNIComponent(e,t){const n=e.getComponents();for(let s=0;s<n.length;s++)if(n[s].code===it&&n[s+1]?.code!==Tn)return n.splice(s+1,0,{name:"sni",code:Tn,value:t}),z(n)}confirm(e,t){const n=R(e);let s=n.host;(n.type==="ip4"||n.type==="ip6")&&n.sni!=null&&(s=n.sni);let i=!1;for(const[o,a]of this.mappings.entries())a.domain===s&&(this.log("marking %s to %s DNS mapping as verified",o,a.domain),i=a.verified,a.verified=!0,a.expires=Date.now()+t,a.lastVerified=Date.now());return i}unconfirm(e,t){const n=R(e);if(n.type!=="ip4"&&n.type!=="ip6")return!1;const s=n.sni??n.host;let i=!1;for(const[o,a]of this.mappings.entries())a.domain===s&&(this.log("removing verification of %s to %s DNS mapping",o,a.domain),i=i||a.verified,a.verified=!1,a.expires=Date.now()+t);return i}}class Df{constructor(e,t={}){c(this,"log");c(this,"mappings");this.log=e.logger.forComponent("libp2p:address-manager:ip-mappings"),this.mappings=Ce({name:"libp2p_address_manager_ip_mappings",metrics:e.metrics})}has(e){const t=R(e);if(t.type!=="ip4"&&t.type!=="ip6")return!1;for(const n of this.mappings.values())for(const s of n)if(s.externalIp===t.host)return!0;return!1}add(e,t,n,s=t,i="tcp"){const o=`${e}-${t}-${i}`,a=this.mappings.get(o)??[],l={internalIp:e,internalPort:t,externalIp:n,externalPort:s,externalFamily:yt(n)?4:6,protocol:i,verified:!1,expires:0};a.push(l),this.mappings.set(o,a)}remove(e){const t=R(e);if(t.type!=="ip4"&&t.type!=="ip6")return!1;let n=!1;for(const[s,i]of this.mappings.entries()){for(let o=0;o<i.length;o++){const a=i[o];a.externalIp===t.host&&a.externalPort===t.port&&a.protocol===t.protocol&&(this.log("removing %s:%s to %s:%s %s IP mapping",a.externalIp,a.externalPort,t.host,t.port,t.protocol),n=n||a.verified,i.splice(o,1),o--)}i.length===0&&this.mappings.delete(s)}return n}getAll(e){const t=[];for(const{multiaddr:n}of e){if(!he(n))continue;const s=R(n);if(s.type!=="ip4"&&s.type!=="ip6")continue;let i;if(s.protocol==="tcp"?i=`${s.host}-${s.port}-tcp`:s.protocol==="udp"&&(i=`${s.host}-${s.port}-udp`),i==null)continue;const o=this.mappings.get(i);if(o!=null)for(const a of o)t.push({multiaddr:this.maybeOverrideIp(n,a.externalIp,a.externalFamily,a.protocol,a.externalPort),verified:a.verified,type:"ip-mapping",expires:a.expires,lastVerified:a.lastVerified})}return t}maybeOverrideIp(e,t,n,s,i){const o=e.getComponents(),a=o.findIndex(u=>u.code===An||u.code===In),l=o.findIndex(u=>u.name===s);return a>-1&&l>-1?(o[a].value=t,o[a].code=n===4?An:In,o[l].value=`${i}`,z(o)):e}confirm(e,t){if(!he(e))return!1;const n=R(e);let s=!1;for(const i of this.mappings.values())for(const o of i)o.externalIp===n.host&&(this.log("marking %s to %s IP mapping as verified",o.internalIp,o.externalIp),s=o.verified,o.verified=!0,o.expires=Date.now()+t,o.lastVerified=Date.now());return s}unconfirm(e,t){if(!he(e))return!1;const n=R(e);let s=!1;for(const i of this.mappings.values())for(let o=0;o<i.length;o++){const a=i[o];a.externalIp===n.host&&a.externalPort===n.port&&a.protocol===n.protocol&&(this.log("removing verification of %s:%s to %s:%s %s IP mapping",a.externalIp,a.externalPort,n.host,n.port,n.protocol),s=s||a.verified,a.verified=!1,a.expires=Date.now()+t)}return s}}const Mf={maxObservedAddresses:10};class Nf{constructor(e,t={}){c(this,"log");c(this,"addresses");c(this,"maxObservedAddresses");this.log=e.logger.forComponent("libp2p:address-manager:observed-addresses"),this.addresses=Ce({name:"libp2p_address_manager_observed_addresses",metrics:e.metrics}),this.maxObservedAddresses=t.maxObservedAddresses??Mf.maxObservedAddresses}has(e){return this.addresses.has(e.toString())}removePrefixed(e){for(const t of this.addresses.keys())t.toString().startsWith(e)&&this.addresses.delete(t)}add(e){this.addresses.size!==this.maxObservedAddresses&&(Gt(e)||Cd(e)||(this.log("adding observed address %a",e),this.addresses.set(e.toString(),{verified:!1,expires:0})))}getAll(){return Array.from(this.addresses).map(([e,t])=>({multiaddr:z(e),verified:t.verified,type:"observed",expires:t.expires,lastVerified:t.lastVerified}))}remove(e){const t=this.addresses.get(e.toString())?.verified??!1;return this.log("removing observed address %a",e),this.addresses.delete(e.toString()),t}confirm(e,t){const n=e.toString(),s=this.addresses.get(n)??{verified:!1,expires:Date.now()+t,lastVerified:Date.now()},i=s.verified;return s.verified=!0,s.expires=Date.now()+t,s.lastVerified=Date.now(),this.log("marking observed address %a as verified",n),this.addresses.set(n,s),i}}const Ff={maxObservedAddresses:10};class Rf{constructor(e,t={}){c(this,"log");c(this,"addresses");c(this,"maxObservedAddresses");this.log=e.logger.forComponent("libp2p:address-manager:observed-addresses"),this.addresses=Ce({name:"libp2p_address_manager_transport_addresses",metrics:e.metrics}),this.maxObservedAddresses=t.maxObservedAddresses??Ff.maxObservedAddresses}get(e,t){if(Gt(e))return{multiaddr:e,verified:!0,type:"transport",expires:Date.now()+t,lastVerified:Date.now()};const n=this.toKey(e);let s=this.addresses.get(n);return s==null&&(s={verified:!he(e),expires:0},this.addresses.set(n,s)),{multiaddr:e,verified:s.verified,type:"transport",expires:s.expires,lastVerified:s.lastVerified}}has(e){const t=this.toKey(e);return this.addresses.has(t)}remove(e){const t=this.toKey(e),n=this.addresses.get(t)?.verified??!1;return this.log("removing observed address %a",e),this.addresses.delete(t),n}confirm(e,t){const n=this.toKey(e),s=this.addresses.get(n)??{verified:!1,expires:0,lastVerified:0},i=s.verified;return s.verified=!0,s.expires=Date.now()+t,s.lastVerified=Date.now(),this.addresses.set(n,s),i}unconfirm(e,t){const n=this.toKey(e),s=this.addresses.get(n)??{verified:!1,expires:0},i=s.verified;return s.verified=!1,s.expires=Date.now()+t,this.addresses.set(n,s),i}toKey(e){if(!he(e))return e.toString();const t=R(e);return`${t.host}-${t.port}-${t.protocol}`}}const pi=6e4,gi={addressVerificationTTL:pi*10,addressVerificationRetry:pi*5},$f=r=>r;function vr(r,e){const t=r.getComponents().findLast(n=>n.code===C)?.value;return t!=null&&mt(t).equals(e)&&(r=r.decapsulate(z(`/p2p/${e.toString()}`))),r}var ki;ki=Symbol.toStringTag;class Of{constructor(e,t={}){c(this,"log");c(this,"components");c(this,"listen");c(this,"announce");c(this,"appendAnnounce");c(this,"announceFilter");c(this,"observed");c(this,"dnsMappings");c(this,"ipMappings");c(this,"transportAddresses");c(this,"observedAddressFilter");c(this,"addressVerificationTTL");c(this,"addressVerificationRetry");c(this,ki,"@libp2p/address-manager");const{listen:n=[],announce:s=[],appendAnnounce:i=[]}=t;this.components=e,this.log=e.logger.forComponent("libp2p:address-manager"),this.listen=n.map(o=>o.toString()),this.announce=new Set(s.map(o=>o.toString())),this.appendAnnounce=new Set(i.map(o=>o.toString())),this.observed=new Nf(e,t),this.dnsMappings=new kf(e,t),this.ipMappings=new Df(e,t),this.transportAddresses=new Rf(e,t),this.announceFilter=t.announceFilter??$f,this.observedAddressFilter=ws(1024),this.addressVerificationTTL=t.addressVerificationTTL??gi.addressVerificationTTL,this.addressVerificationRetry=t.addressVerificationRetry??gi.addressVerificationRetry,this._updatePeerStoreAddresses=Mn(this._updatePeerStoreAddresses.bind(this),1e3),e.events.addEventListener("transport:listening",()=>{this._updatePeerStoreAddresses()}),e.events.addEventListener("transport:close",()=>{this._updatePeerStoreAddresses()})}_updatePeerStoreAddresses(){const e=this.getAddresses().map(t=>t.getComponents().findLast(n=>n.code===C)?.value===this.components.peerId.toString()?t.decapsulate(`/p2p/${this.components.peerId.toString()}`):t);this.components.peerStore.patch(this.components.peerId,{multiaddrs:e}).catch(t=>{this.log.error("error updating addresses - %e",t)})}getListenAddrs(){return Array.from(this.listen).map(e=>z(e))}getAnnounceAddrs(){return Array.from(this.announce).map(e=>z(e))}getAppendAnnounceAddrs(){return Array.from(this.appendAnnounce).map(e=>z(e))}getObservedAddrs(){return this.observed.getAll().map(e=>e.multiaddr)}addObservedAddr(e){const t=R(e);let n;switch(t.type){case"ip4":{n=`${t.host}:${t.port}`;break}case"ip6":{n=`[${t.host}]:${t.port}`;break}default:return}this.observedAddressFilter.has(n)||(this.observedAddressFilter.add(n),e=vr(e,this.components.peerId),!this.ipMappings.has(e)&&(this.dnsMappings.has(e)||this.observed.add(e)))}confirmObservedAddr(e,t){e=vr(e,this.components.peerId);let n=!0;(t?.type==="transport"||this.transportAddresses.has(e))&&!this.transportAddresses.confirm(e,t?.ttl??this.addressVerificationTTL)&&n&&(n=!1),(t?.type==="dns-mapping"||this.dnsMappings.has(e))&&!this.dnsMappings.confirm(e,t?.ttl??this.addressVerificationTTL)&&n&&(n=!1),(t?.type==="ip-mapping"||this.ipMappings.has(e))&&!this.ipMappings.confirm(e,t?.ttl??this.addressVerificationTTL)&&n&&(n=!1),(t?.type==="observed"||this.observed.has(e))&&(this.maybeUpgradeToIPMapping(e)?(this.ipMappings.confirm(e,t?.ttl??this.addressVerificationTTL),n=!1):!this.observed.confirm(e,t?.ttl??this.addressVerificationTTL)&&n&&(n=!1)),n||this._updatePeerStoreAddresses()}removeObservedAddr(e,t){e=vr(e,this.components.peerId),this.observed.has(e)&&this.observed.remove(e),this.transportAddresses.has(e)&&this.transportAddresses.unconfirm(e,t?.ttl??this.addressVerificationRetry),this.dnsMappings.has(e)&&this.dnsMappings.unconfirm(e,t?.ttl??this.addressVerificationRetry),this.ipMappings.has(e)&&this.ipMappings.unconfirm(e,t?.ttl??this.addressVerificationRetry)}getAddresses(){const e=new Set,t=this.getAddressesWithMetadata().filter(n=>{if(!n.verified)return!1;const s=n.multiaddr.toString();return e.has(s)?!1:(e.add(s),!0)}).map(n=>n.multiaddr);return this.announceFilter(t.map(n=>{const s=z(n);return s.getComponents().pop()?.value===this.components.peerId.toString()?s:s.encapsulate(`/p2p/${this.components.peerId.toString()}`)}))}getAddressesWithMetadata(){const e=this.getAnnounceAddrs();if(e.length>0)return this.components.transportManager.getListeners().forEach(s=>{s.updateAnnounceAddrs(e)}),e.map(s=>({multiaddr:s,verified:!0,type:"announce",expires:Date.now()+this.addressVerificationTTL,lastVerified:Date.now()}));let t=[];t=t.concat(this.components.transportManager.getAddrs().map(s=>this.transportAddresses.get(s,this.addressVerificationTTL)));const n=this.getAppendAnnounceAddrs();return n.length>0&&(this.components.transportManager.getListeners().forEach(s=>{s.updateAnnounceAddrs(n)}),t=t.concat(n.map(s=>({multiaddr:s,verified:!0,type:"announce",expires:Date.now()+this.addressVerificationTTL,lastVerified:Date.now()})))),t=t.concat(this.observed.getAll()),t=t.concat(this.ipMappings.getAll(t)),t=t.concat(this.dnsMappings.getAll(t)),t}addDNSMapping(e,t){this.dnsMappings.add(e,t)}removeDNSMapping(e){this.dnsMappings.remove(z(`/dns/${e}`))&&this._updatePeerStoreAddresses()}addPublicAddressMapping(e,t,n,s=t,i="tcp"){this.ipMappings.add(e,t,n,s,i),this.observed.removePrefixed(`/ip${yt(n)?4:6}/${n}/${i}/${s}`)}removePublicAddressMapping(e,t,n,s=t,i="tcp"){this.ipMappings.remove(z(`/ip${yt(n)?4:6}/${n}/${i}/${s}`))&&this._updatePeerStoreAddresses()}maybeUpgradeToIPMapping(e){if(this.ipMappings.has(e)||!he(e))return!1;const t=R(e);if(t.type!=="ip4"||vs(t.host)===!0)return!1;const n=this.components.transportManager.getListeners(),s=[i=>zn.exactMatch(i)||Wr.exactMatch(i),i=>qr.exactMatch(i),i=>xf.exactMatch(i)];for(const i of s){if(!i(e))continue;const o=n.filter(u=>u.getAddrs().filter(d=>R(d).type==="ip4"&&i(d)).length>0);if(o.length!==1)continue;const a=o[0].getAddrs().filter(u=>!Or(u)).pop();if(a==null)continue;const l=R(a);return l.port==null?!1:(this.observed.remove(e),this.ipMappings.add(l.host,l.port,t.host,t.port,t.protocol),!0)}return!1}}var yi;(function(r){r.NOT_STARTED_YET="The libp2p node is not started yet",r.NOT_FOUND="Not found"})(yi||(yi={}));class Bf extends Error{constructor(e="Missing service"){super(e),this.name="MissingServiceError"}}class Uf extends Error{constructor(e="Unmet service dependencies"){super(e),this.name="UnmetServiceDependenciesError"}}class Er extends Error{constructor(e="No content routers available"){super(e),this.name="NoContentRoutersError"}}class wi extends Error{constructor(e="No peer routers available"){super(e),this.name="NoPeerRoutersError"}}class zf extends Error{constructor(e="Should not try to find self"){super(e),this.name="QueriedForSelfError"}}class qf extends Error{constructor(e="Unhandled protocol error"){super(e),this.name="UnhandledProtocolError"}}class Vf extends Error{constructor(e="Duplicate protocol handler error"){super(e),this.name="DuplicateProtocolHandlerError"}}class bi extends Error{constructor(e="Dial denied error"){super(e),this.name="DialDeniedError"}}class Wf extends Error{constructor(e="No transport was configured to listen on this address"){super(e),this.name="UnsupportedListenAddressError"}}class Kf extends Error{constructor(e="Configured listen addresses could not be listened on"){super(e),this.name="UnsupportedListenAddressesError"}}class Gf extends Error{constructor(e="No valid addresses"){super(e),this.name="NoValidAddressesError"}}class Qf extends Error{constructor(e="Connection intercepted"){super(e),this.name="ConnectionInterceptedError"}}class jf extends Error{constructor(e="Connection denied"){super(e),this.name="ConnectionDeniedError"}}class xn extends Error{constructor(e="Stream is not multiplexed"){super(e),this.name="MuxerUnavailableError"}}class un extends Error{constructor(e="Encryption failed"){super(e),this.name="EncryptionFailedError"}}class Hf extends Error{constructor(e="Transport unavailable"){super(e),this.name="TransportUnavailableError"}}class Xf extends Error{constructor(e="Max recursive depth reached"){super(e),this.name="RecursionLimitError"}}class Yf{constructor(e={}){c(this,"components",{});c(this,"_started",!1);this.components={};for(const[t,n]of Object.entries(e))this.components[t]=n;this.components.logger==null&&(this.components.logger=To())}isStarted(){return this._started}async _invokeStartableMethod(e){await Promise.all(Object.values(this.components).filter(t=>Tc(t)).map(async t=>{await t[e]?.()}))}async beforeStart(){await this._invokeStartableMethod("beforeStart")}async start(){await this._invokeStartableMethod("start"),this._started=!0}async afterStart(){await this._invokeStartableMethod("afterStart")}async beforeStop(){await this._invokeStartableMethod("beforeStop")}async stop(){await this._invokeStartableMethod("stop"),this._started=!1}async afterStop(){await this._invokeStartableMethod("afterStop")}}const Jf=["metrics","connectionProtector","dns"],Zf=["components","isStarted","beforeStart","start","afterStart","beforeStop","stop","afterStop","then","_invokeStartableMethod"];function em(r={}){const e=new Yf(r);return new Proxy(e,{get(n,s,i){if(typeof s=="string"&&!Zf.includes(s)){const o=e.components[s];if(o==null&&!Jf.includes(s))throw new Bf(`${s} not set`);return o}return Reflect.get(n,s,i)},set(n,s,i){return typeof s=="string"?e.components[s]=i:Reflect.set(n,s,i),!0}})}function tm(r){const e={};for(const t of Object.values(r.components))for(const n of nm(t))e[n]=!0;for(const t of Object.values(r.components))for(const n of rm(t))if(e[n]!==!0)throw new Uf(`Service "${sm(t)}" required capability "${n}" but it was not provided by any component, you may need to add additional configuration when creating your node.`)}function nm(r){return Array.isArray(r?.[Tr])?r[Tr]:[]}function rm(r){return Array.isArray(r?.[Ms])?r[Ms]:[]}function sm(r){return r?.[Symbol.toStringTag]??r?.toString()??"unknown"}function im(r={}){return r.denyDialMultiaddr==null&&(r.denyDialMultiaddr=e=>zn.matches(e)?!0:Gt(e)),r}class J extends Event{constructor(t,n){super(t);c(this,"type");c(this,"detail");this.type=t,this.detail=n}}function Wa(r){if(Nt(r))return{peerId:r,multiaddrs:[]};let e=Array.isArray(r)?r:[r],t;if(e.length>0){const n=e[0].getComponents().findLast(s=>s.code===C)?.value;t=n==null?void 0:mt(n),e.forEach(s=>{if(!Hn(s))throw new Zr("Invalid multiaddr");const i=s.getComponents().findLast(o=>o.code===C)?.value;if(i==null){if(t!=null)throw new N("Multiaddrs must all have the same peer id or have no peer id")}else{const o=mt(i);if(t?.equals(o)!==!0)throw new N("Multiaddrs must all have the same peer id or have no peer id")}})}return e=e.filter(n=>!Sf.exactMatch(n)),{peerId:t,multiaddrs:e}}const om=["/ipfs/id/1.0.0","/ipfs/id/push/1.0.0","/libp2p/autonat/1.0.0","/libp2p/dcutr"];async function am(r,e){const t=r?.streams?.map(s=>s.protocol)??[],n=e?.closableProtocols??om;if(!(t.filter(s=>s!=null&&!n.includes(s)).length>0))try{await r?.close(e)}catch(s){r?.abort(s)}}function Kr(r){const e=R(r);let t=e.cidr;if(e.type!=="ip4"&&e.type!=="ip6")throw new N(`Multiaddr ${r} was not an IPv4 or IPv6 address`);if(t==null)switch(e.type){case"ip4":{t=32;break}case"ip6":{t=128;break}default:throw new N(`Multiaddr ${r} was not an IPv4 or IPv6 address`)}return new na(e.host,t)}function Ka(r){return!Vn.exactMatch(r)}function Ga(r,e,t){if(r==null||e==null)return;const n=e.sort((i,o)=>i.direct?-1:o.direct?1:0).find(i=>i.limits==null);if(n==null||n.direct||t==null)return n;if(!t.some(i=>Ka(i)))return n}class cm{constructor(e,t={}){c(this,"connectionManager");c(this,"peerStore");c(this,"allow");c(this,"events");c(this,"log");this.allow=(t.allow??[]).map(n=>Kr(n)),this.connectionManager=e.connectionManager,this.peerStore=e.peerStore,this.events=e.events,this.log=e.logger.forComponent("libp2p:connection-manager:connection-pruner"),this.maybePruneConnections=this.maybePruneConnections.bind(this)}start(){this.events.addEventListener("connection:open",this.maybePruneConnections)}stop(){this.events.removeEventListener("connection:open",this.maybePruneConnections)}maybePruneConnections(){this._maybePruneConnections().catch(e=>{this.log.error("error while pruning connections - %e",e)})}async _maybePruneConnections(){const e=this.connectionManager.getConnections(),t=e.length,n=this.connectionManager.getMaxConnections();if(this.log("checking max connections limit %d/%d",t,n),t<=n)return;const s=new en;for(const l of e){const u=l.remotePeer;if(!s.has(u)){s.set(u,0);try{const d=await this.peerStore.get(u);s.set(u,[...d.tags.values()].reduce((h,f)=>h+f.value,0))}catch(d){d.name!=="NotFoundError"&&this.log.error("error loading peer tags - %e",d)}}}const i=this.sortConnections(e,s),o=Math.max(t-n,0),a=[];for(const l of i)if(this.log("too many connections open - closing a connection to %p",l.remotePeer),this.allow.some(d=>{if(he(l.remoteAddr)){const h=R(l.remoteAddr);return d.contains(h.host)}return!0})||a.push(l),a.length===o)break;await Promise.all(a.map(async l=>{await am(l,{signal:AbortSignal.timeout(1e3)})})),this.events.safeDispatchEvent("connection:prune",{detail:a})}sortConnections(e,t){return e.sort((n,s)=>{const i=n.timeline.open,o=s.timeline.open;return i<o?1:i>o?-1:0}).sort((n,s)=>n.direction==="outbound"&&s.direction==="inbound"?1:n.direction==="inbound"&&s.direction==="outbound"?-1:0).sort((n,s)=>n.streams.length>s.streams.length?1:n.streams.length<s.streams.length?-1:0).sort((n,s)=>{const i=t.get(n.remotePeer)??0,o=t.get(s.remotePeer)??0;return i>o?1:i<o?-1:0})}}const Qa=1e4,ja=1e3,lm=1e4,Wn=1e4,Ha=25,um=5,dm=10,hm=5,fm="last-dial-failure",mm="last-dial-success",Xa=500,pm=32,gm=100,Ya=50;function ym(r,e){const t=qr.exactMatch(r.multiaddr),n=qr.exactMatch(e.multiaddr);if(t&&!n)return-1;if(!t&&n)return 1;const s=Wr.exactMatch(r.multiaddr),i=Wr.exactMatch(e.multiaddr);if(s&&!i)return-1;if(!s&&i)return 1;const o=zn.exactMatch(r.multiaddr),a=zn.exactMatch(e.multiaddr);if(o&&!a)return-1;if(!o&&a)return 1;const l=fi.exactMatch(r.multiaddr),u=fi.exactMatch(e.multiaddr);if(l&&!u)return-1;if(!l&&u)return 1;const d=di.exactMatch(r.multiaddr),h=di.exactMatch(e.multiaddr);if(d&&!h)return-1;if(!d&&h)return 1;const f=hi.exactMatch(r.multiaddr),p=hi.exactMatch(e.multiaddr);return f&&!p?-1:!f&&p?1:0}function wm(r,e){const t=Or(r.multiaddr),n=Or(e.multiaddr);return t&&!n?1:!t&&n?-1:0}function bm(r,e){const t=Gt(r.multiaddr),n=Gt(e.multiaddr);return t&&!n?1:!t&&n?-1:0}function vm(r,e){return r.isCertified&&!e.isCertified?-1:!r.isCertified&&e.isCertified?1:0}function Em(r,e){const t=Vn.exactMatch(r.multiaddr),n=Vn.exactMatch(e.multiaddr);return t&&!n?1:!t&&n?-1:0}function Sm(r){return r.sort(ym).sort(vm).sort(Em).sort(bm).sort(wm)}class Ja extends AggregateError{constructor(){super(...arguments);c(this,"name","DNSQueryFailedError")}}c(Ja,"name","DNSQueryFailedError");function Za(r){const e=[Ne.A];return r==null?e:Array.isArray(r)?r.length===0?e:r:[r]}const ec=60;function tc(r){return{Status:r.Status??0,TC:r.TC??r.flag_tc??!1,RD:r.RD??r.flag_rd??!1,RA:r.RA??r.flag_ra??!1,AD:r.AD??r.flag_ad??!1,CD:r.CD??r.flag_cd??!1,Question:(r.Question??r.questions??[]).map(e=>({name:e.name,type:Ne[e.type]})),Answer:(r.Answer??r.answers??[]).map(e=>({name:e.name,type:Ne[e.type],TTL:e.TTL??e.ttl??ec,data:e.data instanceof Uint8Array?Y(e.data):e.data}))}}const _m=4;function vi(r,e={}){const t=new sd({concurrency:e.queryConcurrency??_m});return async(n,s={})=>{const i=s?.logger?.forComponent("dns:dns-json-over-https"),o=new URLSearchParams;o.set("name",n),Za(s.types).forEach(l=>{o.append("type",Ne[l])}),s.onProgress?.(new J("dns:query",n)),i?.("GET %s",`${r}?${o}`);const a=await t.add(async()=>{const l=await fetch(`${r}?${o}`,{headers:{accept:"application/dns-json"},signal:s?.signal});if(i?.("GET %s %d",l.url,l.status),l.status!==200)throw new Error(`Unexpected HTTP status: ${l.status} - ${l.statusText}`);const u=tc(await l.json());return s.onProgress?.(new J("dns:response",u)),u},{signal:s.signal});if(a==null)throw new Error("No DNS response received");return a}}function xm(){return[vi("https://cloudflare-dns.com/dns-query"),vi("https://dns.google/resolve")]}var Cm=function(r){if(!r)throw Error("hashlru must have a max value, of type number, greater than 0");var e=0,t=Object.create(null),n=Object.create(null);function s(i,o){t[i]=o,e++,e>=r&&(e=0,n=t,t=Object.create(null))}return{has:function(i){return t[i]!==void 0||n[i]!==void 0},remove:function(i){t[i]!==void 0&&(t[i]=void 0),n[i]!==void 0&&(n[i]=void 0)},get:function(i){var o=t[i];if(o!==void 0)return o;if((o=n[i])!==void 0)return s(i,o),o},set:function(i,o){t[i]!==void 0?t[i]=o:s(i,o)},clear:function(){t=Object.create(null),n=Object.create(null)}}};const Am=Yi(Cm);class Im{constructor(e){c(this,"lru");this.lru=Am(e)}get(e,t){let n=!0;const s=[];for(const i of t){const o=this.getAnswers(e,i);if(o.length===0){n=!1;break}s.push(...o)}if(n)return tc({answers:s})}getAnswers(e,t){const n=`${e.toLowerCase()}-${t}`,s=this.lru.get(n);if(s!=null){const i=s.filter(o=>o.expires>Date.now()).map(({expires:o,value:a})=>({...a,TTL:Math.round((o-Date.now())/1e3),type:Ne[a.type]}));return i.length===0&&this.lru.remove(n),i}return[]}add(e,t){const n=`${e.toLowerCase()}-${t.type}`,s=this.lru.get(n)??[];s.push({expires:Date.now()+(t.TTL??ec)*1e3,value:t}),this.lru.set(n,s)}remove(e,t){const n=`${e.toLowerCase()}-${t}`;this.lru.remove(n)}clear(){this.lru.clear()}}function Tm(r){return new Im(r)}const Lm=1e3;class Pm{constructor(e){c(this,"resolvers");c(this,"cache");c(this,"logger");this.resolvers={},this.cache=Tm(e.cacheSize??Lm),this.logger=e.logger,Object.entries(e.resolvers??{}).forEach(([t,n])=>{Array.isArray(n)||(n=[n]),t.endsWith(".")||(t=`${t}.`),this.resolvers[t]=n}),this.resolvers["."]==null&&(this.resolvers["."]=xm())}async query(e,t={}){const n=Za(t.types),s=t.cached!==!1?this.cache.get(e,n):void 0;if(s!=null)return t.onProgress?.(new J("dns:cache",s)),s;const i=`${e.split(".").pop()}.`,o=(this.resolvers[i]??this.resolvers["."]).sort(()=>Math.random()>.5?-1:1),a=[];for(const l of o){if(t.signal?.aborted===!0)break;try{const u=await l(e,{...t,logger:this.logger,types:n});for(const d of u.Answer)this.cache.add(e,d);return u}catch(u){a.push(u),t.onProgress?.(new J("dns:error",u))}}throw new Ja(a,`DNS lookup of ${e} ${n} failed`)}}var Ne;(function(r){r[r.A=1]="A",r[r.CNAME=5]="CNAME",r[r.TXT=16]="TXT",r[r.AAAA=28]="AAAA"})(Ne||(Ne={}));function km(r={}){return new Pm(r)}class Dm{constructor(){c(this,"dns")}canResolve(e){return e.getComponents().some(({name:t})=>t==="dnsaddr")}async resolve(e,t){const n=e.getComponents().find(l=>l.name==="dnsaddr")?.value;if(n==null)return[e];const i=await this.getDNS(t).query(`_dnsaddr.${n}`,{signal:t?.signal,types:[Ne.TXT]}),o=e.getComponents().find(l=>l.name==="p2p")?.value,a=[];for(const l of i.Answer){const u=l.data.replace(/["']/g,"").trim().split("=")[1];u!=null&&(o!=null&&!u.includes(o)||a.push(z(u)))}return a}getDNS(e){return e.dns!=null?e.dns:(this.dns==null&&(this.dns=km()),this.dns)}}const nc=new Dm;async function rc(r,e,t){const n=t.depth??0;if(n>(t.maxRecursiveDepth??pm))throw new Xf("Max recursive depth reached");let s=!1;const i=[];for(const o of Object.values(e))if(o.canResolve(r)){s=!0;const a=await o.resolve(r,t);for(const l of a)i.push(...await rc(l,e,{...t,depth:n+1}))}return s===!1&&i.push(r),i}const Pt={maxParallelDials:Ya,maxDialQueueLength:Xa,maxPeerAddrsToDial:Ha,dialTimeout:Qa,resolvers:{dnsaddr:nc}};class Mm{constructor(e,t={}){c(this,"queue");c(this,"components");c(this,"addressSorter");c(this,"maxPeerAddrsToDial");c(this,"maxDialQueueLength");c(this,"dialTimeout");c(this,"shutDownController");c(this,"connections");c(this,"log");c(this,"resolvers");this.addressSorter=t.addressSorter,this.maxPeerAddrsToDial=t.maxPeerAddrsToDial??Pt.maxPeerAddrsToDial,this.maxDialQueueLength=t.maxDialQueueLength??Pt.maxDialQueueLength,this.dialTimeout=t.dialTimeout??Pt.dialTimeout,this.connections=t.connections??new en,this.log=e.logger.forComponent("libp2p:connection-manager:dial-queue"),this.components=e,this.resolvers=t.resolvers??Pt.resolvers,this.shutDownController=new AbortController,pe(1/0,this.shutDownController.signal),this.queue=new Ch({concurrency:t.maxParallelDials??Pt.maxParallelDials,metricName:"libp2p_dial_queue",metrics:e.metrics}),this.queue.addEventListener("failure",n=>{n.detail?.error.name!==Ot.name&&this.log.error("error in dial queue - %e",n.detail.error)})}start(){this.shutDownController=new AbortController,pe(1/0,this.shutDownController.signal)}stop(){this.shutDownController.abort(),this.queue.abort()}async dial(e,t={}){const{peerId:n,multiaddrs:s}=Wa(e);if(n!=null&&t.force!==!0){const o=Ga(n,this.connections.get(n),s);if(o!=null)return this.log("already connected to %a",o.remoteAddr),t.onProgress?.(new J("dial-queue:already-connected")),o}const i=this.queue.queue.find(o=>{if(n?.equals(o.options.peerId)===!0)return!0;const a=o.options.multiaddrs;if(a==null)return!1;for(const l of s)if(a.has(l.toString()))return!0;return!1});if(i!=null){this.log("joining existing dial target for %p",n);for(const o of s)i.options.multiaddrs.add(o.toString());return t.onProgress?.(new J("dial-queue:already-in-dial-queue")),i.join(t)}if(this.queue.size>=this.maxDialQueueLength)throw new or("Dial queue is full");return this.log("creating dial target for %p",n,s.map(o=>o.toString())),t.onProgress?.(new J("dial-queue:add-to-dial-queue")),this.queue.add(async o=>{o.onProgress?.(new J("dial-queue:start-dial"));const a=wt([this.shutDownController.signal,o.signal]);try{return await this.dialPeer(o,a)}finally{a.clear()}},{peerId:n,priority:t.priority??sc,multiaddrs:new Set(s.map(o=>o.toString())),signal:t.signal??AbortSignal.timeout(this.dialTimeout),onProgress:t.onProgress})}async dialPeer(e,t){const n=e.peerId,s=e.multiaddrs,i=new Set;let o=e.multiaddrs.size===0,a=0,l=0;const u=[];for(this.log("starting dial to %p",n);o||s.size>0;){l++,o=!1;const d=[],h=new Set(e.multiaddrs);s.clear(),this.log("calculating addrs to dial %p from %s",n,[...h]);const f=await this.calculateMultiaddrs(n,h,{...e,signal:t});for(const p of f){if(i.has(p.multiaddr.toString())){this.log.trace("skipping previously failed multiaddr %a while dialing %p",p.multiaddr,n);continue}d.push(p)}this.log("%s dial to %p with %s",l===1?"starting":"continuing",n,d.map(p=>p.multiaddr.toString())),e?.onProgress?.(new J("dial-queue:calculated-addresses",d));for(const p of d){if(a===this.maxPeerAddrsToDial)throw this.log("dialed maxPeerAddrsToDial (%d) addresses for %p, not trying any others",a,e.peerId),new or("Peer had more than maxPeerAddrsToDial");a++;try{const b=await this.components.transportManager.dial(p.multiaddr,{...e,signal:t});this.log("dial to %a succeeded",p.multiaddr);try{await this.components.peerStore.merge(b.remotePeer,{multiaddrs:[b.remoteAddr],metadata:{[mm]:F(Date.now().toString())}})}catch(x){this.log.error("could not update last dial failure key for %p - %e",n,x)}return b}catch(b){if(this.log.error("dial failed to %a - %e",p.multiaddr,b),i.add(p.multiaddr.toString()),n!=null)try{await this.components.peerStore.merge(n,{metadata:{[fm]:F(Date.now().toString())}})}catch(x){this.log.error("could not update last dial failure key for %p - %e",n,x)}if(t.aborted)throw new Lc(b.message);u.push(b)}}}throw u.length===1?u[0]:new AggregateError(u,"All multiaddr dials failed")}async calculateMultiaddrs(e,t=new Set,n={}){const s=[...t].map(h=>({multiaddr:z(h),isCertified:!1}));if(e!=null){if(this.components.peerId.equals(e))throw new or("Tried to dial self");if(await this.components.connectionGater.denyDialPeer?.(e)===!0)throw new bi("The dial request is blocked by gater.allowDialPeer");if(s.length===0){this.log("loading multiaddrs for %p",e);try{const h=await this.components.peerStore.get(e);s.push(...h.addresses),this.log("loaded multiaddrs for %p",e,s.map(({multiaddr:f})=>f.toString()))}catch(h){if(h.name!=="NotFoundError")throw h}}if(s.length===0){this.log("looking up multiaddrs for %p in the peer routing",e);try{const h=await this.components.peerRouting.findPeer(e,n);this.log("found multiaddrs for %p in the peer routing",e,s.map(({multiaddr:f})=>f.toString())),s.push(...h.multiaddrs.map(f=>({multiaddr:f,isCertified:!1})))}catch(h){h.name==="NoPeerRoutersError"?this.log("no peer routers configured",e):this.log.error("looking up multiaddrs for %p in the peer routing failed - %e",e,h)}}}let i=(await Promise.all(s.map(async h=>{const f=await rc(h.multiaddr,this.resolvers,{dns:this.components.dns,log:this.log,...n});return f.length===1&&f[0].equals(h.multiaddr)?h:f.map(p=>({multiaddr:p,isCertified:!1}))}))).flat();if(e!=null){const h=`/p2p/${e.toString()}`;i=i.map(f=>f.multiaddr.getComponents().pop()?.name!=="p2p"?{multiaddr:f.multiaddr.encapsulate(h),isCertified:f.isCertified}:f)}const o=i.filter(h=>{if(this.components.transportManager.dialTransportForMultiaddr(h.multiaddr)==null)return!1;const f=h.multiaddr.getComponents().findLast(p=>p.code===C)?.value;return e!=null&&f!=null?e.equals(f):!0}),a=new Map;for(const h of o){const f=h.multiaddr.toString(),p=a.get(f);if(p!=null){p.isCertified=p.isCertified||h.isCertified||!1;continue}a.set(f,h)}const l=[...a.values()];if(l.length===0)throw new Gf("The dial request has no valid addresses");const u=[];for(const h of l)this.components.connectionGater.denyDialMultiaddr!=null&&await this.components.connectionGater.denyDialMultiaddr(h.multiaddr)||u.push(h);const d=this.addressSorter==null?Sm(u):u.sort(this.addressSorter);if(d.length===0)throw new bi("The connection gater denied all addresses in the dial request");return this.log.trace("addresses for %p before filtering",e??"unknown peer",i.map(({multiaddr:h})=>h.toString())),this.log.trace("addresses for %p after filtering",e??"unknown peer",d.map(({multiaddr:h})=>h.toString())),d}async isDialable(e,t={}){Array.isArray(e)||(e=[e]);try{const n=await this.calculateMultiaddrs(void 0,new Set(e.map(s=>s.toString())),t);return t.runOnLimitedConnection===!1?n.find(s=>!Vn.matches(s.multiaddr))!=null:!0}catch{}return!1}}const Nm=Object.prototype.toString,Fm=r=>Nm.call(r)==="[object Error]",Rm=new Set(["network error","Failed to fetch","NetworkError when attempting to fetch resource.","The Internet connection appears to be offline.","Network request failed","fetch failed","terminated"," A network error occurred.","Network connection lost"]);function $m(r){if(!(r&&Fm(r)&&r.name==="TypeError"&&typeof r.message=="string"))return!1;const{message:t,stack:n}=r;return t==="Load failed"?n===void 0||"__sentry_captured__"in r:t.startsWith("error sending request for url")?!0:Rm.has(t)}function Om(r){if(typeof r=="number"){if(r<0)throw new TypeError("Expected `retries` to be a non-negative number.");if(Number.isNaN(r))throw new TypeError("Expected `retries` to be a valid number or Infinity, got NaN.")}else if(r!==void 0)throw new TypeError("Expected `retries` to be a number or Infinity.")}function dn(r,e,{min:t=0,allowInfinity:n=!1}={}){if(e!==void 0){if(typeof e!="number"||Number.isNaN(e))throw new TypeError(`Expected \`${r}\` to be a number${n?" or Infinity":""}.`);if(!n&&!Number.isFinite(e))throw new TypeError(`Expected \`${r}\` to be a finite number.`);if(e<t)throw new TypeError(`Expected \`${r}\` to be  ${t}.`)}}class Bm extends Error{constructor(e){super(),e instanceof Error?(this.originalError=e,{message:e}=e):(this.originalError=new Error(e),this.originalError.stack=this.stack),this.name="AbortError",this.message=e}}function Um(r,e){const t=Math.max(1,r+1),n=e.randomize?Math.random()+1:1;let s=Math.round(n*e.minTimeout*e.factor**(t-1));return s=Math.min(s,e.maxTimeout),s}function Ei(r,e){return Number.isFinite(e)?e-(performance.now()-r):e}async function zm({error:r,attemptNumber:e,retriesConsumed:t,startTime:n,options:s}){const i=r instanceof Error?r:new TypeError(`Non-error was thrown: "${r}". You should only throw errors.`);if(i instanceof Bm)throw i.originalError;const o=Number.isFinite(s.retries)?Math.max(0,s.retries-t):s.retries,a=s.maxRetryTime??Number.POSITIVE_INFINITY,l=Object.freeze({error:i,attemptNumber:e,retriesLeft:o,retriesConsumed:t});if(await s.onFailedAttempt(l),Ei(n,a)<=0)throw i;const u=await s.shouldConsumeRetry(l),d=Ei(n,a);if(d<=0||o<=0)throw i;if(i instanceof TypeError&&!$m(i)){if(u)throw i;return s.signal?.throwIfAborted(),!1}if(!await s.shouldRetry(l))throw i;if(!u)return s.signal?.throwIfAborted(),!1;const h=Um(t,s),f=Math.min(h,d);return s.signal?.throwIfAborted(),f>0&&await new Promise((p,b)=>{const x=()=>{clearTimeout(y),s.signal?.removeEventListener("abort",x),b(s.signal.reason)},y=setTimeout(()=>{s.signal?.removeEventListener("abort",x),p()},f);s.unref&&y.unref?.(),s.signal?.addEventListener("abort",x,{once:!0})}),s.signal?.throwIfAborted(),!0}async function qm(r,e={}){if(e={...e},Om(e.retries),Object.hasOwn(e,"forever"))throw new Error("The `forever` option is no longer supported. For many use-cases, you can set `retries: Infinity` instead.");e.retries??(e.retries=10),e.factor??(e.factor=2),e.minTimeout??(e.minTimeout=1e3),e.maxTimeout??(e.maxTimeout=Number.POSITIVE_INFINITY),e.maxRetryTime??(e.maxRetryTime=Number.POSITIVE_INFINITY),e.randomize??(e.randomize=!1),e.onFailedAttempt??(e.onFailedAttempt=()=>{}),e.shouldRetry??(e.shouldRetry=()=>!0),e.shouldConsumeRetry??(e.shouldConsumeRetry=()=>!0),dn("factor",e.factor,{min:0,allowInfinity:!1}),dn("minTimeout",e.minTimeout,{min:0,allowInfinity:!1}),dn("maxTimeout",e.maxTimeout,{min:0,allowInfinity:!0}),dn("maxRetryTime",e.maxRetryTime,{min:0,allowInfinity:!0}),e.factor>0||(e.factor=1),e.signal?.throwIfAborted();let t=0,n=0;const s=performance.now();for(;!Number.isFinite(e.retries)||n<=e.retries;){t++;try{e.signal?.throwIfAborted();const i=await r(t);return e.signal?.throwIfAborted(),i}catch(i){await zm({error:i,attemptNumber:t,retriesConsumed:n,startTime:s,options:e})&&n++}}throw new Error("Retry attempts exhausted without throwing an error.")}class Vm{constructor(e,t={}){c(this,"log");c(this,"queue");c(this,"started");c(this,"peerStore");c(this,"retries");c(this,"retryInterval");c(this,"backoffFactor");c(this,"connectionManager");c(this,"events");this.log=e.logger.forComponent("libp2p:reconnect-queue"),this.peerStore=e.peerStore,this.connectionManager=e.connectionManager,this.queue=new xh({concurrency:t.maxParallelReconnects??hm,metricName:"libp2p_reconnect_queue",metrics:e.metrics}),this.started=!1,this.retries=t.retries??5,this.backoffFactor=t.backoffFactor,this.retryInterval=t.retryInterval,this.events=e.events,e.events.addEventListener("peer:disconnect",n=>{this.maybeReconnect(n.detail).catch(s=>{this.log.error("failed to maybe reconnect to %p - %e",n.detail,s)})})}async maybeReconnect(e){if(!this.started)return;const t=await this.peerStore.get(e);Si(t)&&(this.queue.has(e)||this.queue.add(async n=>{await qm(async s=>{if(this.started)try{await this.connectionManager.openConnection(e,{signal:n?.signal})}catch(i){throw this.log("reconnecting to %p attempt %d of %d failed - %e",e,s,this.retries,i),i}},{signal:n?.signal,retries:this.retries,factor:this.backoffFactor,minTimeout:this.retryInterval})},{peerId:e}).catch(async n=>{this.log.error("failed to reconnect to %p - %e",e,n);const s={};[...t.tags.keys()].forEach(i=>{i.startsWith(ji)&&(s[i]=void 0)}),await this.peerStore.merge(e,{tags:s}),this.events.safeDispatchEvent("peer:reconnect-failure",{detail:e})}).catch(async n=>{this.log.error("failed to remove keep-alive tag from %p - %e",e,n)}))}start(){this.started=!0}async afterStart(){Promise.resolve().then(async()=>{const e=await this.peerStore.all({filters:[t=>Si(t)]});await Promise.all(e.map(async t=>{await this.connectionManager.openConnection(t.id).catch(n=>{this.log.error("could not open connection to keepalive peer - %e",n)})}))}).catch(e=>{this.log.error("error reconnect to peers after start - %e",e)})}stop(){this.started=!1,this.queue.abort()}}function Si(r){for(const e of r.tags.keys())if(e.startsWith(ji))return!0;return!1}const sc=50,Sr={maxConnections:gm,inboundConnectionThreshold:um,maxIncomingPendingConnections:dm};var Di;Di=Symbol.toStringTag;class Wm{constructor(e,t={}){c(this,"started");c(this,"connections");c(this,"allow");c(this,"deny");c(this,"maxIncomingPendingConnections");c(this,"incomingPendingConnections");c(this,"outboundPendingConnections");c(this,"maxConnections");c(this,"dialQueue");c(this,"reconnectQueue");c(this,"connectionPruner");c(this,"inboundConnectionRateLimiter");c(this,"peerStore");c(this,"metrics");c(this,"events");c(this,"log");c(this,"peerId");c(this,Di,"@libp2p/connection-manager");if(this.maxConnections=t.maxConnections??Sr.maxConnections,this.maxConnections<1)throw new N("Connection Manager maxConnections must be greater than 0");this.connections=new en,this.started=!1,this.peerId=e.peerId,this.peerStore=e.peerStore,this.metrics=e.metrics,this.events=e.events,this.log=e.logger.forComponent("libp2p:connection-manager"),this.onConnect=this.onConnect.bind(this),this.onDisconnect=this.onDisconnect.bind(this),this.allow=(t.allow??[]).map(n=>Kr(z(n))),this.deny=(t.deny??[]).map(n=>Kr(z(n))),this.incomingPendingConnections=0,this.maxIncomingPendingConnections=t.maxIncomingPendingConnections??Sr.maxIncomingPendingConnections,this.outboundPendingConnections=0,this.inboundConnectionRateLimiter=new Ah({points:t.inboundConnectionThreshold??Sr.inboundConnectionThreshold,duration:1}),this.connectionPruner=new cm({connectionManager:this,peerStore:e.peerStore,events:e.events,logger:e.logger},{allow:t.allow?.map(n=>z(n))}),this.dialQueue=new Mm(e,{addressSorter:t.addressSorter,maxParallelDials:t.maxParallelDials??Ya,maxDialQueueLength:t.maxDialQueueLength??Xa,maxPeerAddrsToDial:t.maxPeerAddrsToDial??Ha,dialTimeout:t.dialTimeout??Qa,resolvers:t.resolvers??{dnsaddr:nc},connections:this.connections}),this.reconnectQueue=new Vm({events:e.events,peerStore:e.peerStore,logger:e.logger,connectionManager:this},{retries:t.reconnectRetries,retryInterval:t.reconnectRetryInterval,backoffFactor:t.reconnectBackoffFactor,maxParallelReconnects:t.maxParallelReconnects})}async start(){this.metrics?.registerMetricGroup("libp2p_connection_manager_connections",{calculate:()=>{const e={inbound:0,"inbound pending":this.incomingPendingConnections,outbound:0,"outbound pending":this.outboundPendingConnections};for(const t of this.connections.values())for(const n of t)e[n.direction]++;return e}}),this.metrics?.registerMetricGroup("libp2p_protocol_streams_total",{label:"protocol",calculate:()=>{const e={};for(const t of this.connections.values())for(const n of t)for(const s of n.streams){const i=`${s.direction} ${s.protocol??"unnegotiated"}`;e[i]=(e[i]??0)+1}return e}}),this.metrics?.registerMetricGroup("libp2p_connection_manager_protocol_streams_per_connection_90th_percentile",{label:"protocol",calculate:()=>{const e={};for(const n of this.connections.values())for(const s of n){const i={};for(const o of s.streams){const a=`${o.direction} ${o.protocol??"unnegotiated"}`;i[a]=(i[a]??0)+1}for(const[o,a]of Object.entries(i))e[o]=e[o]??[],e[o].push(a)}const t={};for(let[n,s]of Object.entries(e)){s=s.sort((o,a)=>o-a);const i=Math.floor(s.length*.9);t[n]=s[i]}return t}}),this.events.addEventListener("connection:open",this.onConnect),this.events.addEventListener("connection:close",this.onDisconnect),await Pc(this.dialQueue,this.reconnectQueue,this.connectionPruner),this.started=!0,this.log("started")}async stop(){this.events.removeEventListener("connection:open",this.onConnect),this.events.removeEventListener("connection:close",this.onDisconnect),await kc(this.reconnectQueue,this.dialQueue,this.connectionPruner);const e=[];for(const t of this.connections.values())for(const n of t)e.push(Promise.all([oe(n,"close",{signal:AbortSignal.timeout(500)}),n.close({signal:AbortSignal.timeout(500)})]).catch(s=>{n.abort(s)}));this.log("closing %d connections",e.length),await Promise.all(e),this.connections.clear(),this.log("stopped")}getMaxConnections(){return this.maxConnections}setMaxConnections(e){if(this.maxConnections<1)throw new N("Connection Manager maxConnections must be greater than 0");let t=!1;e<this.maxConnections&&(t=!0),this.maxConnections=e,t&&this.connectionPruner.maybePruneConnections()}onConnect(e){this._onConnect(e).catch(t=>{this.log.error("could not connect - %e",t)})}async _onConnect(e){const{detail:t}=e;if(!this.started){await t.close();return}if(t.status!=="open")return;const n=t.remotePeer,s=!this.connections.has(n),i=this.connections.get(n)??[];i.push(t),this.connections.set(n,i),n.publicKey!=null&&n.type==="RSA"&&await this.peerStore.patch(n,{publicKey:n.publicKey}),s&&this.events.safeDispatchEvent("peer:connect",{detail:t.remotePeer})}onDisconnect(e){const{detail:t}=e,n=t.remotePeer,i=(this.connections.get(n)??[]).filter(o=>o.id!==t.id);this.connections.set(n,i),i.length===0&&(this.log.trace("peer %p disconnected, removing connection map entry",n),this.connections.delete(n),this.events.safeDispatchEvent("peer:disconnect",{detail:n}))}getConnections(e){if(e!=null)return this.connections.get(e)??[];let t=[];for(const n of this.connections.values())t=t.concat(n);return t}getConnectionsMap(){return this.connections}async openConnection(e,t={}){if(!this.started)throw new Cn("Not started");this.outboundPendingConnections++;try{t.signal?.throwIfAborted();const{peerId:n,multiaddrs:s}=Wa(e);if(this.peerId.equals(n))throw new Hi("Can not dial self");if(n!=null&&t.force!==!0){this.log("dial %p",n);const l=Ga(n,this.getConnections(n),s);if(l!=null)return this.log("had an existing connection to %p as %a",n,l.remoteAddr),t.onProgress?.(new J("dial-queue:already-connected")),l}const i=await this.dialQueue.dial(e,{...t,priority:t.priority??sc});if(i.status!=="open")throw new Lr("Remote closed connection during opening");let o=this.connections.get(i.remotePeer);o==null&&(o=[],this.connections.set(i.remotePeer,o));let a=!1;for(const l of o)if(l.id===i.id&&(a=!0),t.force!==!0&&l.id!==i.id&&l.remoteAddr.equals(i.remoteAddr))return i.abort(new Zr("Duplicate multiaddr connection")),l;return a||o.push(i),i}finally{this.outboundPendingConnections--}}async openStream(e,t,n={}){return(await this.openConnection(e,n)).newStream(t,n)}async closeConnections(e,t={}){const n=this.connections.get(e)??[];await Promise.all(n.map(async s=>{try{await Promise.all([oe(s,"close",t),s.close(t)])}catch(i){s.abort(i)}}))}acceptIncomingConnection(e){if(this.deny.some(s=>{if(he(e.remoteAddr)){const i=R(e.remoteAddr);return s.contains(i.host)}return!1}))return this.log("connection from %a refused - connection remote address was in deny list",e.remoteAddr),!1;if(this.allow.some(s=>{if(he(e.remoteAddr)){const i=R(e.remoteAddr);return s.contains(i.host)}return!0}))return this.incomingPendingConnections++,!0;if(this.incomingPendingConnections===this.maxIncomingPendingConnections)return this.log("connection from %a refused - incomingPendingConnections exceeded by host",e.remoteAddr),!1;if(he(e.remoteAddr)){const s=R(e.remoteAddr);try{this.inboundConnectionRateLimiter.consume(s.host,1)}catch{return this.log("connection from %a refused - inboundConnectionThreshold exceeded by host %s",e.remoteAddr,s.host),!1}}return this.getConnections().length<this.maxConnections?(this.incomingPendingConnections++,!0):(this.log("connection from %a refused - maxConnections exceeded",e.remoteAddr),!1)}afterUpgradeInbound(){this.incomingPendingConnections--}getDialQueue(){const e={queued:"queued",running:"active",errored:"error",complete:"success"};return this.dialQueue.queue.queue.map(t=>({id:t.id,status:e[t.status],peerId:t.options.peerId,multiaddrs:[...t.options.multiaddrs].map(n=>z(n))}))}async isDialable(e,t={}){return this.dialQueue.isDialable(e,t)}}const Km=1e4,Gm="1.0.0",Qm="ping",jm="ipfs",_i=32,Hm=!0;var Mi,Ni;Ni=Symbol.toStringTag,Mi=Tr;class Xm{constructor(e,t={}){c(this,"protocol");c(this,"components");c(this,"log");c(this,"heartbeatInterval");c(this,"pingIntervalMs");c(this,"abortController");c(this,"timeout");c(this,"abortConnectionOnPingFailure");c(this,Ni,"@libp2p/connection-monitor");c(this,Mi,["@libp2p/connection-monitor"]);this.components=e,this.protocol=`/${t.protocolPrefix??jm}/${Qm}/${Gm}`,this.log=e.logger.forComponent("libp2p:connection-monitor"),this.pingIntervalMs=t.pingInterval??Km,this.abortConnectionOnPingFailure=t.abortConnectionOnPingFailure??Hm,this.timeout=new Yd({...t.pingTimeout??{},metrics:e.metrics,metricName:"libp2p_connection_monitor_ping_time_milliseconds"})}start(){this.abortController=new AbortController,pe(1/0,this.abortController.signal),this.heartbeatInterval=setInterval(()=>{this.components.connectionManager.getConnections().forEach(e=>{Promise.resolve().then(async()=>{let t=Date.now();try{const n=this.timeout.getTimeoutSignal({signal:this.abortController?.signal}),s=await e.newStream(this.protocol,{signal:n,runOnLimitedConnection:!0}),i=da(s);t=Date.now(),await Promise.all([i.write(Xi(_i),{signal:n}),i.read({bytes:_i,signal:n})]),e.rtt=Date.now()-t,await s.close({signal:n})}catch(n){if(n.name!=="UnsupportedProtocolError")throw n;e.rtt=(Date.now()-t)/2}}).catch(t=>{this.log.error("error during heartbeat - %e",t),this.abortConnectionOnPingFailure?(this.log.error("aborting connection due to ping failure"),e.abort(t)):this.log("connection ping failed, but not aborting due to abortConnectionOnPingFailure flag")})})},this.pingIntervalMs)}stop(){this.abortController?.abort(),this.heartbeatInterval!=null&&clearInterval(this.heartbeatInterval)}}var Fi;Fi=Symbol.toStringTag;class Ym{constructor(e,t){c(this,"routers");c(this,"started");c(this,"components");c(this,Fi,"@libp2p/content-routing");this.routers=t.routers??[],this.started=!1,this.components=e,this.findProviders=e.metrics?.traceFunction("libp2p.contentRouting.findProviders",this.findProviders.bind(this),{optionsIndex:1,getAttributesFromArgs:([n],s)=>({...s,cid:n.toString()}),getAttributesFromYieldedValue:(n,s)=>({...s,providers:[...Array.isArray(s.providers)?s.providers:[],n.id.toString()]})})??this.findProviders,this.provide=e.metrics?.traceFunction("libp2p.contentRouting.provide",this.provide.bind(this),{optionsIndex:1,getAttributesFromArgs:([n],s)=>({...s,cid:n.toString()})})??this.provide,this.cancelReprovide=e.metrics?.traceFunction("libp2p.contentRouting.cancelReprovide",this.cancelReprovide.bind(this),{optionsIndex:1,getAttributesFromArgs:([n],s)=>({...s,cid:n.toString()})})??this.cancelReprovide,this.put=e.metrics?.traceFunction("libp2p.contentRouting.put",this.put.bind(this),{optionsIndex:2,getAttributesFromArgs:([n])=>({key:Y(n,"base36")})})??this.put,this.get=e.metrics?.traceFunction("libp2p.contentRouting.get",this.get.bind(this),{optionsIndex:1,getAttributesFromArgs:([n])=>({key:Y(n,"base36")})})??this.get}isStarted(){return this.started}async start(){this.started=!0}async stop(){this.started=!1}async*findProviders(e,t={}){if(this.routers.length===0)throw new Er("No content routers available");const n=this,s=new at;for await(const i of Fn(...n.routers.filter(o=>o.findProviders instanceof Function).map(o=>o.findProviders(e,t))))i!=null&&(i.multiaddrs.length>0&&await this.components.peerStore.merge(i.id,{multiaddrs:i.multiaddrs},t),!s.has(i.id)&&(s.add(i.id),yield i))}async provide(e,t={}){if(this.routers.length===0)throw new Er("No content routers available");await Promise.all(this.routers.filter(n=>n.provide instanceof Function).map(async n=>{await n.provide(e,t)}))}async cancelReprovide(e,t={}){if(this.routers.length===0)throw new Er("No content routers available");await Promise.all(this.routers.filter(n=>n.cancelReprovide instanceof Function).map(async n=>{await n.cancelReprovide(e,t)}))}async put(e,t,n){if(!this.isStarted())throw new Cn;await Promise.all(this.routers.filter(s=>s.put instanceof Function).map(async s=>{await s.put(e,t,n)}))}async get(e,t){if(!this.isStarted())throw new Cn;return Promise.any(this.routers.filter(n=>n.get instanceof Function).map(async n=>n.get(e,t)))}}const hn=globalThis.CustomEvent??Event;async function*Jm(r,e={}){let t=e.concurrency??1/0;t<1&&(t=1/0);const n=e.ordered??!1,s=new EventTarget,i=[];let o=se(),a=se(),l=!1,u,d=!1;s.addEventListener("task-complete",()=>{a.resolve()}),Promise.resolve().then(async()=>{try{for await(const b of r){if(i.length===t&&(o=se(),await o.promise),d)break;const x={done:!1};i.push(x),b().then(y=>{x.done=!0,x.ok=!0,x.value=y,s.dispatchEvent(new hn("task-complete"))},y=>{x.done=!0,x.err=y,s.dispatchEvent(new hn("task-complete"))})}l=!0,s.dispatchEvent(new hn("task-complete"))}catch(b){u=b,s.dispatchEvent(new hn("task-complete"))}});function h(){return n?i[0]?.done:!!i.find(b=>b.done)}function*f(){for(;i.length>0&&i[0].done;){const b=i[0];if(i.shift(),b.ok)yield b.value;else throw d=!0,o.resolve(),b.err;o.resolve()}}function*p(){for(;h();)for(let b=0;b<i.length;b++)if(i[b].done){const x=i[b];if(i.splice(b,1),b--,x.ok)yield x.value;else throw d=!0,o.resolve(),x.err;o.resolve()}}for(;;){if(h()||(a=se(),await a.promise),u!=null||(n?yield*f():yield*p(),u!=null))throw u;if(l&&i.length===0)break}}var Ri;Ri=Symbol.toStringTag;class Zm{constructor(e,t={}){c(this,"log");c(this,"peerId");c(this,"peerStore");c(this,"routers");c(this,Ri,"@libp2p/peer-routing");this.log=e.logger.forComponent("libp2p:peer-routing"),this.peerId=e.peerId,this.peerStore=e.peerStore,this.routers=t.routers??[],this.findPeer=e.metrics?.traceFunction("libp2p.peerRouting.findPeer",this.findPeer.bind(this),{optionsIndex:1,getAttributesFromArgs:([n],s)=>({...s,peer:n.toString()})})??this.findPeer,this.getClosestPeers=e.metrics?.traceFunction("libp2p.peerRouting.getClosestPeers",this.getClosestPeers.bind(this),{optionsIndex:1,getAttributesFromArgs:([n],s)=>({...s,key:Y(n,"base36")}),getAttributesFromYieldedValue:(n,s)=>({...s,peers:[...Array.isArray(s.peers)?s.peers:[],n.id.toString()]})})??this.getClosestPeers}async findPeer(e,t){if(this.routers.length===0)throw new wi("No peer routers available");if(e.toString()===this.peerId.toString())throw new zf("Should not try to find self");const n=this,s=Fn(...this.routers.filter(i=>i.findPeer instanceof Function).map(i=>async function*(){try{yield await i.findPeer(e,t)}catch(o){n.log.error("router failed to find peer - %e",o)}}()));for await(const i of s)if(i!=null)return i.multiaddrs.length>0&&await this.peerStore.merge(i.id,{multiaddrs:i.multiaddrs},t),i;throw new Ir}async*getClosestPeers(e,t={}){if(this.routers.length===0)throw new wi("No peer routers available");const n=this,s=ws(1024);for await(const i of Jm(async function*(){const o=Fn(...n.routers.filter(a=>a.getClosestPeers instanceof Function).map(a=>a.getClosestPeers(e,t)));for await(let a of o)yield async()=>{if(a.multiaddrs.length===0)try{a=await n.findPeer(a.id,{...t,useCache:!1})}catch(l){n.log.error("could not find peer multiaddrs - %e",l);return}return a}}()))i!=null&&(i.multiaddrs.length>0&&await this.peerStore.merge(i.id,{multiaddrs:i.multiaddrs},t),!s.has(i.id.toMultihash().bytes)&&(s.add(i.id.toMultihash().bytes),yield i))}}var $i,Oi;class ep extends(Oi=_e,$i=Symbol.toStringTag,Oi){constructor(t){super();c(this,"peerRouting");c(this,"log");c(this,"walking");c(this,"walkers");c(this,"shutdownController");c(this,"walkController");c(this,"needNext");c(this,$i,"@libp2p/random-walk");this.log=t.logger.forComponent("libp2p:random-walk"),this.peerRouting=t.peerRouting,this.walkers=0,this.walking=!1,this.shutdownController=new AbortController,pe(1/0,this.shutdownController.signal)}start(){this.shutdownController=new AbortController,pe(1/0,this.shutdownController.signal)}stop(){this.shutdownController.abort()}async*walk(t){this.walking||this.startWalk(),this.walkers++;const n=wt([this.shutdownController.signal,t?.signal]);try{for(;;)this.needNext?.resolve(),this.needNext=se(),yield(await oe(this,"walk:peer",{signal:n,rejectionEvents:["walk:error"]})).detail}catch(s){throw s.detail!=null?s.detail:s}finally{n.clear(),this.walkers--,this.walkers===0&&(this.walkController?.abort(),this.walkController=void 0)}}startWalk(){this.walking=!0,this.walkController=new AbortController,pe(1/0,this.walkController.signal);const t=wt([this.walkController.signal,this.shutdownController.signal]),n=Date.now();let s=0;Promise.resolve().then(async()=>{for(this.log("start walk");this.walkers>0;)try{const i=Xi(32);let o=Date.now();for await(const a of this.peerRouting.getClosestPeers(i,{signal:t}))t.aborted&&this.log("aborting walk"),t.throwIfAborted(),this.log("found peer %p after %dms for %d walkers",a.id,Date.now()-o,this.walkers),s++,this.safeDispatchEvent("walk:peer",{detail:a}),this.walkers===1&&this.needNext!=null&&(this.log("wait for need next"),await xe(this.needNext.promise,t)),o=Date.now();this.log("walk iteration for %b and %d walkers finished, found %d peers",i,this.walkers,s)}catch(i){this.log.error("random walk errored - %e",i),this.safeDispatchEvent("walk:error",{detail:i})}this.log("no walkers left, ended walk")}).catch(i=>{this.log.error("random walk errored - %e",i)}).finally(()=>{this.log("finished walk, found %d peers after %dms",s,Date.now()-n),this.walking=!1})}}const ic=32,oc=64;var Bi;Bi=Symbol.toStringTag;class tp{constructor(e){c(this,"log");c(this,"topologies");c(this,"handlers");c(this,"components");c(this,"middleware");c(this,Bi,"@libp2p/registrar");this.components=e,this.log=e.logger.forComponent("libp2p:registrar"),this.middleware=new Map,this.topologies=new Map,e.metrics?.registerMetricGroup("libp2p_registrar_topologies",{calculate:()=>{const t={};for(const[n,s]of this.topologies)t[n]=s.size;return t}}),this.handlers=Ce({name:"libp2p_registrar_protocol_handlers",metrics:e.metrics}),this._onDisconnect=this._onDisconnect.bind(this),this._onPeerUpdate=this._onPeerUpdate.bind(this),this._onPeerIdentify=this._onPeerIdentify.bind(this),this.components.events.addEventListener("peer:disconnect",this._onDisconnect),this.components.events.addEventListener("peer:update",this._onPeerUpdate),this.components.events.addEventListener("peer:identify",this._onPeerIdentify)}getProtocols(){return Array.from(new Set([...this.handlers.keys()])).sort()}getHandler(e){const t=this.handlers.get(e);if(t==null)throw new qf(`No handler registered for protocol ${e}`);return t}getTopologies(e){const t=this.topologies.get(e);return t==null?[]:[...t.values()]}async handle(e,t,n){if(this.handlers.has(e)&&n?.force!==!0)throw new Vf(`Handler already registered for protocol ${e}`);this.handlers.set(e,{handler:t,options:{maxInboundStreams:ic,maxOutboundStreams:oc,...n}}),await this.components.peerStore.merge(this.components.peerId,{protocols:[e]},n)}async unhandle(e,t){(Array.isArray(e)?e:[e]).forEach(s=>{this.handlers.delete(s)}),await this.components.peerStore.patch(this.components.peerId,{protocols:this.getProtocols()},t)}async register(e,t){if(t==null)throw new N("invalid topology");const n=`${(Math.random()*1e9).toString(36)}${Date.now()}`;let s=this.topologies.get(e);return s==null&&(s=new Map,this.topologies.set(e,s)),s.set(n,t),n}unregister(e){for(const[t,n]of this.topologies.entries())n.has(e)&&(n.delete(e),n.size===0&&this.topologies.delete(t))}use(e,t){this.middleware.set(e,t)}unuse(e){this.middleware.delete(e)}getMiddleware(e){return this.middleware.get(e)??[]}async _onDisconnect(e){const t=e.detail,n={signal:AbortSignal.timeout(5e3)};try{const s=await this.components.peerStore.get(t,n);for(const i of s.protocols){const o=this.topologies.get(i);o!=null&&await Promise.all([...o.values()].map(async a=>{a.filter?.has(t)!==!1&&(a.filter?.remove(t),await a.onDisconnect?.(t))}))}}catch(s){if(s.name==="NotFoundError")return;this.log.error("could not inform topologies of disconnecting peer %p - %e",t,s)}}async _onPeerUpdate(e){const{peer:t,previous:n}=e.detail,s=(n?.protocols??[]).filter(i=>!t.protocols.includes(i));try{for(const i of s){const o=this.topologies.get(i);o!=null&&await Promise.all([...o.values()].map(async a=>{a.filter?.has(t.id)!==!1&&(a.filter?.remove(t.id),await a.onDisconnect?.(t.id))}))}}catch(i){this.log.error("could not inform topologies of updated peer %p - %e",t.id,i)}}async _onPeerIdentify(e){const t=e.detail.protocols,n=e.detail.connection,s=e.detail.peerId;try{for(const i of t){const o=this.topologies.get(i);o!=null&&await Promise.all([...o.values()].map(async a=>{n.limits!=null&&a.notifyOnLimitedConnection!==!0||a.filter?.has(s)!==!0&&(a.filter?.add(s),await a.onConnect?.(s,n))}))}}catch(i){this.log.error("could not inform topologies of updated peer after identify %p - %e",s,i)}}}var Ui;Ui=Symbol.toStringTag;class np{constructor(e,t={}){c(this,"log");c(this,"components");c(this,"transports");c(this,"listeners");c(this,"faultTolerance");c(this,"started");c(this,Ui,"@libp2p/transport-manager");this.log=e.logger.forComponent("libp2p:transports"),this.components=e,this.started=!1,this.transports=Ce({name:"libp2p_transport_manager_transports",metrics:this.components.metrics}),this.listeners=Ce({name:"libp2p_transport_manager_listeners",metrics:this.components.metrics}),this.faultTolerance=t.faultTolerance??Ns.FATAL_ALL}add(e){const t=e[Symbol.toStringTag];if(t==null)throw new N("Transport must have a valid tag");if(this.transports.has(t))throw new N(`There is already a transport with the tag ${t}`);this.log("adding transport %s",t),this.transports.set(t,e),this.listeners.has(t)||this.listeners.set(t,[])}isStarted(){return this.started}start(){this.started=!0}async afterStart(){const e=this.components.addressManager.getListenAddrs();await this.listen(e)}async stop(){const e=[];for(const[t,n]of this.listeners)for(this.log("closing listeners for %s",t);n.length>0;){const s=n.pop();s!=null&&e.push(s.close())}await Promise.all(e),this.log("all listeners closed");for(const t of this.listeners.keys())this.listeners.set(t,[]);this.started=!1}async dial(e,t){const n=this.dialTransportForMultiaddr(e);if(n==null)throw new Hf(`No transport available for address ${String(e)}`);return t?.onProgress?.(new J("transport-manager:selected-transport",n[Symbol.toStringTag])),n.dial(e,{...t,upgrader:this.components.upgrader})}getAddrs(){let e=[];for(const t of this.listeners.values())for(const n of t)e=[...e,...n.getAddrs()];return e}getTransports(){return Array.of(...this.transports.values())}getListeners(){return Array.of(...this.listeners.values()).flat()}dialTransportForMultiaddr(e){for(const t of this.transports.values())if(t.dialFilter([e]).length>0)return t}listenTransportForMultiaddr(e){for(const t of this.transports.values())if(t.listenFilter([e]).length>0)return t}async listen(e){if(!this.isStarted())throw new Cn("Not started");if(e==null||e.length===0){this.log("no addresses were provided for listening, this node is dial only");return}const t={errors:new Map,ipv4:{success:0,attempts:0},ipv6:{success:0,attempts:0}};e.forEach(i=>{t.errors.set(i.toString(),new Wf)});const n=[];for(const[i,o]of this.transports.entries()){const a=o.listenFilter(e);for(const l of a){this.log("creating listener for %s on %a",i,l);const u=o.createListener({upgrader:this.components.upgrader});let d=this.listeners.get(i)??[];d==null&&(d=[],this.listeners.set(i,d)),d.push(u),u.addEventListener("listening",()=>{this.components.events.safeDispatchEvent("transport:listening",{detail:u})}),u.addEventListener("close",()=>{const h=d.findIndex(f=>f===u);d.splice(h,1),this.components.events.safeDispatchEvent("transport:close",{detail:u})}),li.matches(l)?t.ipv4.attempts++:ui.matches(l)&&t.ipv6.attempts++,n.push(u.listen(l).then(()=>{t.errors.delete(l.toString()),li.matches(l)&&t.ipv4.success++,ui.matches(l)&&t.ipv6.success++},h=>{throw this.log.error("transport %s could not listen on address %a - %e",i,l,h),t.errors.set(l.toString(),h),h}))}}const s=await Promise.allSettled(n);if(!(s.length>0&&s.every(i=>i.status==="fulfilled"))){if(this.ipv6Unsupported(t)){this.log("all IPv4 addresses succeed but all IPv6 failed");return}if(this.faultTolerance===Ns.NO_FATAL){this.log("failed to listen on any address but fault tolerance allows this");return}throw new Kf(`Some configured addresses failed to be listened on, you may need to remove one or more listen addresses from your configuration or set \`transportManager.faultTolerance\` to NO_FATAL:
${[...t.errors.entries()].map(([i,o])=>`
  ${i}: ${`${rp(o)}`.split(`
`).join(`
  `)}
`).join("")}`)}}ipv6Unsupported(e){if(e.ipv4.attempts===0||e.ipv6.attempts===0)return!1;const t=e.ipv4.attempts===e.ipv4.success,n=e.ipv6.success===0;return t&&n}async remove(e){const t=this.listeners.get(e)??[];this.log.trace("removing transport %s",e);const n=[];for(this.log.trace("closing listeners for %s",e);t.length>0;){const s=t.pop();s!=null&&n.push(s.close())}await Promise.all(n),this.transports.delete(e),this.listeners.delete(e)}async removeAll(){const e=[];for(const t of this.transports.keys())e.push(this.remove(t));await Promise.all(e)}}function rp(r){return r.stack!=null&&r.stack.trim()!==""?r.stack:r.message!=null?r.message:r.toString()}const qe="/multistream/1.0.0",ac=1024,sp=F(`
`);async function Gr(r,e){const n=(await r.read(e)).subarray();if(n.byteLength===0||n[n.length-1]!==sp[0])throw new Dc("Missing newline");return Y(n).trimEnd()}async function Qr(r,e,t={}){if(e=Array.isArray(e)?[...e]:[e],e.length===0)throw new Error("At least one protocol must be specified");const n=r.log.newScope("mss:select"),s=Es(r,{...t,maxDataLength:ac});for(let i=0;i<e.length;i++){const o=e[i];let a;if(i===0){n.trace('write ["%s", "%s"]',qe,o);const l=F(`${qe}
`),u=F(`${o}
`);if(await s.writeV([l,u],t),n.trace("reading multistream-select header"),a=await Gr(s,t),n.trace('read "%s"',a),a!==qe){n.error("did not read multistream-select header from response");break}}else n.trace('write "%s"',o),await s.write(F(`${o}
`),t);if(n.trace("reading protocol response"),a=await Gr(s,t),n.trace('read "%s"',a),a===o)return n.trace('selected "%s" after negotiation',a),s.unwrap(),o}throw new Mc(`Protocol selection failed - could not negotiate ${e}`)}async function jr(r,e,t={}){e=Array.isArray(e)?e:[e];const n=r.log.newScope("mss:handle"),s=Es(r,{...t,maxDataLength:ac,maxLengthLength:2});for(;;){n.trace("reading incoming string");const i=await Gr(s,t);if(n.trace('read "%s"',i),i===qe){n.trace('respond with "%s" for "%s"',qe,i),await s.write(F(`${qe}
`),t),n.trace('responded with "%s" for "%s"',qe,i);continue}if(e.includes(i))return n.trace('respond with "%s" for "%s"',i,i),await s.write(F(`${i}
`),t),n.trace('responded with "%s" for "%s"',i,i),s.unwrap(),i;if(i==="ls"){const o=new ie(...e.map(a=>pa.single(F(`${a}
`))),F(`
`));n.trace('respond with "%s" for %s',e,i),await s.write(o,t),n.trace('responded with "%s" for %s',e,i);continue}n.trace('respond with "na" for "%s"',i),await s.write(F(`na
`),t),n('responded with "na" for "%s"',i)}}var zi,qi,Vi;class ip extends(Vi=_e,qi=Symbol.toStringTag,zi=Nc,Vi){constructor(t,n){super();c(this,"id");c(this,"remoteAddr");c(this,"remotePeer");c(this,"direction");c(this,"timeline");c(this,"direct");c(this,"multiplexer");c(this,"encryption");c(this,"limits");c(this,"log");c(this,"maConn");c(this,"muxer");c(this,"components");c(this,"outboundStreamProtocolNegotiationTimeout");c(this,"inboundStreamProtocolNegotiationTimeout");c(this,"closeTimeout");c(this,qi,"Connection");c(this,zi,!0);c(this,"newStream",async(t,n={})=>{if(this.muxer==null)throw new xn("Connection is not multiplexed");if(this.muxer.status!=="open")throw new Lr(`The connection muxer is "${this.muxer.status}" and not "open"`);if(this.maConn.status!=="open")throw new Lr(`The connection is "${this.status}" and not "open"`);if(this.limits!=null&&n?.runOnLimitedConnection!==!0)throw new Fs("Cannot open protocol stream on limited connection");Array.isArray(t)||(t=[t]),this.log.trace("starting new stream for protocols %s",t);const s=await this.muxer.createStream({...n,protocol:t.length===1?t[0]:void 0});this.log.trace("started new stream %s for protocols %s",s.id,t);try{if(n.signal==null){s.log("no abort signal was passed while trying to negotiate protocols %s falling back to default timeout",t);const l=AbortSignal.timeout(this.outboundStreamProtocolNegotiationTimeout);pe(1/0,l),n={...n,signal:l}}s.protocol===""?(s.log.trace("selecting protocol from protocols %s",t),s.protocol=await Qr(s,t,n),s.log("negotiated protocol %s",s.protocol)):s.log("pre-negotiated protocol %s",s.protocol);const i=cp(s.protocol,this.components.registrar,n),o=xi(s.protocol,"outbound",this);if(o>i){const l=new Fc(`Too many outbound protocol streams for protocol "${s.protocol}" - ${o}/${i}`);throw s.abort(l),l}await this.components.peerStore.merge(this.remotePeer,{protocols:[s.protocol]}),this.components.metrics?.trackProtocolStream(s);const a=this.components.registrar.getMiddleware(s.protocol);return await this.runMiddlewareChain(s,this,a)}catch(i){throw s.status==="open"?s.abort(i):this.log.error("could not create new outbound stream on connection %s %a for protocols %s - %e",this.direction==="inbound"?"from":"to",this.remoteAddr,t,i),i}});this.components=t,this.id=n.id,this.remoteAddr=n.maConn.remoteAddr,this.remotePeer=n.remotePeer,this.direction=n.direction??"outbound",this.timeline=n.maConn.timeline,this.encryption=n.cryptoProtocol,this.limits=n.limits,this.maConn=n.maConn,this.log=n.maConn.log,this.outboundStreamProtocolNegotiationTimeout=n.outboundStreamProtocolNegotiationTimeout??Wn,this.inboundStreamProtocolNegotiationTimeout=n.inboundStreamProtocolNegotiationTimeout??Wn,this.closeTimeout=n.closeTimeout??ja,this.direct=Ka(n.maConn.remoteAddr),this.onIncomingStream=this.onIncomingStream.bind(this),this.remoteAddr.getComponents().find(s=>s.code===C)==null&&(this.remoteAddr=this.remoteAddr.encapsulate(`/p2p/${this.remotePeer}`)),n.muxer!=null&&(this.multiplexer=n.muxer.protocol,this.muxer=n.muxer,this.muxer.addEventListener("stream",this.onIncomingStream)),this.maConn.addEventListener("close",s=>{this.dispatchEvent(new Qi(s.local,s.error))})}get streams(){return this.muxer?.streams??[]}get status(){return this.maConn.status}async onIncomingStream(t){const n=t.detail,s=AbortSignal.timeout(this.inboundStreamProtocolNegotiationTimeout);n.log("start protocol negotiation, timing out after %dms",this.inboundStreamProtocolNegotiationTimeout);try{if(n.protocol===""){const d=this.components.registrar.getProtocols();n.log.trace("selecting protocol from protocols %s",d),n.protocol=await jr(n,d,{signal:s}),n.log("negotiated protocol %s",n.protocol)}else n.log("pre-negotiated protocol %s",n.protocol);const i=ap(n.protocol,this.components.registrar);if(xi(n.protocol,"inbound",this)>i)throw new Rc(`Too many inbound protocol streams for protocol "${n.protocol}" - limit ${i}`);await this.components.peerStore.merge(this.remotePeer,{protocols:[n.protocol]},{signal:s}),this.components.metrics?.trackProtocolStream(n);const{handler:a,options:l}=this.components.registrar.getHandler(n.protocol);if(this.limits!=null&&l.runOnLimitedConnection!==!0)throw new Fs("Cannot open protocol stream on limited connection");const u=this.components.registrar.getMiddleware(n.protocol);u.push(async(d,h,f)=>{await a(d,h),f(d,h)}),await this.runMiddlewareChain(n,this,u)}catch(i){n.abort(i)}}async runMiddlewareChain(t,n,s){for(let i=0;i<s.length;i++){const o=s[i];t.log.trace("running middleware",i,o),await new Promise((a,l)=>{try{const u=o(t,n,(d,h)=>{t=d,n=h,a()});u instanceof Promise&&u.catch(l)}catch(u){l(u)}}),t.log.trace("ran middleware",i,o)}return t}async close(t={}){if(this.log("closing connection to %a",this.remoteAddr),t.signal==null){const n=AbortSignal.timeout(this.closeTimeout);t={...t,signal:n}}await this.muxer?.close(t),await this.maConn.close(t)}abort(t){this.muxer?.abort(t),this.maConn.abort(t)}}function op(r,e){return new ip(r,e)}function ap(r,e){try{const{options:t}=e.getHandler(r);if(t.maxInboundStreams!=null)return t.maxInboundStreams}catch(t){if(t.name!=="UnhandledProtocolError")throw t}return ic}function cp(r,e,t={}){try{const{options:n}=e.getHandler(r);if(n.maxOutboundStreams!=null)return n.maxOutboundStreams}catch(n){if(n.name!=="UnhandledProtocolError")throw n}return t.maxOutboundStreams??oc}function xi(r,e,t){let n=0;return t.streams.forEach(s=>{s.direction===e&&s.protocol===r&&n++}),n}var Wi;Wi=Symbol.toStringTag;class lp{constructor(e,t){c(this,"components");c(this,"connectionEncrypters");c(this,"streamMuxers");c(this,"inboundUpgradeTimeout");c(this,"inboundStreamProtocolNegotiationTimeout");c(this,"outboundStreamProtocolNegotiationTimeout");c(this,"events");c(this,"metrics");c(this,"connectionCloseTimeout");c(this,Wi,"@libp2p/upgrader");this.components=e,this.connectionEncrypters=Ce({name:"libp2p_upgrader_connection_encrypters",metrics:this.components.metrics}),t.connectionEncrypters.forEach(n=>{this.connectionEncrypters.set(n.protocol,n)}),this.streamMuxers=Ce({name:"libp2p_upgrader_stream_multiplexers",metrics:this.components.metrics}),t.streamMuxers.forEach(n=>{this.streamMuxers.set(n.protocol,n)}),this.inboundUpgradeTimeout=t.inboundUpgradeTimeout??lm,this.inboundStreamProtocolNegotiationTimeout=t.inboundStreamProtocolNegotiationTimeout??Wn,this.outboundStreamProtocolNegotiationTimeout=t.outboundStreamProtocolNegotiationTimeout??Wn,this.connectionCloseTimeout=t.connectionCloseTimeout??ja,this.events=e.events,this.metrics={dials:e.metrics?.registerCounterGroup("libp2p_connection_manager_dials_total"),errors:e.metrics?.registerCounterGroup("libp2p_connection_manager_dial_errors_total"),inboundErrors:e.metrics?.registerCounterGroup("libp2p_connection_manager_dials_inbound_errors_total"),outboundErrors:e.metrics?.registerCounterGroup("libp2p_connection_manager_dials_outbound_errors_total")}}async shouldBlockConnection(e,...t){const n=this.components.connectionGater[e];if(n==null)return;if(await n.apply(this.components.connectionGater,t)===!0)throw new Qf(`The multiaddr connection is blocked by gater.${e}`)}createInboundAbortSignal(e){return wt([AbortSignal.timeout(this.inboundUpgradeTimeout),e])}async upgradeInbound(e,t){let n=!1;const s=this.createInboundAbortSignal(t.signal);try{if(this.metrics.dials?.increment({inbound:!0}),n=this.components.connectionManager.acceptIncomingConnection(e),!n)throw new jf("Connection denied");await xe(this.shouldBlockConnection("denyInboundConnection",e),s),await this._performUpgrade(e,"inbound",{...t,signal:s})}catch(i){throw this.metrics.errors?.increment({inbound:!0}),this.metrics.inboundErrors?.increment({[i.name??"Error"]:!0}),i}finally{s.clear(),n&&this.components.connectionManager.afterUpgradeInbound()}}async upgradeOutbound(e,t){try{this.metrics.dials?.increment({outbound:!0});const n=e.remoteAddr.getComponents().findLast(o=>o.code===C)?.value;let s;n!=null&&(s=mt(n),await xe(this.shouldBlockConnection("denyOutboundConnection",s,e),t.signal));let i="outbound";return t.initiator===!1&&(i="inbound"),await this._performUpgrade(e,i,t)}catch(n){throw this.metrics.errors?.increment({outbound:!0}),this.metrics.outboundErrors?.increment({[n.name??"Error"]:!0}),n}}async _performUpgrade(e,t,n){let s=e,i,o,a,l;const u=`${parseInt(String(Math.random()*1e9)).toString(36)}${Date.now()}`;if(e.log=e.log.newScope(`${t}:${u}`),this.components.metrics?.trackMultiaddrConnection(e),e.log.trace("starting the %s connection upgrade",t),n?.skipProtection!==!0){const h=this.components.connectionProtector;h!=null&&(e.log("protecting the %s connection",t),s=await h.protect(s,n))}try{if(up(n)){if(n.remotePeer==null)throw new Zr(`${t} connection that skipped encryption must have a peer id`);l="native",i=n.remotePeer}else{const h=e.remoteAddr.getComponents().findLast(p=>p.code===C)?.value;let f;h!=null&&(f=mt(h)),n?.onProgress?.(new J(`upgrader:encrypt-${t}-connection`)),{connection:s,remotePeer:i,protocol:l,streamMuxer:o}=await(t==="inbound"?this._encryptInbound(s,{...n,remotePeer:f}):this._encryptOutbound(s,{...n,remotePeer:f}))}if(i.equals(this.components.peerId)){const h=new Hi("Can not dial self");throw e.abort(h),h}await this.shouldBlockConnection(t==="inbound"?"denyInboundEncryptedConnection":"denyOutboundEncryptedConnection",i,e),n?.muxerFactory!=null?o=n.muxerFactory:o==null&&this.streamMuxers.size>0&&(n?.onProgress?.(new J(`upgrader:multiplex-${t}-connection`)),o=await(t==="inbound"?this._multiplexInbound(s,this.streamMuxers,n):this._multiplexOutbound(s,this.streamMuxers,n)))}catch(h){throw e.log.error("failed to upgrade %s connection %s %a - %e",t,t==="inbound"?"from":"to",e.remoteAddr,h),h}o!=null&&(e.log("create muxer %s",o.protocol),a=o.createStreamMuxer(s)),await this.shouldBlockConnection(t==="inbound"?"denyInboundUpgradedConnection":"denyOutboundUpgradedConnection",i,e);const d=this._createConnection({id:u,cryptoProtocol:l,direction:t,maConn:e,stream:s,muxer:a,remotePeer:i,limits:n?.limits,closeTimeout:this.connectionCloseTimeout});return d.log("successfully upgraded connection"),d}_createConnection(e){const t=op(this.components,{...e,outboundStreamProtocolNegotiationTimeout:this.outboundStreamProtocolNegotiationTimeout,inboundStreamProtocolNegotiationTimeout:this.inboundStreamProtocolNegotiationTimeout});return t.addEventListener("close",()=>{this.events.safeDispatchEvent("connection:close",{detail:t})}),this.events.safeDispatchEvent("connection:open",{detail:t}),t}async _encryptInbound(e,t){const n=Array.from(this.connectionEncrypters.keys());try{const s=await jr(e,n,t),i=this.connectionEncrypters.get(s);if(i==null)throw new un(`no crypto module found for ${s}`);return e.log("encrypting inbound connection using %s",s),{...await i.secureInbound(e,t),protocol:s}}catch(s){throw new un(s.message)}}async _encryptOutbound(e,t){const n=Array.from(this.connectionEncrypters.keys());try{e.log.trace("selecting encrypter from %s",n);const s=await Qr(e,n,t),i=this.connectionEncrypters.get(s);if(i==null)throw new un(`no crypto module found for ${s}`);return e.log("encrypting outbound connection using %s",s),{...await i.secureOutbound(e,t),protocol:s}}catch(s){throw new un(s.message)}}async _multiplexOutbound(e,t,n){const s=Array.from(t.keys());e.log("outbound selecting muxer %s",s);try{e.log.trace("selecting stream muxer from %s",s);const i=await Qr(e,s,n),o=t.get(i);if(o==null)throw new xn(`No muxer configured for protocol "${i}"`);return e.log("selected %s as muxer protocol",i),o}catch(i){throw e.log.error("error multiplexing outbound connection - %e",i),new xn(String(i))}}async _multiplexInbound(e,t,n){const s=Array.from(t.keys());e.log("inbound handling muxers %s",s);try{e.log.trace("selecting stream muxer from %s",s);const i=await jr(e,s,n),o=t.get(i);if(o==null)throw new xn(`No muxer configured for protocol "${i}"`);return e.log("selected %s as muxer protocol",i),o}catch(i){throw e.log.error("error multiplexing inbound connection - %e",i),i}}getConnectionEncrypters(){return this.connectionEncrypters}getStreamMuxers(){return this.streamMuxers}}function up(r){return r.skipEncryption===!0}const cc="3.1.3",lc="js-libp2p";function dp(r,e){return`${r??lc}/${e??cc} browser/${globalThis.navigator.userAgent}`}var Ht,Hr;class hp extends _e{constructor(t){super();D(this,Ht);c(this,"peerId");c(this,"peerStore");c(this,"contentRouting");c(this,"peerRouting");c(this,"metrics");c(this,"services");c(this,"logger");c(this,"status");c(this,"components");c(this,"log");this.status="stopped";const n=new _e,s=n.dispatchEvent.bind(n);n.dispatchEvent=d=>{const h=s(d),f=this.dispatchEvent(new CustomEvent(d.type,{detail:d.detail}));return h||f},this.peerId=t.peerId,this.logger=t.logger??To(),this.log=this.logger.forComponent("libp2p"),this.services={};const i=t.nodeInfo?.name??lc,o=t.nodeInfo?.version??cc,a=this.components=em({peerId:t.peerId,privateKey:t.privateKey,nodeInfo:{name:i,version:o,userAgent:t.nodeInfo?.userAgent??dp(i,o)},logger:this.logger,events:n,datastore:t.datastore??new bf,connectionGater:im(t.connectionGater),dns:t.dns});t.metrics!=null&&(this.metrics=this.configureComponent("metrics",t.metrics(this.components))),this.peerStore=this.configureComponent("peerStore",ff(a,{addressFilter:this.components.connectionGater.filterMultiaddrForPeer,...t.peerStore})),a.events.addEventListener("peer:update",d=>{if(d.detail.previous==null){const h={id:d.detail.peer.id,multiaddrs:d.detail.peer.addresses.map(f=>f.multiaddr)};a.events.safeDispatchEvent("peer:discovery",{detail:h})}}),t.connectionProtector!=null&&this.configureComponent("connectionProtector",t.connectionProtector(a)),this.components.upgrader=new lp(this.components,{connectionEncrypters:(t.connectionEncrypters??[]).map((d,h)=>this.configureComponent(`connection-encryption-${h}`,d(this.components))),streamMuxers:(t.streamMuxers??[]).map((d,h)=>this.configureComponent(`stream-muxers-${h}`,d(this.components))),inboundUpgradeTimeout:t.connectionManager?.inboundUpgradeTimeout,inboundStreamProtocolNegotiationTimeout:t.connectionManager?.inboundStreamProtocolNegotiationTimeout,outboundStreamProtocolNegotiationTimeout:t.connectionManager?.outboundStreamProtocolNegotiationTimeout,connectionCloseTimeout:t.connectionManager?.connectionCloseTimeout}),this.configureComponent("transportManager",new np(this.components,t.transportManager)),this.configureComponent("connectionManager",new Wm(this.components,t.connectionManager)),t.connectionMonitor?.enabled!==!1&&this.configureComponent("connectionMonitor",new Xm(this.components,t.connectionMonitor)),this.configureComponent("registrar",new tp(this.components)),this.configureComponent("addressManager",new Of(this.components,t.addresses));const l=(t.peerRouters??[]).map((d,h)=>this.configureComponent(`peer-router-${h}`,d(this.components)));this.peerRouting=this.components.peerRouting=this.configureComponent("peerRouting",new Zm(this.components,{routers:l}));const u=(t.contentRouters??[]).map((d,h)=>this.configureComponent(`content-router-${h}`,d(this.components)));if(this.contentRouting=this.components.contentRouting=this.configureComponent("contentRouting",new Ym(this.components,{routers:u})),this.configureComponent("randomWalk",new ep(this.components)),(t.peerDiscovery??[]).forEach((d,h)=>{this.configureComponent(`peer-discovery-${h}`,d(this.components)).addEventListener("peer",p=>{E(this,Ht,Hr).call(this,p)})}),t.transports?.forEach((d,h)=>{this.components.transportManager.add(this.configureComponent(`transport-${h}`,d(this.components)))}),t.services!=null)for(const d of Object.keys(t.services)){const h=t.services[d],f=h(this.components);if(f==null){this.log.error("service factory %s returned null or undefined instance",d);continue}this.services[d]=f,this.configureComponent(d,f),f[Rs]!=null&&(this.log("registering service %s for content routing",d),u.push(f[Rs])),f[$s]!=null&&(this.log("registering service %s for peer routing",d),l.push(f[$s])),f[Os]!=null&&(this.log("registering service %s for peer discovery",d),f[Os].addEventListener?.("peer",p=>{E(this,Ht,Hr).call(this,p)}))}tm(a)}configureComponent(t,n){return n==null&&this.log.error("component %s was null or undefined",t),this.components[t]=n,n}async start(){if(this.status==="stopped"){this.status="starting",this.log("libp2p is starting");try{await this.components.beforeStart?.(),await this.components.start(),await this.components.afterStart?.(),this.status="started",this.safeDispatchEvent("start",{detail:this}),this.log("libp2p has started with peer id %p",this.peerId)}catch(t){throw this.log.error("an error occurred starting libp2p - %e",t),this.status="started",await this.stop(),t}}}async stop(){this.status==="started"&&(this.log("libp2p is stopping"),this.status="stopping",await this.components.beforeStop?.(),await this.components.stop(),await this.components.afterStop?.(),this.status="stopped",this.safeDispatchEvent("stop",{detail:this}),this.log("libp2p has stopped"))}getConnections(t){return this.components.connectionManager.getConnections(t)}getDialQueue(){return this.components.connectionManager.getDialQueue()}getPeers(){const t=new at;for(const n of this.components.connectionManager.getConnections())t.add(n.remotePeer);return Array.from(t)}async dial(t,n={}){return this.components.connectionManager.openConnection(t,{priority:75,...n})}async dialProtocol(t,n,s={}){if(n==null)throw new N("no protocols were provided to open a stream");if(n=Array.isArray(n)?n:[n],n.length===0)throw new N("no protocols were provided to open a stream");return this.components.connectionManager.openStream(t,n,s)}getMultiaddrs(){return this.components.addressManager.getAddresses()}getProtocols(){return this.components.registrar.getProtocols()}async hangUp(t,n={}){Hn(t)&&(t=mt(t.getComponents().findLast(s=>s.code===C)?.value??"")),await this.components.connectionManager.closeConnections(t,n)}async getPublicKey(t,n={}){if(this.log("getPublicKey %p",t),t.publicKey!=null)return t.publicKey;try{const a=await this.peerStore.get(t,n);if(a.id.publicKey!=null)return a.id.publicKey}catch(a){if(a.name!=="NotFoundError")throw a}const s=Qn([F("/pk/"),t.toMultihash().bytes]),i=await this.contentRouting.get(s,n),o=Jr(i);return await this.peerStore.patch(t,{publicKey:o},n),o}async handle(t,n,s){Array.isArray(t)||(t=[t]),await Promise.all(t.map(async i=>{await this.components.registrar.handle(i,n,s)}))}async unhandle(t,n){Array.isArray(t)||(t=[t]),await Promise.all(t.map(async s=>{await this.components.registrar.unhandle(s,n)}))}async register(t,n,s){return this.components.registrar.register(t,n,s)}unregister(t){this.components.registrar.unregister(t)}use(t,n){this.components.registrar.use(t,Array.isArray(n)?n:[n])}unuse(t){this.components.registrar.unuse(t)}async isDialable(t,n={}){return this.components.connectionManager.isDialable(t,n)}}Ht=new WeakSet,Hr=function(t){const{detail:n}=t;if(n.id.toString()===this.peerId.toString()){this.log.error("peer discovery mechanism discovered self");return}this.components.peerStore.merge(n.id,{multiaddrs:n.multiaddrs}).catch(s=>{this.log.error("could not update multiaddrs of discovered peer - %e",s)})};async function Kp(r={}){r.privateKey??(r.privateKey=await $c("Ed25519"));const e=new hp({...await od(r),peerId:qc(r.privateKey)});return r.start!==!1&&await e.start(),e}export{di as $,aa as A,tn as B,In as C,sh as D,st as E,fo as F,go as G,mo as H,qp as I,po as J,it as K,Rp as L,Tp as M,J as N,oe as O,sd as P,Wr as Q,$n as R,hi as S,qr as T,O as U,$ as V,zn as W,ss as X,Wp as Y,fi as Z,Bt as _,jn as a,M as a0,xh as a1,en as a2,ws as a3,Vn as a4,Bp as a5,G as a6,Jm as a7,oa as a8,at as a9,Yd as aa,Fn as ab,ci as ac,oi as ad,kh as ae,Ur as af,zp as ag,Vp as ah,$p as ai,yp as aj,wp as ak,To as al,Kp as am,wt as b,se as c,bp as d,mt as e,ro as f,$t as g,ts as h,Np as i,Gt as j,ho as k,is as l,z as m,Ep as n,C as o,id as p,Es as q,Pp as r,Lp as s,Op as t,xe as u,pa as v,Fp as w,Ys as x,he as y,R as z};
