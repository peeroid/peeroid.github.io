var ah=Object.defineProperty;var Qa=r=>{throw TypeError(r)};var ch=(r,e,t)=>e in r?ah(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t;var u=(r,e,t)=>ch(r,typeof e!="symbol"?e+"":e,t),ki=(r,e,t)=>e.has(r)||Qa("Cannot "+t);var v=(r,e,t)=>(ki(r,e,"read from private field"),t?t.call(r):e.get(r)),se=(r,e,t)=>e.has(r)?Qa("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(r):e.set(r,t),re=(r,e,t,n)=>(ki(r,e,"write to private field"),n?n.call(r,t):e.set(r,t),t),O=(r,e,t)=>(ki(r,e,"access private method"),t);var Ht=(r,e,t,n)=>({set _(s){re(r,e,s,t)},get _(){return v(r,e,n)}});var uh=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function Fu(r){return r&&r.__esModule&&Object.prototype.hasOwnProperty.call(r,"default")?r.default:r}const lh=Symbol.for("@libp2p/connection"),Ja=Symbol.for("@libp2p/content-routing");var no;let _n=(no=class extends Error{constructor(e="The operation was aborted"){super(e),this.name="AbortError"}},u(no,"name","AbortError"),no);class dh extends Error{constructor(e="Unexpected Peer"){super(e),this.name="UnexpectedPeerError"}}u(dh,"name","UnexpectedPeerError");class fh extends Error{constructor(e="Invalid crypto exchange"){super(e),this.name="InvalidCryptoExchangeError"}}u(fh,"name","InvalidCryptoExchangeError");var so;let Z=(so=class extends Error{constructor(e="Invalid parameters"){super(e),this.name="InvalidParametersError"}},u(so,"name","InvalidParametersError"),so);class jo extends Error{constructor(e="Invalid public key"){super(e),this.name="InvalidPublicKeyError"}}u(jo,"name","InvalidPublicKeyError");class Yo extends Error{constructor(e="Invalid private key"){super(e),this.name="InvalidPrivateKeyError"}}u(Yo,"name","InvalidPrivateKeyError");class Ps extends Error{constructor(e="The connection is closed"){super(e),this.name="ConnectionClosedError"}}u(Ps,"name","ConnectionClosedError");class hh extends Error{constructor(e="Connection failed"){super(e),this.name="ConnectionFailedError"}}u(hh,"name","ConnectionFailedError");class Ou extends Error{constructor(e="The muxer is closed"){super(e),this.name="MuxerClosedError"}}u(Ou,"name","MuxerClosedError");class $u extends Error{constructor(e="The stream has been reset"){super(e),this.name="StreamResetError"}}u($u,"name","StreamResetError");class Er extends Error{constructor(e="The stream is in an invalid state"){super(e),this.name="StreamStateError"}}u(Er,"name","StreamStateError");class fo extends Error{constructor(e="The stream buffer was full"){super(e),this.name="StreamBufferError"}}u(fo,"name","StreamBufferError");var io;let ho=(io=class extends Error{constructor(e="Not found"){super(e),this.name="NotFoundError"}},u(io,"name","NotFoundError"),io);class Xo extends Error{constructor(e="Invalid PeerID"){super(e),this.name="InvalidPeerIdError"}}u(Xo,"name","InvalidPeerIdError");var oo;let Qo=(oo=class extends Error{constructor(e="Invalid multiaddr"){super(e),this.name="InvalidMultiaddrError"}},u(oo,"name","InvalidMultiaddrError"),oo);class Uu extends Error{constructor(e="Invalid CID"){super(e),this.name="InvalidCIDError"}}u(Uu,"name","InvalidCIDError");class zu extends Error{constructor(e="Invalid Multihash"){super(e),this.name="InvalidMultihashError"}}u(zu,"name","InvalidMultihashError");class qu extends Error{constructor(e="Unsupported protocol error"){super(e),this.name="UnsupportedProtocolError"}}u(qu,"name","UnsupportedProtocolError");class Ku extends Error{constructor(e="Invalid message"){super(e),this.name="InvalidMessageError"}}u(Ku,"name","InvalidMessageError");class gh extends Error{constructor(e="Protocol error"){super(e),this.name="ProtocolError"}}u(gh,"name","ProtocolError");var ao;let mh=(ao=class extends Error{constructor(e="Timed out"){super(e),this.name="TimeoutError"}},u(ao,"name","TimeoutError"),ao);class An extends Error{constructor(e="Not started"){super(e),this.name="NotStartedError"}}u(An,"name","NotStartedError");class ps extends Error{constructor(e="Dial error"){super(e),this.name="DialError"}}u(ps,"name","DialError");class ph extends Error{constructor(e="Listen error"){super(e),this.name="ListenError"}}u(ph,"name","ListenError");class go extends Error{constructor(e="Limited connection"){super(e),this.name="LimitedConnectionError"}}u(go,"name","LimitedConnectionError");class Vu extends Error{constructor(e="Too many inbound protocol streams"){super(e),this.name="TooManyInboundProtocolStreamsError"}}u(Vu,"name","TooManyInboundProtocolStreamsError");class Hu extends Error{constructor(e="Too many outbound protocol streams"){super(e),this.name="TooManyOutboundProtocolStreamsError"}}u(Hu,"name","TooManyOutboundProtocolStreamsError");class Jr extends Error{constructor(e="Unsupported key type"){super(e),this.name="UnsupportedKeyTypeError"}}u(Jr,"name","UnsupportedKeyTypeError");class yh extends Event{constructor(t,n){super("message",n);u(this,"data");this.data=t}}class li extends Event{constructor(t,n,s){super("close",s);u(this,"error");u(this,"local");this.error=n,this.local=t}}class wh extends li{constructor(e,t){super(!0,e,t)}}class bh extends li{constructor(e,t){super(!1,e,t)}}const ec=Symbol.for("@libp2p/peer-discovery"),Jo=Symbol.for("@libp2p/peer-id");function wn(r){return!!(r!=null&&r[Jo])}const tc=Symbol.for("@libp2p/peer-routing"),Wu="keep-alive";function ea(r){return r!=null&&typeof r.start=="function"&&typeof r.stop=="function"}async function Eh(...r){const e=[];for(const t of r)ea(t)&&e.push(t);await Promise.all(e.map(async t=>{t.beforeStart!=null&&await t.beforeStart()})),await Promise.all(e.map(async t=>{await t.start()})),await Promise.all(e.map(async t=>{t.afterStart!=null&&await t.afterStart()}))}async function vh(...r){const e=[];for(const t of r)ea(t)&&e.push(t);await Promise.all(e.map(async t=>{t.beforeStop!=null&&await t.beforeStop()})),await Promise.all(e.map(async t=>{await t.stop()})),await Promise.all(e.map(async t=>{t.afterStop!=null&&await t.afterStop()}))}const ox=Symbol.for("@libp2p/transport");var Ms;(function(r){r[r.FATAL_ALL=0]="FATAL_ALL",r[r.NO_FATAL=1]="NO_FATAL"})(Ms||(Ms={}));function ax(){}var ct;class It extends EventTarget{constructor(){super();se(this,ct,new Map)}listenerCount(t){const n=v(this,ct).get(t);return n==null?0:n.length}addEventListener(t,n,s){super.addEventListener(t,n,s);let i=v(this,ct).get(t);i==null&&(i=[],v(this,ct).set(t,i)),i.push({callback:n,once:(s!==!0&&s!==!1&&(s==null?void 0:s.once))??!1})}removeEventListener(t,n,s){super.removeEventListener(t.toString(),n??null,s);let i=v(this,ct).get(t);i!=null&&(i=i.filter(({callback:o})=>o!==n),v(this,ct).set(t,i))}dispatchEvent(t){const n=super.dispatchEvent(t);let s=v(this,ct).get(t.type);return s==null||(s=s.filter(({once:i})=>!i),v(this,ct).set(t.type,s)),n}safeDispatchEvent(t,n={}){return this.dispatchEvent(new CustomEvent(t,n))}}ct=new WeakMap;const mo=Symbol.for("@libp2p/service-capabilities"),rc=Symbol.for("@libp2p/service-dependencies");function xh(r,e){if(r===e)return!0;if(r.byteLength!==e.byteLength)return!1;for(let t=0;t<r.byteLength;t++)if(r[t]!==e[t])return!1;return!0}function di(r){if(r instanceof Uint8Array&&r.constructor.name==="Uint8Array")return r;if(r instanceof ArrayBuffer)return new Uint8Array(r);if(ArrayBuffer.isView(r))return new Uint8Array(r.buffer,r.byteOffset,r.byteLength);throw new Error("Unknown type, must be binary type")}function Sh(r){return new TextEncoder().encode(r)}function _h(r){return new TextDecoder().decode(r)}function Ah(r,e){if(r.length>=255)throw new TypeError("Alphabet too long");for(var t=new Uint8Array(256),n=0;n<t.length;n++)t[n]=255;for(var s=0;s<r.length;s++){var i=r.charAt(s),o=i.charCodeAt(0);if(t[o]!==255)throw new TypeError(i+" is ambiguous");t[o]=s}var a=r.length,c=r.charAt(0),l=Math.log(a)/Math.log(256),d=Math.log(256)/Math.log(a);function f(g){if(g instanceof Uint8Array||(ArrayBuffer.isView(g)?g=new Uint8Array(g.buffer,g.byteOffset,g.byteLength):Array.isArray(g)&&(g=Uint8Array.from(g))),!(g instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(g.length===0)return"";for(var y=0,m=0,_=0,x=g.length;_!==x&&g[_]===0;)_++,y++;for(var E=(x-_)*d+1>>>0,C=new Uint8Array(E);_!==x;){for(var A=g[_],N=0,R=E-1;(A!==0||N<m)&&R!==-1;R--,N++)A+=256*C[R]>>>0,C[R]=A%a>>>0,A=A/a>>>0;if(A!==0)throw new Error("Non-zero carry");m=N,_++}for(var L=E-m;L!==E&&C[L]===0;)L++;for(var T=c.repeat(y);L<E;++L)T+=r.charAt(C[L]);return T}function h(g){if(typeof g!="string")throw new TypeError("Expected String");if(g.length===0)return new Uint8Array;var y=0;if(g[y]!==" "){for(var m=0,_=0;g[y]===c;)m++,y++;for(var x=(g.length-y)*l+1>>>0,E=new Uint8Array(x);g[y];){var C=t[g.charCodeAt(y)];if(C===255)return;for(var A=0,N=x-1;(C!==0||A<_)&&N!==-1;N--,A++)C+=a*E[N]>>>0,E[N]=C%256>>>0,C=C/256>>>0;if(C!==0)throw new Error("Non-zero carry");_=A,y++}if(g[y]!==" "){for(var R=x-_;R!==x&&E[R]===0;)R++;for(var L=new Uint8Array(m+(x-R)),T=m;R!==x;)L[T++]=E[R++];return L}}}function p(g){var y=h(g);if(y)return y;throw new Error(`Non-${e} character`)}return{encode:f,decodeUnsafe:h,decode:p}}var Ih=Ah,Ch=Ih;class Lh{constructor(e,t,n){u(this,"name");u(this,"prefix");u(this,"baseEncode");this.name=e,this.prefix=t,this.baseEncode=n}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}}class Th{constructor(e,t,n){u(this,"name");u(this,"prefix");u(this,"baseDecode");u(this,"prefixCodePoint");this.name=e,this.prefix=t;const s=t.codePointAt(0);if(s===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=s,this.baseDecode=n}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return Gu(this,e)}}class Dh{constructor(e){u(this,"decoders");this.decoders=e}or(e){return Gu(this,e)}decode(e){const t=e[0],n=this.decoders[t];if(n!=null)return n.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}function Gu(r,e){return new Dh({...r.decoders??{[r.prefix]:r},...e.decoders??{[e.prefix]:e}})}class kh{constructor(e,t,n,s){u(this,"name");u(this,"prefix");u(this,"baseEncode");u(this,"baseDecode");u(this,"encoder");u(this,"decoder");this.name=e,this.prefix=t,this.baseEncode=n,this.baseDecode=s,this.encoder=new Lh(e,t,n),this.decoder=new Th(e,t,s)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}function fi({name:r,prefix:e,encode:t,decode:n}){return new kh(r,e,t,n)}function zn({name:r,prefix:e,alphabet:t}){const{encode:n,decode:s}=Ch(t,r);return fi({prefix:e,name:r,encode:n,decode:i=>di(s(i))})}function Ph(r,e,t,n){let s=r.length;for(;r[s-1]==="=";)--s;const i=new Uint8Array(s*t/8|0);let o=0,a=0,c=0;for(let l=0;l<s;++l){const d=e[r[l]];if(d===void 0)throw new SyntaxError(`Non-${n} character`);a=a<<t|d,o+=t,o>=8&&(o-=8,i[c++]=255&a>>o)}if(o>=t||255&a<<8-o)throw new SyntaxError("Unexpected end of data");return i}function Mh(r,e,t){const n=e[e.length-1]==="=",s=(1<<t)-1;let i="",o=0,a=0;for(let c=0;c<r.length;++c)for(a=a<<8|r[c],o+=8;o>t;)o-=t,i+=e[s&a>>o];if(o!==0&&(i+=e[s&a<<t-o]),n)for(;i.length*t&7;)i+="=";return i}function Nh(r){const e={};for(let t=0;t<r.length;++t)e[r[t]]=t;return e}function De({name:r,prefix:e,bitsPerChar:t,alphabet:n}){const s=Nh(n);return fi({prefix:e,name:r,encode(i){return Mh(i,n,t)},decode(i){return Ph(i,s,t,r)}})}const Ce=zn({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),Rh=zn({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),Bh=Object.freeze(Object.defineProperty({__proto__:null,base58btc:Ce,base58flickr:Rh},Symbol.toStringTag,{value:"Module"})),zt=De({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),Fh=De({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),Oh=De({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),$h=De({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),Uh=De({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),zh=De({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),qh=De({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),Kh=De({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),Vh=De({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),Hh=Object.freeze(Object.defineProperty({__proto__:null,base32:zt,base32hex:Uh,base32hexpad:qh,base32hexpadupper:Kh,base32hexupper:zh,base32pad:Oh,base32padupper:$h,base32upper:Fh,base32z:Vh},Symbol.toStringTag,{value:"Module"})),ys=zn({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),Wh=zn({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),Gh=Object.freeze(Object.defineProperty({__proto__:null,base36:ys,base36upper:Wh},Symbol.toStringTag,{value:"Module"}));var Zh=Zu,nc=128,jh=-128,Yh=Math.pow(2,31);function Zu(r,e,t){e=e||[],t=t||0;for(var n=t;r>=Yh;)e[t++]=r&255|nc,r/=128;for(;r&jh;)e[t++]=r&255|nc,r>>>=7;return e[t]=r|0,Zu.bytes=t-n+1,e}var Xh=po,Qh=128,sc=127;function po(r,n){var t=0,n=n||0,s=0,i=n,o,a=r.length;do{if(i>=a)throw po.bytes=0,new RangeError("Could not decode varint");o=r[i++],t+=s<28?(o&sc)<<s:(o&sc)*Math.pow(2,s),s+=7}while(o>=Qh);return po.bytes=i-n,t}var Jh=Math.pow(2,7),eg=Math.pow(2,14),tg=Math.pow(2,21),rg=Math.pow(2,28),ng=Math.pow(2,35),sg=Math.pow(2,42),ig=Math.pow(2,49),og=Math.pow(2,56),ag=Math.pow(2,63),cg=function(r){return r<Jh?1:r<eg?2:r<tg?3:r<rg?4:r<ng?5:r<sg?6:r<ig?7:r<og?8:r<ag?9:10},ug={encode:Zh,decode:Xh,encodingLength:cg},Ns=ug;function yo(r,e=0){return[Ns.decode(r,e),Ns.decode.bytes]}function Rs(r,e,t=0){return Ns.encode(r,e,t),e}function Bs(r){return Ns.encodingLength(r)}function en(r,e){const t=e.byteLength,n=Bs(r),s=n+Bs(t),i=new Uint8Array(s+t);return Rs(r,i,0),Rs(t,i,n),i.set(e,s),new ta(r,t,e,i)}function hi(r){const e=di(r),[t,n]=yo(e),[s,i]=yo(e.subarray(n)),o=e.subarray(n+i);if(o.byteLength!==s)throw new Error("Incorrect length");return new ta(t,s,o,e)}function lg(r,e){if(r===e)return!0;{const t=e;return r.code===t.code&&r.size===t.size&&t.bytes instanceof Uint8Array&&xh(r.bytes,t.bytes)}}class ta{constructor(e,t,n,s){u(this,"code");u(this,"size");u(this,"digest");u(this,"bytes");this.code=e,this.size=t,this.digest=n,this.bytes=s}}function ic(r,e){const{bytes:t,version:n}=r;switch(n){case 0:return fg(t,wo(r),e??Ce.encoder);default:return hg(t,wo(r),e??zt.encoder)}}const oc=new WeakMap;function wo(r){const e=oc.get(r);if(e==null){const t=new Map;return oc.set(r,t),t}return e}var mu;class ue{constructor(e,t,n,s){u(this,"code");u(this,"version");u(this,"multihash");u(this,"bytes");u(this,"/");u(this,mu,"CID");this.code=t,this.version=e,this.multihash=n,this.bytes=s,this["/"]=s}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:e,multihash:t}=this;if(e!==un)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(t.code!==gg)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return ue.createV0(t)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{const{code:e,digest:t}=this.multihash,n=en(e,t);return ue.createV1(this.code,n)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(e){return ue.equals(this,e)}static equals(e,t){const n=t;return n!=null&&e.code===n.code&&e.version===n.version&&lg(e.multihash,n.multihash)}toString(e){return ic(this,e)}toJSON(){return{"/":ic(this)}}link(){return this}[(mu=Symbol.toStringTag,Symbol.for("nodejs.util.inspect.custom"))](){return`CID(${this.toString()})`}static asCID(e){if(e==null)return null;const t=e;if(t instanceof ue)return t;if(t["/"]!=null&&t["/"]===t.bytes||t.asCID===t){const{version:n,code:s,multihash:i,bytes:o}=t;return new ue(n,s,i,o??ac(n,s,i.bytes))}else if(t[mg]===!0){const{version:n,multihash:s,code:i}=t,o=hi(s);return ue.create(n,i,o)}else return null}static create(e,t,n){if(typeof t!="number")throw new Error("String codecs are no longer supported");if(!(n.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(e){case 0:{if(t!==un)throw new Error(`Version 0 CID must use dag-pb (code: ${un}) block encoding`);return new ue(e,t,n,n.bytes)}case 1:{const s=ac(e,t,n.bytes);return new ue(e,t,n,s)}default:throw new Error("Invalid version")}}static createV0(e){return ue.create(0,un,e)}static createV1(e,t){return ue.create(1,e,t)}static decode(e){const[t,n]=ue.decodeFirst(e);if(n.length!==0)throw new Error("Incorrect length");return t}static decodeFirst(e){const t=ue.inspectBytes(e),n=t.size-t.multihashSize,s=di(e.subarray(n,n+t.multihashSize));if(s.byteLength!==t.multihashSize)throw new Error("Incorrect length");const i=s.subarray(t.multihashSize-t.digestSize),o=new ta(t.multihashCode,t.digestSize,i,s);return[t.version===0?ue.createV0(o):ue.createV1(t.codec,o),e.subarray(t.size)]}static inspectBytes(e){let t=0;const n=()=>{const[f,h]=yo(e.subarray(t));return t+=h,f};let s=n(),i=un;if(s===18?(s=0,t=0):i=n(),s!==0&&s!==1)throw new RangeError(`Invalid CID version ${s}`);const o=t,a=n(),c=n(),l=t+c,d=l-o;return{version:s,codec:i,multihashCode:a,digestSize:c,multihashSize:d,size:l}}static parse(e,t){const[n,s]=dg(e,t),i=ue.decode(s);if(i.version===0&&e[0]!=="Q")throw Error("Version 0 CID string must not include multibase prefix");return wo(i).set(n,e),i}}function dg(r,e){switch(r[0]){case"Q":{const t=e??Ce;return[Ce.prefix,t.decode(`${Ce.prefix}${r}`)]}case Ce.prefix:{const t=e??Ce;return[Ce.prefix,t.decode(r)]}case zt.prefix:{const t=e??zt;return[zt.prefix,t.decode(r)]}case ys.prefix:{const t=e??ys;return[ys.prefix,t.decode(r)]}default:{if(e==null)throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");return[r[0],e.decode(r)]}}}function fg(r,e,t){const{prefix:n}=t;if(n!==Ce.prefix)throw Error(`Cannot string encode V0 in ${t.name} encoding`);const s=e.get(n);if(s==null){const i=t.encode(r).slice(1);return e.set(n,i),i}else return s}function hg(r,e,t){const{prefix:n}=t,s=e.get(n);if(s==null){const i=t.encode(r);return e.set(n,i),i}else return s}const un=112,gg=18;function ac(r,e,t){const n=Bs(r),s=n+Bs(e),i=new Uint8Array(s+t.byteLength);return Rs(r,i,0),Rs(e,i,n),i.set(t,s),i}const mg=Symbol.for("@ipld/js-cid/CID"),ju=0,pg="identity",Yu=di;function yg(r,e){if((e==null?void 0:e.truncate)!=null&&e.truncate!==r.byteLength){if(e.truncate<0||e.truncate>r.byteLength)throw new Error(`Invalid truncate option, must be less than or equal to ${r.byteLength}`);r=r.subarray(0,e.truncate)}return en(ju,Yu(r))}const qn={code:ju,name:pg,encode:Yu,digest:yg};function Se(r,e){if(r===e)return!0;if(r.byteLength!==e.byteLength)return!1;for(let t=0;t<r.byteLength;t++)if(r[t]!==e[t])return!1;return!0}function Ie(r=0){return new Uint8Array(r)}function Ct(r=0){return new Uint8Array(r)}function cx(r){return r}function Ur(r,e){e==null&&(e=r.reduce((s,i)=>s+i.length,0));const t=Ct(e);let n=0;for(const s of r)t.set(s,n),n+=s.length;return t}const Xu=Symbol.for("@achingbrain/uint8arraylist");function cc(r,e){if(e==null||e<0)throw new RangeError("index is out of bounds");let t=0;for(const n of r){const s=t+n.byteLength;if(e<s)return{buf:n,index:e-t};t=s}throw new RangeError("index is out of bounds")}function Jn(r){return!!(r!=null&&r[Xu])}var pu;class ce{constructor(...e){u(this,"bufs");u(this,"length");u(this,pu,!0);this.bufs=[],this.length=0,e.length>0&&this.appendAll(e)}*[(pu=Xu,Symbol.iterator)](){yield*this.bufs}get byteLength(){return this.length}append(...e){this.appendAll(e)}appendAll(e){let t=0;for(const n of e)if(n instanceof Uint8Array)t+=n.byteLength,this.bufs.push(n);else if(Jn(n))t+=n.byteLength,this.bufs.push(...n.bufs);else throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");this.length+=t}prepend(...e){this.prependAll(e)}prependAll(e){let t=0;for(const n of e.reverse())if(n instanceof Uint8Array)t+=n.byteLength,this.bufs.unshift(n);else if(Jn(n))t+=n.byteLength,this.bufs.unshift(...n.bufs);else throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");this.length+=t}get(e){const t=cc(this.bufs,e);return t.buf[t.index]}set(e,t){const n=cc(this.bufs,e);n.buf[n.index]=t}write(e,t=0){if(e instanceof Uint8Array)for(let n=0;n<e.length;n++)this.set(t+n,e[n]);else if(Jn(e))for(let n=0;n<e.length;n++)this.set(t+n,e.get(n));else throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList")}consume(e){if(e=Math.trunc(e),!(Number.isNaN(e)||e<=0)){if(e===this.byteLength){this.bufs=[],this.length=0;return}for(;this.bufs.length>0;)if(e>=this.bufs[0].byteLength)e-=this.bufs[0].byteLength,this.length-=this.bufs[0].byteLength,this.bufs.shift();else{this.bufs[0]=this.bufs[0].subarray(e),this.length-=e;break}}}slice(e,t){const{bufs:n,length:s}=this._subList(e,t);return Ur(n,s)}subarray(e,t){const{bufs:n,length:s}=this._subList(e,t);return n.length===1?n[0]:Ur(n,s)}sublist(e,t){const{bufs:n,length:s}=this._subList(e,t),i=new ce;return i.length=s,i.bufs=[...n],i}_subList(e,t){if(e=e??0,t=t??this.length,e<0&&(e=this.length+e),t<0&&(t=this.length+t),e<0||t>this.length)throw new RangeError("index is out of bounds");if(e===t)return{bufs:[],length:0};if(e===0&&t===this.length)return{bufs:this.bufs,length:this.length};const n=[];let s=0;for(let i=0;i<this.bufs.length;i++){const o=this.bufs[i],a=s,c=a+o.byteLength;if(s=c,e>=c)continue;const l=e>=a&&e<c,d=t>a&&t<=c;if(l&&d){if(e===a&&t===c){n.push(o);break}const f=e-a;n.push(o.subarray(f,f+(t-e)));break}if(l){if(e===0){n.push(o);continue}n.push(o.subarray(e-a));continue}if(d){if(t===c){n.push(o);break}n.push(o.subarray(0,t-a));break}n.push(o)}return{bufs:n,length:t-e}}indexOf(e,t=0){if(!Jn(e)&&!(e instanceof Uint8Array))throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');const n=e instanceof Uint8Array?e:e.subarray();if(t=Number(t??0),isNaN(t)&&(t=0),t<0&&(t=this.length+t),t<0&&(t=0),e.length===0)return t>this.length?this.length:t;const s=n.byteLength;if(s===0)throw new TypeError("search must be at least 1 byte long");const i=256,o=new Int32Array(i);for(let f=0;f<i;f++)o[f]=-1;for(let f=0;f<s;f++)o[n[f]]=f;const a=o,c=this.byteLength-n.byteLength,l=n.byteLength-1;let d;for(let f=t;f<=c;f+=d){d=0;for(let h=l;h>=0;h--){const p=this.get(f+h);if(n[h]!==p){d=Math.max(1,h-a[p]);break}}if(d===0)return f}return-1}getInt8(e){const t=this.subarray(e,e+1);return new DataView(t.buffer,t.byteOffset,t.byteLength).getInt8(0)}setInt8(e,t){const n=Ct(1);new DataView(n.buffer,n.byteOffset,n.byteLength).setInt8(0,t),this.write(n,e)}getInt16(e,t){const n=this.subarray(e,e+2);return new DataView(n.buffer,n.byteOffset,n.byteLength).getInt16(0,t)}setInt16(e,t,n){const s=Ie(2);new DataView(s.buffer,s.byteOffset,s.byteLength).setInt16(0,t,n),this.write(s,e)}getInt32(e,t){const n=this.subarray(e,e+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getInt32(0,t)}setInt32(e,t,n){const s=Ie(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setInt32(0,t,n),this.write(s,e)}getBigInt64(e,t){const n=this.subarray(e,e+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getBigInt64(0,t)}setBigInt64(e,t,n){const s=Ie(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setBigInt64(0,t,n),this.write(s,e)}getUint8(e){const t=this.subarray(e,e+1);return new DataView(t.buffer,t.byteOffset,t.byteLength).getUint8(0)}setUint8(e,t){const n=Ct(1);new DataView(n.buffer,n.byteOffset,n.byteLength).setUint8(0,t),this.write(n,e)}getUint16(e,t){const n=this.subarray(e,e+2);return new DataView(n.buffer,n.byteOffset,n.byteLength).getUint16(0,t)}setUint16(e,t,n){const s=Ie(2);new DataView(s.buffer,s.byteOffset,s.byteLength).setUint16(0,t,n),this.write(s,e)}getUint32(e,t){const n=this.subarray(e,e+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getUint32(0,t)}setUint32(e,t,n){const s=Ie(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setUint32(0,t,n),this.write(s,e)}getBigUint64(e,t){const n=this.subarray(e,e+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getBigUint64(0,t)}setBigUint64(e,t,n){const s=Ie(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setBigUint64(0,t,n),this.write(s,e)}getFloat32(e,t){const n=this.subarray(e,e+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getFloat32(0,t)}setFloat32(e,t,n){const s=Ie(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setFloat32(0,t,n),this.write(s,e)}getFloat64(e,t){const n=this.subarray(e,e+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getFloat64(0,t)}setFloat64(e,t,n){const s=Ie(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setFloat64(0,t,n),this.write(s,e)}equals(e){if(e==null||!(e instanceof ce)||e.bufs.length!==this.bufs.length)return!1;for(let t=0;t<this.bufs.length;t++)if(!Se(this.bufs[t],e.bufs[t]))return!1;return!0}static fromUint8Arrays(e,t){const n=new ce;return n.bufs=e,t==null&&(t=e.reduce((s,i)=>s+i.byteLength,0)),n.length=t,n}}const wg=zn({prefix:"9",name:"base10",alphabet:"0123456789"}),bg=Object.freeze(Object.defineProperty({__proto__:null,base10:wg},Symbol.toStringTag,{value:"Module"})),Eg=De({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),vg=De({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),xg=Object.freeze(Object.defineProperty({__proto__:null,base16:Eg,base16upper:vg},Symbol.toStringTag,{value:"Module"})),Sg=De({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),_g=Object.freeze(Object.defineProperty({__proto__:null,base2:Sg},Symbol.toStringTag,{value:"Module"})),Qu=Array.from("ðŸš€ðŸªâ˜„ðŸ›°ðŸŒŒðŸŒ‘ðŸŒ’ðŸŒ“ðŸŒ”ðŸŒ•ðŸŒ–ðŸŒ—ðŸŒ˜ðŸŒðŸŒðŸŒŽðŸ‰â˜€ðŸ’»ðŸ–¥ðŸ’¾ðŸ’¿ðŸ˜‚â¤ðŸ˜ðŸ¤£ðŸ˜ŠðŸ™ðŸ’•ðŸ˜­ðŸ˜˜ðŸ‘ðŸ˜…ðŸ‘ðŸ˜ðŸ”¥ðŸ¥°ðŸ’”ðŸ’–ðŸ’™ðŸ˜¢ðŸ¤”ðŸ˜†ðŸ™„ðŸ’ªðŸ˜‰â˜ºðŸ‘ŒðŸ¤—ðŸ’œðŸ˜”ðŸ˜ŽðŸ˜‡ðŸŒ¹ðŸ¤¦ðŸŽ‰ðŸ’žâœŒâœ¨ðŸ¤·ðŸ˜±ðŸ˜ŒðŸŒ¸ðŸ™ŒðŸ˜‹ðŸ’—ðŸ’šðŸ˜ðŸ’›ðŸ™‚ðŸ’“ðŸ¤©ðŸ˜„ðŸ˜€ðŸ–¤ðŸ˜ƒðŸ’¯ðŸ™ˆðŸ‘‡ðŸŽ¶ðŸ˜’ðŸ¤­â£ðŸ˜œðŸ’‹ðŸ‘€ðŸ˜ªðŸ˜‘ðŸ’¥ðŸ™‹ðŸ˜žðŸ˜©ðŸ˜¡ðŸ¤ªðŸ‘ŠðŸ¥³ðŸ˜¥ðŸ¤¤ðŸ‘‰ðŸ’ƒðŸ˜³âœ‹ðŸ˜šðŸ˜ðŸ˜´ðŸŒŸðŸ˜¬ðŸ™ƒðŸ€ðŸŒ·ðŸ˜»ðŸ˜“â­âœ…ðŸ¥ºðŸŒˆðŸ˜ˆðŸ¤˜ðŸ’¦âœ”ðŸ˜£ðŸƒðŸ’â˜¹ðŸŽŠðŸ’˜ðŸ˜ â˜ðŸ˜•ðŸŒºðŸŽ‚ðŸŒ»ðŸ˜ðŸ–•ðŸ’ðŸ™ŠðŸ˜¹ðŸ—£ðŸ’«ðŸ’€ðŸ‘‘ðŸŽµðŸ¤žðŸ˜›ðŸ”´ðŸ˜¤ðŸŒ¼ðŸ˜«âš½ðŸ¤™â˜•ðŸ†ðŸ¤«ðŸ‘ˆðŸ˜®ðŸ™†ðŸ»ðŸƒðŸ¶ðŸ’ðŸ˜²ðŸŒ¿ðŸ§¡ðŸŽâš¡ðŸŒžðŸŽˆâŒâœŠðŸ‘‹ðŸ˜°ðŸ¤¨ðŸ˜¶ðŸ¤ðŸš¶ðŸ’°ðŸ“ðŸ’¢ðŸ¤ŸðŸ™ðŸš¨ðŸ’¨ðŸ¤¬âœˆðŸŽ€ðŸºðŸ¤“ðŸ˜™ðŸ’ŸðŸŒ±ðŸ˜–ðŸ‘¶ðŸ¥´â–¶âž¡â“ðŸ’ŽðŸ’¸â¬‡ðŸ˜¨ðŸŒšðŸ¦‹ðŸ˜·ðŸ•ºâš ðŸ™…ðŸ˜ŸðŸ˜µðŸ‘ŽðŸ¤²ðŸ¤ ðŸ¤§ðŸ“ŒðŸ”µðŸ’…ðŸ§ðŸ¾ðŸ’ðŸ˜—ðŸ¤‘ðŸŒŠðŸ¤¯ðŸ·â˜ŽðŸ’§ðŸ˜¯ðŸ’†ðŸ‘†ðŸŽ¤ðŸ™‡ðŸ‘â„ðŸŒ´ðŸ’£ðŸ¸ðŸ’ŒðŸ“ðŸ¥€ðŸ¤¢ðŸ‘…ðŸ’¡ðŸ’©ðŸ‘ðŸ“¸ðŸ‘»ðŸ¤ðŸ¤®ðŸŽ¼ðŸ¥µðŸš©ðŸŽðŸŠðŸ‘¼ðŸ’ðŸ“£ðŸ¥‚"),Ag=Qu.reduce((r,e,t)=>(r[t]=e,r),[]),Ig=Qu.reduce((r,e,t)=>{const n=e.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${e}`);return r[n]=t,r},[]);function Cg(r){return r.reduce((e,t)=>(e+=Ag[t],e),"")}function Lg(r){const e=[];for(const t of r){const n=t.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${t}`);const s=Ig[n];if(s==null)throw new Error(`Non-base256emoji character: ${t}`);e.push(s)}return new Uint8Array(e)}const Tg=fi({prefix:"ðŸš€",name:"base256emoji",encode:Cg,decode:Lg}),Dg=Object.freeze(Object.defineProperty({__proto__:null,base256emoji:Tg},Symbol.toStringTag,{value:"Module"})),Ju=De({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),kg=De({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),el=De({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),Pg=De({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6}),Mg=Object.freeze(Object.defineProperty({__proto__:null,base64:Ju,base64pad:kg,base64url:el,base64urlpad:Pg},Symbol.toStringTag,{value:"Module"})),Ng=De({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),Rg=Object.freeze(Object.defineProperty({__proto__:null,base8:Ng},Symbol.toStringTag,{value:"Module"})),Bg=fi({prefix:"\0",name:"identity",encode:r=>_h(r),decode:r=>Sh(r)}),Fg=Object.freeze(Object.defineProperty({__proto__:null,identity:Bg},Symbol.toStringTag,{value:"Module"}));new TextEncoder;new TextDecoder;const ux=85,Og=20;function $g({name:r,code:e,encode:t,minDigestLength:n,maxDigestLength:s}){return new Ug(r,e,t,n,s)}class Ug{constructor(e,t,n,s,i){u(this,"name");u(this,"code");u(this,"encode");u(this,"minDigestLength");u(this,"maxDigestLength");this.name=e,this.code=t,this.encode=n,this.minDigestLength=s??Og,this.maxDigestLength=i}digest(e,t){if((t==null?void 0:t.truncate)!=null){if(t.truncate<this.minDigestLength)throw new Error(`Invalid truncate option, must be greater than or equal to ${this.minDigestLength}`);if(this.maxDigestLength!=null&&t.truncate>this.maxDigestLength)throw new Error(`Invalid truncate option, must be less than or equal to ${this.maxDigestLength}`)}if(e instanceof Uint8Array){const n=this.encode(e);return n instanceof Uint8Array?uc(n,this.code,t==null?void 0:t.truncate):n.then(s=>uc(s,this.code,t==null?void 0:t.truncate))}else throw Error("Unknown type, must be binary type")}}function uc(r,e,t){if(t!=null&&t!==r.byteLength){if(t>r.byteLength)throw new Error(`Invalid truncate option, must be less than or equal to ${r.byteLength}`);r=r.subarray(0,t)}return en(e,r)}function zg(r){return async e=>new Uint8Array(await crypto.subtle.digest(r,e))}const ra=$g({name:"sha2-256",code:18,encode:zg("SHA-256")}),bo={...Fg,..._g,...Rg,...bg,...xg,...Hh,...Gh,...Bh,...Mg,...Dg};function tl(r,e,t,n){return{name:r,prefix:e,encoder:{name:r,prefix:e,encode:t},decoder:{decode:n}}}const lc=tl("utf8","u",r=>"u"+new TextDecoder("utf8").decode(r),r=>new TextEncoder().encode(r.substring(1))),Pi=tl("ascii","a",r=>{let e="a";for(let t=0;t<r.length;t++)e+=String.fromCharCode(r[t]);return e},r=>{r=r.substring(1);const e=Ct(r.length);for(let t=0;t<r.length;t++)e[t]=r.charCodeAt(t);return e}),rl={utf8:lc,"utf-8":lc,hex:bo.base16,latin1:Pi,ascii:Pi,binary:Pi,...bo};function W(r,e="utf8"){const t=rl[e];if(t==null)throw new Error(`Unsupported encoding "${e}"`);return t.decoder.decode(`${t.prefix}${r}`)}function X(r,e="utf8"){const t=rl[e];if(t==null)throw new Error(`Unsupported encoding "${e}"`);return t.encoder.encode(r).substring(1)}const qg=parseInt("11111",2),Eo=parseInt("10000000",2),Kg=parseInt("01111111",2),dc={0:ln,1:ln,2:Vg,3:Gg,4:Zg,5:Wg,6:Hg,16:ln,22:ln,48:ln};function tn(r,e={offset:0}){const t=r[e.offset]&qg;if(e.offset++,dc[t]!=null)return dc[t](r,e);throw new Error("No decoder for tag "+t)}function Kn(r,e){let t=0;if((r[e.offset]&Eo)===Eo){const n=r[e.offset]&Kg;let s="0x";e.offset++;for(let i=0;i<n;i++,e.offset++)s+=r[e.offset].toString(16).padStart(2,"0");t=parseInt(s,16)}else t=r[e.offset],e.offset++;return t}function ln(r,e){Kn(r,e);const t=[];for(;!(e.offset>=r.byteLength);){const n=tn(r,e);if(n===null)break;t.push(n)}return t}function Vg(r,e){const t=Kn(r,e),n=e.offset,s=e.offset+t,i=[];for(let o=n;o<s;o++)o===n&&r[o]===0||i.push(r[o]);return e.offset+=t,Uint8Array.from(i)}function Hg(r,e){const t=Kn(r,e),n=e.offset+t,s=r[e.offset];e.offset++;let i=0,o=0;s<40?(i=0,o=s):s<80?(i=1,o=s-40):(i=2,o=s-80);let a=`${i}.${o}`,c=[];for(;e.offset<n;){const l=r[e.offset];if(e.offset++,c.push(l&127),l<128){c.reverse();let d=0;for(let f=0;f<c.length;f++)d+=c[f]<<f*7;a+=`.${d}`,c=[]}}return a}function Wg(r,e){return e.offset++,null}function Gg(r,e){const t=Kn(r,e),n=r[e.offset];e.offset++;const s=r.subarray(e.offset,e.offset+t-1);if(e.offset+=t,n!==0)throw new Error("Unused bits in bit string is unimplemented");return s}function Zg(r,e){const t=Kn(r,e),n=r.subarray(e.offset,e.offset+t);return e.offset+=t,n}function jg(r){let e=r.toString(16);e.length%2===1&&(e="0"+e);const t=new ce;for(let n=0;n<e.length;n+=2)t.append(Uint8Array.from([parseInt(`${e[n]}${e[n+1]}`,16)]));return t}function gi(r){if(r.byteLength<128)return Uint8Array.from([r.byteLength]);const e=jg(r.byteLength);return new ce(Uint8Array.from([e.byteLength|Eo]),e)}function Ve(r){const e=new ce,t=128;return(r.subarray()[0]&t)===t&&e.append(Uint8Array.from([0])),e.append(r),new ce(Uint8Array.from([2]),gi(e),e)}function na(r){const e=Uint8Array.from([0]),t=new ce(e,r);return new ce(Uint8Array.from([3]),gi(t),t)}function Yg(r){return new ce(Uint8Array.from([4]),gi(r),r)}function At(r,e=48){const t=new ce;for(const n of r)t.append(n);return new ce(Uint8Array.from([e]),gi(t),t)}async function Xg(r="P-256"){const e=await crypto.subtle.generateKey({name:"ECDSA",namedCurve:r},!0,["sign","verify"]);return{publicKey:await crypto.subtle.exportKey("jwk",e.publicKey),privateKey:await crypto.subtle.exportKey("jwk",e.privateKey)}}async function Qg(r,e,t){var i,o;const n=await crypto.subtle.importKey("jwk",r,{name:"ECDSA",namedCurve:r.crv??"P-256"},!1,["sign"]);(i=t==null?void 0:t.signal)==null||i.throwIfAborted();const s=await crypto.subtle.sign({name:"ECDSA",hash:{name:"SHA-256"}},n,e.subarray());return(o=t==null?void 0:t.signal)==null||o.throwIfAborted(),new Uint8Array(s,0,s.byteLength)}async function Jg(r,e,t,n){var o,a;const s=await crypto.subtle.importKey("jwk",r,{name:"ECDSA",namedCurve:r.crv??"P-256"},!1,["verify"]);(o=n==null?void 0:n.signal)==null||o.throwIfAborted();const i=await crypto.subtle.verify({name:"ECDSA",hash:{name:"SHA-256"}},s,e,t.subarray());return(a=n==null?void 0:n.signal)==null||a.throwIfAborted(),i}const em=Uint8Array.from([6,8,42,134,72,206,61,3,1,7]),tm=Uint8Array.from([6,5,43,129,4,0,34]),rm=Uint8Array.from([6,5,43,129,4,0,35]),nl={ext:!0,kty:"EC",crv:"P-256"},sl={ext:!0,kty:"EC",crv:"P-384"},il={ext:!0,kty:"EC",crv:"P-521"},Ar=32,Ir=48,Cr=66;function nm(r){const e=tn(r);return sm(e)}function sm(r){const e=r[1],t=X(e,"base64url"),n=r[2][1][0],s=1;let i,o;if(e.byteLength===Ar)return i=X(n.subarray(s,s+Ar),"base64url"),o=X(n.subarray(s+Ar),"base64url"),new bs({...nl,key_ops:["sign"],d:t,x:i,y:o});if(e.byteLength===Ir)return i=X(n.subarray(s,s+Ir),"base64url"),o=X(n.subarray(s+Ir),"base64url"),new bs({...sl,key_ops:["sign"],d:t,x:i,y:o});if(e.byteLength===Cr)return i=X(n.subarray(s,s+Cr),"base64url"),o=X(n.subarray(s+Cr),"base64url"),new bs({...il,key_ops:["sign"],d:t,x:i,y:o});throw new Z(`Private key length was wrong length, got ${e.byteLength}, expected 32, 48 or 66`)}function ol(r){const e=tn(r);return im(e)}function im(r){const e=r[1][1][0],t=1;let n,s;if(e.byteLength===Ar*2+1)return n=X(e.subarray(t,t+Ar),"base64url"),s=X(e.subarray(t+Ar),"base64url"),new ws({...nl,key_ops:["verify"],x:n,y:s});if(e.byteLength===Ir*2+1)return n=X(e.subarray(t,t+Ir),"base64url"),s=X(e.subarray(t+Ir),"base64url"),new ws({...sl,key_ops:["verify"],x:n,y:s});if(e.byteLength===Cr*2+1)return n=X(e.subarray(t,t+Cr),"base64url"),s=X(e.subarray(t+Cr),"base64url"),new ws({...il,key_ops:["verify"],x:n,y:s});throw new Z(`coordinates were wrong length, got ${e.byteLength}, expected 65, 97 or 133`)}function om(r){return At([Ve(Uint8Array.from([1])),Yg(W(r.d??"","base64url")),At([al(r.crv)],160),At([na(new ce(Uint8Array.from([4]),W(r.x??"","base64url"),W(r.y??"","base64url")))],161)]).subarray()}function am(r){return At([Ve(Uint8Array.from([1])),At([al(r.crv)],160),At([na(new ce(Uint8Array.from([4]),W(r.x??"","base64url"),W(r.y??"","base64url")))],161)]).subarray()}function al(r){if(r==="P-256")return em;if(r==="P-384")return tm;if(r==="P-521")return rm;throw new Z(`Invalid curve ${r}`)}async function cm(r="P-256"){const e=await Xg(r);return new bs(e.privateKey)}class ws{constructor(e){u(this,"type","ECDSA");u(this,"jwk");u(this,"_raw");this.jwk=e}get raw(){return this._raw==null&&(this._raw=am(this.jwk)),this._raw}toMultihash(){return qn.digest(ir(this))}toCID(){return ue.createV1(114,this.toMultihash())}toString(){return Ce.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:Se(this.raw,e.raw)}async verify(e,t,n){return Jg(this.jwk,t,e,n)}}class bs{constructor(e){u(this,"type","ECDSA");u(this,"jwk");u(this,"publicKey");u(this,"_raw");this.jwk=e,this.publicKey=new ws({crv:e.crv,ext:e.ext,key_ops:["verify"],kty:"EC",x:e.x,y:e.y})}get raw(){return this._raw==null&&(this._raw=om(this.jwk)),this._raw}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:Se(this.raw,e.raw)}async sign(e,t){return Qg(this.jwk,e,t)}}/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function mi(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function or(r,e=""){if(!Number.isSafeInteger(r)||r<0){const t=e&&`"${e}" `;throw new Error(`${t}expected integer >= 0, got ${r}`)}}function ee(r,e,t=""){const n=mi(r),s=r==null?void 0:r.length,i=e!==void 0;if(!n||i&&s!==e){const o=t&&`"${t}" `,a=i?` of length ${e}`:"",c=n?`length=${s}`:`type=${typeof r}`;throw new Error(o+"expected Uint8Array"+a+", got "+c)}return r}function cl(r){if(typeof r!="function"||typeof r.create!="function")throw new Error("Hash must wrapped by utils.createHasher");or(r.outputLen),or(r.blockLen)}function Fs(r,e=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(e&&r.finished)throw new Error("Hash#digest() has already been called")}function um(r,e){ee(r,void 0,"digestInto() output");const t=e.outputLen;if(r.length<t)throw new Error('"digestInto() output" expected to be of length >='+t)}function zr(...r){for(let e=0;e<r.length;e++)r[e].fill(0)}function Mi(r){return new DataView(r.buffer,r.byteOffset,r.byteLength)}function at(r,e){return r<<32-e|r>>>e}const ul=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",lm=Array.from({length:256},(r,e)=>e.toString(16).padStart(2,"0"));function Vn(r){if(ee(r),ul)return r.toHex();let e="";for(let t=0;t<r.length;t++)e+=lm[r[t]];return e}const yt={_0:48,_9:57,A:65,F:70,a:97,f:102};function fc(r){if(r>=yt._0&&r<=yt._9)return r-yt._0;if(r>=yt.A&&r<=yt.F)return r-(yt.A-10);if(r>=yt.a&&r<=yt.f)return r-(yt.a-10)}function In(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);if(ul)return Uint8Array.fromHex(r);const e=r.length,t=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);const n=new Uint8Array(t);for(let s=0,i=0;s<t;s++,i+=2){const o=fc(r.charCodeAt(i)),a=fc(r.charCodeAt(i+1));if(o===void 0||a===void 0){const c=r[i]+r[i+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+i)}n[s]=o*16+a}return n}function ft(...r){let e=0;for(let n=0;n<r.length;n++){const s=r[n];ee(s),e+=s.length}const t=new Uint8Array(e);for(let n=0,s=0;n<r.length;n++){const i=r[n];t.set(i,s),s+=i.length}return t}function ll(r,e={}){const t=(s,i)=>r(i).update(s).digest(),n=r(void 0);return t.outputLen=n.outputLen,t.blockLen=n.blockLen,t.create=s=>r(s),Object.assign(t,e),Object.freeze(t)}function Hn(r=32){const e=typeof globalThis=="object"?globalThis.crypto:null;if(typeof(e==null?void 0:e.getRandomValues)!="function")throw new Error("crypto.getRandomValues must be defined");return e.getRandomValues(new Uint8Array(r))}const dl=r=>({oid:Uint8Array.from([6,9,96,134,72,1,101,3,4,2,r])});function dm(r,e,t){return r&e^~r&t}function fm(r,e,t){return r&e^r&t^e&t}class fl{constructor(e,t,n,s){u(this,"blockLen");u(this,"outputLen");u(this,"padOffset");u(this,"isLE");u(this,"buffer");u(this,"view");u(this,"finished",!1);u(this,"length",0);u(this,"pos",0);u(this,"destroyed",!1);this.blockLen=e,this.outputLen=t,this.padOffset=n,this.isLE=s,this.buffer=new Uint8Array(e),this.view=Mi(this.buffer)}update(e){Fs(this),ee(e);const{view:t,buffer:n,blockLen:s}=this,i=e.length;for(let o=0;o<i;){const a=Math.min(s-this.pos,i-o);if(a===s){const c=Mi(e);for(;s<=i-o;o+=s)this.process(c,o);continue}n.set(e.subarray(o,o+a),this.pos),this.pos+=a,o+=a,this.pos===s&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){Fs(this),um(e,this),this.finished=!0;const{buffer:t,view:n,blockLen:s,isLE:i}=this;let{pos:o}=this;t[o++]=128,zr(this.buffer.subarray(o)),this.padOffset>s-o&&(this.process(n,0),o=0);for(let f=o;f<s;f++)t[f]=0;n.setBigUint64(s-8,BigInt(this.length*8),i),this.process(n,0);const a=Mi(e),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen must be aligned to 32bit");const l=c/4,d=this.get();if(l>d.length)throw new Error("_sha2: outputLen bigger than state");for(let f=0;f<l;f++)a.setUint32(4*f,d[f],i)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const n=e.slice(0,t);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:n,length:s,finished:i,destroyed:o,pos:a}=this;return e.destroyed=o,e.finished=i,e.length=s,e.pos=a,s%t&&e.buffer.set(n),e}clone(){return this._cloneInto()}}const kt=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Pe=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),es=BigInt(2**32-1),hc=BigInt(32);function hm(r,e=!1){return e?{h:Number(r&es),l:Number(r>>hc&es)}:{h:Number(r>>hc&es)|0,l:Number(r&es)|0}}function gm(r,e=!1){const t=r.length;let n=new Uint32Array(t),s=new Uint32Array(t);for(let i=0;i<t;i++){const{h:o,l:a}=hm(r[i],e);[n[i],s[i]]=[o,a]}return[n,s]}const gc=(r,e,t)=>r>>>t,mc=(r,e,t)=>r<<32-t|e>>>t,pr=(r,e,t)=>r>>>t|e<<32-t,yr=(r,e,t)=>r<<32-t|e>>>t,ts=(r,e,t)=>r<<64-t|e>>>t-32,rs=(r,e,t)=>r>>>t-32|e<<64-t;function wt(r,e,t,n){const s=(e>>>0)+(n>>>0);return{h:r+t+(s/2**32|0)|0,l:s|0}}const mm=(r,e,t)=>(r>>>0)+(e>>>0)+(t>>>0),pm=(r,e,t,n)=>e+t+n+(r/2**32|0)|0,ym=(r,e,t,n)=>(r>>>0)+(e>>>0)+(t>>>0)+(n>>>0),wm=(r,e,t,n,s)=>e+t+n+s+(r/2**32|0)|0,bm=(r,e,t,n,s)=>(r>>>0)+(e>>>0)+(t>>>0)+(n>>>0)+(s>>>0),Em=(r,e,t,n,s,i)=>e+t+n+s+i+(r/2**32|0)|0,vm=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Pt=new Uint32Array(64);class xm extends fl{constructor(e){super(64,e,8,!1)}get(){const{A:e,B:t,C:n,D:s,E:i,F:o,G:a,H:c}=this;return[e,t,n,s,i,o,a,c]}set(e,t,n,s,i,o,a,c){this.A=e|0,this.B=t|0,this.C=n|0,this.D=s|0,this.E=i|0,this.F=o|0,this.G=a|0,this.H=c|0}process(e,t){for(let f=0;f<16;f++,t+=4)Pt[f]=e.getUint32(t,!1);for(let f=16;f<64;f++){const h=Pt[f-15],p=Pt[f-2],g=at(h,7)^at(h,18)^h>>>3,y=at(p,17)^at(p,19)^p>>>10;Pt[f]=y+Pt[f-7]+g+Pt[f-16]|0}let{A:n,B:s,C:i,D:o,E:a,F:c,G:l,H:d}=this;for(let f=0;f<64;f++){const h=at(a,6)^at(a,11)^at(a,25),p=d+h+dm(a,c,l)+vm[f]+Pt[f]|0,y=(at(n,2)^at(n,13)^at(n,22))+fm(n,s,i)|0;d=l,l=c,c=a,a=o+p|0,o=i,i=s,s=n,n=p+y|0}n=n+this.A|0,s=s+this.B|0,i=i+this.C|0,o=o+this.D|0,a=a+this.E|0,c=c+this.F|0,l=l+this.G|0,d=d+this.H|0,this.set(n,s,i,o,a,c,l,d)}roundClean(){zr(Pt)}destroy(){this.set(0,0,0,0,0,0,0,0),zr(this.buffer)}}class Sm extends xm{constructor(){super(32);u(this,"A",kt[0]|0);u(this,"B",kt[1]|0);u(this,"C",kt[2]|0);u(this,"D",kt[3]|0);u(this,"E",kt[4]|0);u(this,"F",kt[5]|0);u(this,"G",kt[6]|0);u(this,"H",kt[7]|0)}}const hl=gm(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(r=>BigInt(r))),_m=hl[0],Am=hl[1],Mt=new Uint32Array(80),Nt=new Uint32Array(80);class Im extends fl{constructor(e){super(128,e,16,!1)}get(){const{Ah:e,Al:t,Bh:n,Bl:s,Ch:i,Cl:o,Dh:a,Dl:c,Eh:l,El:d,Fh:f,Fl:h,Gh:p,Gl:g,Hh:y,Hl:m}=this;return[e,t,n,s,i,o,a,c,l,d,f,h,p,g,y,m]}set(e,t,n,s,i,o,a,c,l,d,f,h,p,g,y,m){this.Ah=e|0,this.Al=t|0,this.Bh=n|0,this.Bl=s|0,this.Ch=i|0,this.Cl=o|0,this.Dh=a|0,this.Dl=c|0,this.Eh=l|0,this.El=d|0,this.Fh=f|0,this.Fl=h|0,this.Gh=p|0,this.Gl=g|0,this.Hh=y|0,this.Hl=m|0}process(e,t){for(let E=0;E<16;E++,t+=4)Mt[E]=e.getUint32(t),Nt[E]=e.getUint32(t+=4);for(let E=16;E<80;E++){const C=Mt[E-15]|0,A=Nt[E-15]|0,N=pr(C,A,1)^pr(C,A,8)^gc(C,A,7),R=yr(C,A,1)^yr(C,A,8)^mc(C,A,7),L=Mt[E-2]|0,T=Nt[E-2]|0,V=pr(L,T,19)^ts(L,T,61)^gc(L,T,6),Y=yr(L,T,19)^rs(L,T,61)^mc(L,T,6),$=ym(R,Y,Nt[E-7],Nt[E-16]),U=wm($,N,V,Mt[E-7],Mt[E-16]);Mt[E]=U|0,Nt[E]=$|0}let{Ah:n,Al:s,Bh:i,Bl:o,Ch:a,Cl:c,Dh:l,Dl:d,Eh:f,El:h,Fh:p,Fl:g,Gh:y,Gl:m,Hh:_,Hl:x}=this;for(let E=0;E<80;E++){const C=pr(f,h,14)^pr(f,h,18)^ts(f,h,41),A=yr(f,h,14)^yr(f,h,18)^rs(f,h,41),N=f&p^~f&y,R=h&g^~h&m,L=bm(x,A,R,Am[E],Nt[E]),T=Em(L,_,C,N,_m[E],Mt[E]),V=L|0,Y=pr(n,s,28)^ts(n,s,34)^ts(n,s,39),$=yr(n,s,28)^rs(n,s,34)^rs(n,s,39),U=n&i^n&a^i&a,w=s&o^s&c^o&c;_=y|0,x=m|0,y=p|0,m=g|0,p=f|0,g=h|0,{h:f,l:h}=wt(l|0,d|0,T|0,V|0),l=a|0,d=c|0,a=i|0,c=o|0,i=n|0,o=s|0;const b=mm(V,$,w);n=pm(b,T,Y,U),s=b|0}({h:n,l:s}=wt(this.Ah|0,this.Al|0,n|0,s|0)),{h:i,l:o}=wt(this.Bh|0,this.Bl|0,i|0,o|0),{h:a,l:c}=wt(this.Ch|0,this.Cl|0,a|0,c|0),{h:l,l:d}=wt(this.Dh|0,this.Dl|0,l|0,d|0),{h:f,l:h}=wt(this.Eh|0,this.El|0,f|0,h|0),{h:p,l:g}=wt(this.Fh|0,this.Fl|0,p|0,g|0),{h:y,l:m}=wt(this.Gh|0,this.Gl|0,y|0,m|0),{h:_,l:x}=wt(this.Hh|0,this.Hl|0,_|0,x|0),this.set(n,s,i,o,a,c,l,d,f,h,p,g,y,m,_,x)}roundClean(){zr(Mt,Nt)}destroy(){zr(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}class Cm extends Im{constructor(){super(64);u(this,"Ah",Pe[0]|0);u(this,"Al",Pe[1]|0);u(this,"Bh",Pe[2]|0);u(this,"Bl",Pe[3]|0);u(this,"Ch",Pe[4]|0);u(this,"Cl",Pe[5]|0);u(this,"Dh",Pe[6]|0);u(this,"Dl",Pe[7]|0);u(this,"Eh",Pe[8]|0);u(this,"El",Pe[9]|0);u(this,"Fh",Pe[10]|0);u(this,"Fl",Pe[11]|0);u(this,"Gh",Pe[12]|0);u(this,"Gl",Pe[13]|0);u(this,"Hh",Pe[14]|0);u(this,"Hl",Pe[15]|0)}}const pi=ll(()=>new Sm,dl(1)),Lm=ll(()=>new Cm,dl(3));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const sa=BigInt(0),vo=BigInt(1);function ar(r,e=""){if(typeof r!="boolean"){const t=e&&`"${e}" `;throw new Error(t+"expected boolean, got type="+typeof r)}return r}function gl(r){if(typeof r=="bigint"){if(!Es(r))throw new Error("positive bigint expected, got "+r)}else or(r);return r}function ns(r){const e=gl(r).toString(16);return e.length&1?"0"+e:e}function ml(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);return r===""?sa:BigInt("0x"+r)}function yi(r){return ml(Vn(r))}function cr(r){return ml(Vn(Cn(ee(r)).reverse()))}function ia(r,e){or(e),r=gl(r);const t=In(r.toString(16).padStart(e*2,"0"));if(t.length!==e)throw new Error("number too large");return t}function oa(r,e){return ia(r,e).reverse()}function Cn(r){return Uint8Array.from(r)}const Es=r=>typeof r=="bigint"&&sa<=r;function Tm(r,e,t){return Es(r)&&Es(e)&&Es(t)&&e<=r&&r<t}function Ln(r,e,t,n){if(!Tm(e,t,n))throw new Error("expected valid "+r+": "+t+" <= n < "+n+", got "+e)}function Dm(r){let e;for(e=0;r>sa;r>>=vo,e+=1);return e}const aa=r=>(vo<<BigInt(r))-vo;function km(r,e,t){if(or(r,"hashLen"),or(e,"qByteLen"),typeof t!="function")throw new Error("hmacFn must be a function");const n=m=>new Uint8Array(m),s=Uint8Array.of(),i=Uint8Array.of(0),o=Uint8Array.of(1),a=1e3;let c=n(r),l=n(r),d=0;const f=()=>{c.fill(1),l.fill(0),d=0},h=(...m)=>t(l,ft(c,...m)),p=(m=s)=>{l=h(i,m),c=h(),m.length!==0&&(l=h(o,m),c=h())},g=()=>{if(d++>=a)throw new Error("drbg: tried max amount of iterations");let m=0;const _=[];for(;m<e;){c=h();const x=c.slice();_.push(x),m+=c.length}return ft(..._)};return(m,_)=>{f(),p(m);let x;for(;!(x=_(g()));)p();return f(),x}}function rn(r,e={},t={}){if(!r||typeof r!="object")throw new Error("expected valid options object");function n(i,o,a){const c=r[i];if(a&&c===void 0)return;const l=typeof c;if(l!==o||c===null)throw new Error(`param "${i}" is invalid: expected ${o}, got ${l}`)}const s=(i,o)=>Object.entries(i).forEach(([a,c])=>n(a,c,o));s(e,!1),s(t,!0)}function Os(r){const e=new WeakMap;return(t,...n)=>{const s=e.get(t);if(s!==void 0)return s;const i=r(t,...n);return e.set(t,i),i}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const qe=BigInt(0),Te=BigInt(1),jt=BigInt(2),pl=BigInt(3),yl=BigInt(4),wl=BigInt(5),Pm=BigInt(7),bl=BigInt(8),Mm=BigInt(9),El=BigInt(16);function ye(r,e){const t=r%e;return t>=qe?t:e+t}function pe(r,e,t){let n=r;for(;e-- >qe;)n*=n,n%=t;return n}function pc(r,e){if(r===qe)throw new Error("invert: expected non-zero number");if(e<=qe)throw new Error("invert: expected positive modulus, got "+e);let t=ye(r,e),n=e,s=qe,i=Te;for(;t!==qe;){const a=n/t,c=n%t,l=s-i*a;n=t,t=c,s=i,i=l}if(n!==Te)throw new Error("invert: does not exist");return ye(s,e)}function ca(r,e,t){if(!r.eql(r.sqr(e),t))throw new Error("Cannot find square root")}function vl(r,e){const t=(r.ORDER+Te)/yl,n=r.pow(e,t);return ca(r,n,e),n}function Nm(r,e){const t=(r.ORDER-wl)/bl,n=r.mul(e,jt),s=r.pow(n,t),i=r.mul(e,s),o=r.mul(r.mul(i,jt),s),a=r.mul(i,r.sub(o,r.ONE));return ca(r,a,e),a}function Rm(r){const e=wi(r),t=xl(r),n=t(e,e.neg(e.ONE)),s=t(e,n),i=t(e,e.neg(n)),o=(r+Pm)/El;return(a,c)=>{let l=a.pow(c,o),d=a.mul(l,n);const f=a.mul(l,s),h=a.mul(l,i),p=a.eql(a.sqr(d),c),g=a.eql(a.sqr(f),c);l=a.cmov(l,d,p),d=a.cmov(h,f,g);const y=a.eql(a.sqr(d),c),m=a.cmov(l,d,y);return ca(a,m,c),m}}function xl(r){if(r<pl)throw new Error("sqrt is not defined for small field");let e=r-Te,t=0;for(;e%jt===qe;)e/=jt,t++;let n=jt;const s=wi(r);for(;yc(s,n)===1;)if(n++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(t===1)return vl;let i=s.pow(n,e);const o=(e+Te)/jt;return function(c,l){if(c.is0(l))return l;if(yc(c,l)!==1)throw new Error("Cannot find square root");let d=t,f=c.mul(c.ONE,i),h=c.pow(l,e),p=c.pow(l,o);for(;!c.eql(h,c.ONE);){if(c.is0(h))return c.ZERO;let g=1,y=c.sqr(h);for(;!c.eql(y,c.ONE);)if(g++,y=c.sqr(y),g===d)throw new Error("Cannot find square root");const m=Te<<BigInt(d-g-1),_=c.pow(f,m);d=g,f=c.sqr(_),h=c.mul(h,f),p=c.mul(p,_)}return p}}function Bm(r){return r%yl===pl?vl:r%bl===wl?Nm:r%El===Mm?Rm(r):xl(r)}const Fm=(r,e)=>(ye(r,e)&Te)===Te,Om=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function $m(r){const e={ORDER:"bigint",BYTES:"number",BITS:"number"},t=Om.reduce((n,s)=>(n[s]="function",n),e);return rn(r,t),r}function Um(r,e,t){if(t<qe)throw new Error("invalid exponent, negatives unsupported");if(t===qe)return r.ONE;if(t===Te)return e;let n=r.ONE,s=e;for(;t>qe;)t&Te&&(n=r.mul(n,s)),s=r.sqr(s),t>>=Te;return n}function Sl(r,e,t=!1){const n=new Array(e.length).fill(t?r.ZERO:void 0),s=e.reduce((o,a,c)=>r.is0(a)?o:(n[c]=o,r.mul(o,a)),r.ONE),i=r.inv(s);return e.reduceRight((o,a,c)=>r.is0(a)?o:(n[c]=r.mul(o,n[c]),r.mul(o,a)),i),n}function yc(r,e){const t=(r.ORDER-Te)/jt,n=r.pow(e,t),s=r.eql(n,r.ONE),i=r.eql(n,r.ZERO),o=r.eql(n,r.neg(r.ONE));if(!s&&!i&&!o)throw new Error("invalid Legendre symbol result");return s?1:i?0:-1}function zm(r,e){e!==void 0&&or(e);const t=e!==void 0?e:r.toString(2).length,n=Math.ceil(t/8);return{nBitLength:t,nByteLength:n}}class qm{constructor(e,t={}){u(this,"ORDER");u(this,"BITS");u(this,"BYTES");u(this,"isLE");u(this,"ZERO",qe);u(this,"ONE",Te);u(this,"_lengths");u(this,"_sqrt");u(this,"_mod");var o;if(e<=qe)throw new Error("invalid field: expected ORDER > 0, got "+e);let n;this.isLE=!1,t!=null&&typeof t=="object"&&(typeof t.BITS=="number"&&(n=t.BITS),typeof t.sqrt=="function"&&(this.sqrt=t.sqrt),typeof t.isLE=="boolean"&&(this.isLE=t.isLE),t.allowedLengths&&(this._lengths=(o=t.allowedLengths)==null?void 0:o.slice()),typeof t.modFromBytes=="boolean"&&(this._mod=t.modFromBytes));const{nBitLength:s,nByteLength:i}=zm(e,n);if(i>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");this.ORDER=e,this.BITS=s,this.BYTES=i,this._sqrt=void 0,Object.preventExtensions(this)}create(e){return ye(e,this.ORDER)}isValid(e){if(typeof e!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof e);return qe<=e&&e<this.ORDER}is0(e){return e===qe}isValidNot0(e){return!this.is0(e)&&this.isValid(e)}isOdd(e){return(e&Te)===Te}neg(e){return ye(-e,this.ORDER)}eql(e,t){return e===t}sqr(e){return ye(e*e,this.ORDER)}add(e,t){return ye(e+t,this.ORDER)}sub(e,t){return ye(e-t,this.ORDER)}mul(e,t){return ye(e*t,this.ORDER)}pow(e,t){return Um(this,e,t)}div(e,t){return ye(e*pc(t,this.ORDER),this.ORDER)}sqrN(e){return e*e}addN(e,t){return e+t}subN(e,t){return e-t}mulN(e,t){return e*t}inv(e){return pc(e,this.ORDER)}sqrt(e){return this._sqrt||(this._sqrt=Bm(this.ORDER)),this._sqrt(this,e)}toBytes(e){return this.isLE?oa(e,this.BYTES):ia(e,this.BYTES)}fromBytes(e,t=!1){ee(e);const{_lengths:n,BYTES:s,isLE:i,ORDER:o,_mod:a}=this;if(n){if(!n.includes(e.length)||e.length>s)throw new Error("Field.fromBytes: expected "+n+" bytes, got "+e.length);const l=new Uint8Array(s);l.set(e,i?0:l.length-e.length),e=l}if(e.length!==s)throw new Error("Field.fromBytes: expected "+s+" bytes, got "+e.length);let c=i?cr(e):yi(e);if(a&&(c=ye(c,o)),!t&&!this.isValid(c))throw new Error("invalid field element: outside of range 0..ORDER");return c}invertBatch(e){return Sl(this,e)}cmov(e,t,n){return n?t:e}}function wi(r,e={}){return new qm(r,e)}function _l(r){if(typeof r!="bigint")throw new Error("field order must be bigint");const e=r.toString(2).length;return Math.ceil(e/8)}function Al(r){const e=_l(r);return e+Math.ceil(e/2)}function Km(r,e,t=!1){ee(r);const n=r.length,s=_l(e),i=Al(e);if(n<16||n<i||n>1024)throw new Error("expected "+i+"-1024 bytes of input, got "+n);const o=t?cr(r):yi(r),a=ye(o,e-Te)+Te;return t?oa(a,s):ia(a,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const qr=BigInt(0),Yt=BigInt(1);function $s(r,e){const t=e.negate();return r?t:e}function bn(r,e){const t=Sl(r.Fp,e.map(n=>n.Z));return e.map((n,s)=>r.fromAffine(n.toAffine(t[s])))}function Il(r,e){if(!Number.isSafeInteger(r)||r<=0||r>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+r)}function Ni(r,e){Il(r,e);const t=Math.ceil(e/r)+1,n=2**(r-1),s=2**r,i=aa(r),o=BigInt(r);return{windows:t,windowSize:n,mask:i,maxNumber:s,shiftBy:o}}function wc(r,e,t){const{windowSize:n,mask:s,maxNumber:i,shiftBy:o}=t;let a=Number(r&s),c=r>>o;a>n&&(a-=i,c+=Yt);const l=e*n,d=l+Math.abs(a)-1,f=a===0,h=a<0,p=e%2!==0;return{nextN:c,offset:d,isZero:f,isNeg:h,isNegF:p,offsetF:l}}const Ri=new WeakMap,Cl=new WeakMap;function Bi(r){return Cl.get(r)||1}function bc(r){if(r!==qr)throw new Error("invalid wNAF")}class Ll{constructor(e,t){u(this,"BASE");u(this,"ZERO");u(this,"Fn");u(this,"bits");this.BASE=e.BASE,this.ZERO=e.ZERO,this.Fn=e.Fn,this.bits=t}_unsafeLadder(e,t,n=this.ZERO){let s=e;for(;t>qr;)t&Yt&&(n=n.add(s)),s=s.double(),t>>=Yt;return n}precomputeWindow(e,t){const{windows:n,windowSize:s}=Ni(t,this.bits),i=[];let o=e,a=o;for(let c=0;c<n;c++){a=o,i.push(a);for(let l=1;l<s;l++)a=a.add(o),i.push(a);o=a.double()}return i}wNAF(e,t,n){if(!this.Fn.isValid(n))throw new Error("invalid scalar");let s=this.ZERO,i=this.BASE;const o=Ni(e,this.bits);for(let a=0;a<o.windows;a++){const{nextN:c,offset:l,isZero:d,isNeg:f,isNegF:h,offsetF:p}=wc(n,a,o);n=c,d?i=i.add($s(h,t[p])):s=s.add($s(f,t[l]))}return bc(n),{p:s,f:i}}wNAFUnsafe(e,t,n,s=this.ZERO){const i=Ni(e,this.bits);for(let o=0;o<i.windows&&n!==qr;o++){const{nextN:a,offset:c,isZero:l,isNeg:d}=wc(n,o,i);if(n=a,!l){const f=t[c];s=s.add(d?f.negate():f)}}return bc(n),s}getPrecomputes(e,t,n){let s=Ri.get(t);return s||(s=this.precomputeWindow(t,e),e!==1&&(typeof n=="function"&&(s=n(s)),Ri.set(t,s))),s}cached(e,t,n){const s=Bi(e);return this.wNAF(s,this.getPrecomputes(s,e,n),t)}unsafe(e,t,n,s){const i=Bi(e);return i===1?this._unsafeLadder(e,t,s):this.wNAFUnsafe(i,this.getPrecomputes(i,e,n),t,s)}createCache(e,t){Il(t,this.bits),Cl.set(e,t),Ri.delete(e)}hasCache(e){return Bi(e)!==1}}function Vm(r,e,t,n){let s=e,i=r.ZERO,o=r.ZERO;for(;t>qr||n>qr;)t&Yt&&(i=i.add(s)),n&Yt&&(o=o.add(s)),s=s.double(),t>>=Yt,n>>=Yt;return{p1:i,p2:o}}function Ec(r,e,t){if(e){if(e.ORDER!==r)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return $m(e),e}else return wi(r,{isLE:t})}function Tl(r,e,t={},n){if(n===void 0&&(n=r==="edwards"),!e||typeof e!="object")throw new Error(`expected valid ${r} CURVE object`);for(const c of["p","n","h"]){const l=e[c];if(!(typeof l=="bigint"&&l>qr))throw new Error(`CURVE.${c} must be positive bigint`)}const s=Ec(e.p,t.Fp,n),i=Ec(e.n,t.Fn,n),a=["Gx","Gy","a",r==="weierstrass"?"b":"d"];for(const c of a)if(!s.isValid(e[c]))throw new Error(`CURVE.${c} must be valid field element of CURVE.Fp`);return e=Object.freeze(Object.assign({},e)),{CURVE:e,Fp:s,Fn:i}}function ua(r,e){return function(n){const s=r(n);return{secretKey:s,publicKey:e(s)}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Rt=BigInt(0),xe=BigInt(1),Fi=BigInt(2),Hm=BigInt(8);function Wm(r,e,t,n){const s=r.sqr(t),i=r.sqr(n),o=r.add(r.mul(e.a,s),i),a=r.add(r.ONE,r.mul(e.d,r.mul(s,i)));return r.eql(o,a)}function Gm(r,e={}){const t=Tl("edwards",r,e,e.FpFnLE),{Fp:n,Fn:s}=t;let i=t.CURVE;const{h:o}=i;rn(e,{},{uvRatio:"function"});const a=Fi<<BigInt(s.BYTES*8)-xe,c=_=>n.create(_),l=e.uvRatio||((_,x)=>{try{return{isValid:!0,value:n.sqrt(n.div(_,x))}}catch{return{isValid:!1,value:Rt}}});if(!Wm(n,i,i.Gx,i.Gy))throw new Error("bad curve params: generator point");function d(_,x,E=!1){const C=E?xe:Rt;return Ln("coordinate "+_,x,C,a),x}function f(_){if(!(_ instanceof g))throw new Error("EdwardsPoint expected")}const h=Os((_,x)=>{const{X:E,Y:C,Z:A}=_,N=_.is0();x==null&&(x=N?Hm:n.inv(A));const R=c(E*x),L=c(C*x),T=n.mul(A,x);if(N)return{x:Rt,y:xe};if(T!==xe)throw new Error("invZ was invalid");return{x:R,y:L}}),p=Os(_=>{const{a:x,d:E}=i;if(_.is0())throw new Error("bad point: ZERO");const{X:C,Y:A,Z:N,T:R}=_,L=c(C*C),T=c(A*A),V=c(N*N),Y=c(V*V),$=c(L*x),U=c(V*c($+T)),w=c(Y+c(E*c(L*T)));if(U!==w)throw new Error("bad point: equation left != right (1)");const b=c(C*A),I=c(N*R);if(b!==I)throw new Error("bad point: equation left != right (2)");return!0}),m=class m{constructor(x,E,C,A){u(this,"X");u(this,"Y");u(this,"Z");u(this,"T");this.X=d("x",x),this.Y=d("y",E),this.Z=d("z",C,!0),this.T=d("t",A),Object.freeze(this)}static CURVE(){return i}static fromAffine(x){if(x instanceof m)throw new Error("extended point not allowed");const{x:E,y:C}=x||{};return d("x",E),d("y",C),new m(E,C,xe,c(E*C))}static fromBytes(x,E=!1){const C=n.BYTES,{a:A,d:N}=i;x=Cn(ee(x,C,"point")),ar(E,"zip215");const R=Cn(x),L=x[C-1];R[C-1]=L&-129;const T=cr(R),V=E?a:n.ORDER;Ln("point.y",T,Rt,V);const Y=c(T*T),$=c(Y-xe),U=c(N*Y-A);let{isValid:w,value:b}=l($,U);if(!w)throw new Error("bad point: invalid y coordinate");const I=(b&xe)===xe,k=(L&128)!==0;if(!E&&b===Rt&&k)throw new Error("bad point: x=0 and x_0=1");return k!==I&&(b=c(-b)),m.fromAffine({x:b,y:T})}static fromHex(x,E=!1){return m.fromBytes(In(x),E)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(x=8,E=!0){return y.createCache(this,x),E||this.multiply(Fi),this}assertValidity(){p(this)}equals(x){f(x);const{X:E,Y:C,Z:A}=this,{X:N,Y:R,Z:L}=x,T=c(E*L),V=c(N*A),Y=c(C*L),$=c(R*A);return T===V&&Y===$}is0(){return this.equals(m.ZERO)}negate(){return new m(c(-this.X),this.Y,this.Z,c(-this.T))}double(){const{a:x}=i,{X:E,Y:C,Z:A}=this,N=c(E*E),R=c(C*C),L=c(Fi*c(A*A)),T=c(x*N),V=E+C,Y=c(c(V*V)-N-R),$=T+R,U=$-L,w=T-R,b=c(Y*U),I=c($*w),k=c(Y*w),B=c(U*$);return new m(b,I,B,k)}add(x){f(x);const{a:E,d:C}=i,{X:A,Y:N,Z:R,T:L}=this,{X:T,Y:V,Z:Y,T:$}=x,U=c(A*T),w=c(N*V),b=c(L*C*$),I=c(R*Y),k=c((A+N)*(T+V)-U-w),B=I-b,F=I+b,z=c(w-E*U),M=c(k*B),K=c(F*z),j=c(k*z),de=c(B*F);return new m(M,K,de,j)}subtract(x){return this.add(x.negate())}multiply(x){if(!s.isValidNot0(x))throw new Error("invalid scalar: expected 1 <= sc < curve.n");const{p:E,f:C}=y.cached(this,x,A=>bn(m,A));return bn(m,[E,C])[0]}multiplyUnsafe(x,E=m.ZERO){if(!s.isValid(x))throw new Error("invalid scalar: expected 0 <= sc < curve.n");return x===Rt?m.ZERO:this.is0()||x===xe?this:y.unsafe(this,x,C=>bn(m,C),E)}isSmallOrder(){return this.multiplyUnsafe(o).is0()}isTorsionFree(){return y.unsafe(this,i.n).is0()}toAffine(x){return h(this,x)}clearCofactor(){return o===xe?this:this.multiplyUnsafe(o)}toBytes(){const{x,y:E}=this.toAffine(),C=n.toBytes(E);return C[C.length-1]|=x&xe?128:0,C}toHex(){return Vn(this.toBytes())}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}};u(m,"BASE",new m(i.Gx,i.Gy,xe,c(i.Gx*i.Gy))),u(m,"ZERO",new m(Rt,xe,xe,Rt)),u(m,"Fp",n),u(m,"Fn",s);let g=m;const y=new Ll(g,s.BITS);return g.BASE.precompute(8),g}function Zm(r,e,t={}){if(typeof e!="function")throw new Error('"hash" function param is required');rn(t,{},{adjustScalarBytes:"function",randomBytes:"function",domain:"function",prehash:"function",mapToCurve:"function"});const{prehash:n}=t,{BASE:s,Fp:i,Fn:o}=r,a=t.randomBytes||Hn,c=t.adjustScalarBytes||(L=>L),l=t.domain||((L,T,V)=>{if(ar(V,"phflag"),T.length||V)throw new Error("Contexts/pre-hash are not supported");return L});function d(L){return o.create(cr(L))}function f(L){const T=E.secretKey;ee(L,E.secretKey,"secretKey");const V=ee(e(L),2*T,"hashedSecretKey"),Y=c(V.slice(0,T)),$=V.slice(T,2*T),U=d(Y);return{head:Y,prefix:$,scalar:U}}function h(L){const{head:T,prefix:V,scalar:Y}=f(L),$=s.multiply(Y),U=$.toBytes();return{head:T,prefix:V,scalar:Y,point:$,pointBytes:U}}function p(L){return h(L).pointBytes}function g(L=Uint8Array.of(),...T){const V=ft(...T);return d(e(l(V,ee(L,void 0,"context"),!!n)))}function y(L,T,V={}){L=ee(L,void 0,"message"),n&&(L=n(L));const{prefix:Y,scalar:$,pointBytes:U}=h(T),w=g(V.context,Y,L),b=s.multiply(w).toBytes(),I=g(V.context,b,U,L),k=o.create(w+I*$);if(!o.isValid(k))throw new Error("sign failed: invalid s");const B=ft(b,o.toBytes(k));return ee(B,E.signature,"result")}const m={zip215:!0};function _(L,T,V,Y=m){const{context:$,zip215:U}=Y,w=E.signature;L=ee(L,w,"signature"),T=ee(T,void 0,"message"),V=ee(V,E.publicKey,"publicKey"),U!==void 0&&ar(U,"zip215"),n&&(T=n(T));const b=w/2,I=L.subarray(0,b),k=cr(L.subarray(b,w));let B,F,z;try{B=r.fromBytes(V,U),F=r.fromBytes(I,U),z=s.multiplyUnsafe(k)}catch{return!1}if(!U&&B.isSmallOrder())return!1;const M=g($,F.toBytes(),B.toBytes(),T);return F.add(B.multiplyUnsafe(M)).subtract(z).clearCofactor().is0()}const x=i.BYTES,E={secretKey:x,publicKey:x,signature:2*x,seed:x};function C(L=a(E.seed)){return ee(L,E.seed,"seed")}function A(L){return mi(L)&&L.length===o.BYTES}function N(L,T){try{return!!r.fromBytes(L,T)}catch{return!1}}const R={getExtendedPublicKey:h,randomSecretKey:C,isValidSecretKey:A,isValidPublicKey:N,toMontgomery(L){const{y:T}=r.fromBytes(L),V=E.publicKey,Y=V===32;if(!Y&&V!==57)throw new Error("only defined for 25519 and 448");const $=Y?i.div(xe+T,xe-T):i.div(T-xe,T+xe);return i.toBytes($)},toMontgomerySecret(L){const T=E.secretKey;ee(L,T);const V=e(L.subarray(0,T));return c(V).subarray(0,T)}};return Object.freeze({keygen:ua(C,p),getPublicKey:p,sign:y,verify:_,utils:R,Point:r,lengths:E})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const dn=BigInt(0),wr=BigInt(1),ss=BigInt(2);function jm(r){return rn(r,{adjustScalarBytes:"function",powPminus2:"function"}),Object.freeze({...r})}function Ym(r){const e=jm(r),{P:t,type:n,adjustScalarBytes:s,powPminus2:i,randomBytes:o}=e,a=n==="x25519";if(!a&&n!=="x448")throw new Error("invalid type");const c=o||Hn,l=a?255:448,d=a?32:56,f=BigInt(a?9:5),h=BigInt(a?121665:39081),p=a?ss**BigInt(254):ss**BigInt(447),g=a?BigInt(8)*ss**BigInt(251)-wr:BigInt(4)*ss**BigInt(445)-wr,y=p+g+wr,m=w=>ye(w,t),_=x(f);function x(w){return oa(m(w),d)}function E(w){const b=Cn(ee(w,d,"uCoordinate"));return a&&(b[31]&=127),m(cr(b))}function C(w){return cr(s(Cn(ee(w,d,"scalar"))))}function A(w,b){const I=V(E(b),C(w));if(I===dn)throw new Error("invalid private or public key received");return x(I)}function N(w){return A(w,_)}const R=N,L=A;function T(w,b,I){const k=m(w*(b-I));return b=m(b-k),I=m(I+k),{x_2:b,x_3:I}}function V(w,b){Ln("u",w,dn,t),Ln("scalar",b,p,y);const I=b,k=w;let B=wr,F=dn,z=w,M=wr,K=dn;for(let de=BigInt(l-1);de>=dn;de--){const ae=I>>de&wr;K^=ae,{x_2:B,x_3:z}=T(K,B,z),{x_2:F,x_3:M}=T(K,F,M),K=ae;const G=B+F,we=m(G*G),ve=B-F,ke=m(ve*ve),fe=we-ke,_e=z+M,Qn=z-M,cn=m(Qn*G),ja=m(_e*ve),Ya=cn+ja,Xa=cn-ja;z=m(Ya*Ya),M=m(k*m(Xa*Xa)),B=m(we*ke),F=m(fe*(we+m(h*fe)))}({x_2:B,x_3:z}=T(K,B,z)),{x_2:F,x_3:M}=T(K,F,M);const j=i(F);return m(B*j)}const Y={secretKey:d,publicKey:d,seed:d},$=(w=c(d))=>(ee(w,Y.seed,"seed"),w),U={randomSecretKey:$};return Object.freeze({keygen:ua($,R),getSharedSecret:L,getPublicKey:R,scalarMult:A,scalarMultBase:N,utils:U,GuBytes:_.slice(),lengths:Y})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Xm=BigInt(1),vc=BigInt(2),Qm=BigInt(3),Jm=BigInt(5),ep=BigInt(8),bi=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"),tp={p:bi,n:BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),h:ep,a:BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),d:BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),Gx:BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),Gy:BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")};function Dl(r){const e=BigInt(10),t=BigInt(20),n=BigInt(40),s=BigInt(80),i=bi,a=r*r%i*r%i,c=pe(a,vc,i)*a%i,l=pe(c,Xm,i)*r%i,d=pe(l,Jm,i)*l%i,f=pe(d,e,i)*d%i,h=pe(f,t,i)*f%i,p=pe(h,n,i)*h%i,g=pe(p,s,i)*p%i,y=pe(g,s,i)*p%i,m=pe(y,e,i)*d%i;return{pow_p_5_8:pe(m,vc,i)*r%i,b2:a}}function kl(r){return r[0]&=248,r[31]&=127,r[31]|=64,r}const xc=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");function rp(r,e){const t=bi,n=ye(e*e*e,t),s=ye(n*n*e,t),i=Dl(r*s).pow_p_5_8;let o=ye(r*n*i,t);const a=ye(e*o*o,t),c=o,l=ye(o*xc,t),d=a===r,f=a===ye(-r,t),h=a===ye(-r*xc,t);return d&&(o=c),(f||h)&&(o=l),Fm(o,t)&&(o=ye(-o,t)),{isValid:d||f,value:o}}const np=Gm(tp,{uvRatio:rp});function sp(r){return Zm(np,Lm,Object.assign({adjustScalarBytes:kl},r))}const Us=sp({}),lx=(()=>{const r=bi;return Ym({P:r,type:"x25519",powPminus2:e=>{const{pow_p_5_8:t,b2:n}=Dl(e);return ye(pe(t,Qm,r)*n,r)},adjustScalarBytes:kl})})();class Sc extends Error{constructor(e="An error occurred while signing a message"){super(e),this.name="SigningError"}}class _c extends Error{constructor(e="An error occurred while verifying a message"){super(e),this.name="VerificationError"}}class ip extends Error{constructor(e="Missing Web Crypto API"){super(e),this.name="WebCryptoMissingError"}}const Je={get(r=globalThis){const e=r.crypto;if((e==null?void 0:e.subtle)==null)throw new ip("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p/blob/main/packages/crypto/README.md#web-crypto-api");return e}},zs=32,vt=64,xo=32;let Lr;const Pl=(async()=>{try{return await Je.get().subtle.generateKey({name:"Ed25519"},!0,["sign","verify"]),!0}catch{return!1}})();function op(){const r=Us.utils.randomSecretKey(),e=Us.getPublicKey(r);return{privateKey:hp(r,e),publicKey:e}}async function ap(r,e){let t;r.length===vt?t=r.subarray(0,32):t=r;const n={crv:"Ed25519",kty:"OKP",x:X(r.subarray(32),"base64url"),d:X(t,"base64url"),ext:!0,key_ops:["sign"]},s=await Je.get().subtle.importKey("jwk",n,{name:"Ed25519"},!0,["sign"]),i=await Je.get().subtle.sign({name:"Ed25519"},s,e instanceof Uint8Array?e:e.subarray());return new Uint8Array(i,0,i.byteLength)}function cp(r,e){const t=r.subarray(0,xo);return Us.sign(e instanceof Uint8Array?e:e.subarray(),t)}async function up(r,e){return Lr==null&&(Lr=await Pl),Lr?ap(r,e):cp(r,e)}async function lp(r,e,t){if(r.buffer instanceof ArrayBuffer){const n=await Je.get().subtle.importKey("raw",r.buffer,{name:"Ed25519"},!1,["verify"]);return await Je.get().subtle.verify({name:"Ed25519"},n,e,t instanceof Uint8Array?t:t.subarray())}throw new TypeError("WebCrypto does not support SharedArrayBuffer for Ed25519 keys")}function dp(r,e,t){return Us.verify(e,t instanceof Uint8Array?t:t.subarray(),r)}async function fp(r,e,t){return Lr==null&&(Lr=await Pl),Lr?lp(r,e,t):dp(r,e,t)}function hp(r,e){const t=new Uint8Array(vt);for(let n=0;n<xo;n++)t[n]=r[n],t[xo+n]=e[n];return t}function Ei(r){return r==null?!1:typeof r.then=="function"&&typeof r.catch=="function"&&typeof r.finally=="function"}class Ml{constructor(e){u(this,"type","Ed25519");u(this,"raw");this.raw=Tn(e,zs)}toMultihash(){return qn.digest(ir(this))}toCID(){return ue.createV1(114,this.toMultihash())}toString(){return Ce.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:Se(this.raw,e.raw)}verify(e,t,n){var i;(i=n==null?void 0:n.signal)==null||i.throwIfAborted();const s=fp(this.raw,t,e);return Ei(s)?s.then(o=>{var a;return(a=n==null?void 0:n.signal)==null||a.throwIfAborted(),o}):s}}class So{constructor(e,t){u(this,"type","Ed25519");u(this,"raw");u(this,"publicKey");this.raw=Tn(e,vt),this.publicKey=new Ml(t)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:Se(this.raw,e.raw)}sign(e,t){var s,i;(s=t==null?void 0:t.signal)==null||s.throwIfAborted();const n=up(this.raw,e);return Ei(n)?n.then(o=>{var a;return(a=t==null?void 0:t.signal)==null||a.throwIfAborted(),o}):((i=t==null?void 0:t.signal)==null||i.throwIfAborted(),n)}}function gp(r){if(r.length>vt){r=Tn(r,vt+zs);const n=r.subarray(0,vt),s=r.subarray(vt,r.length);return new So(n,s)}r=Tn(r,vt);const e=r.subarray(0,vt),t=r.subarray(zs);return new So(e,t)}function Nl(r){return r=Tn(r,zs),new Ml(r)}async function mp(){const{privateKey:r,publicKey:e}=op();return new So(r,e)}function Tn(r,e){if(r=Uint8Array.from(r??[]),r.length!==e)throw new Z(`Key must be a Uint8Array of length ${e}, got ${r.length}`);return r}const pp=Math.pow(2,7),yp=Math.pow(2,14),wp=Math.pow(2,21),la=Math.pow(2,28),da=Math.pow(2,35),fa=Math.pow(2,42),ha=Math.pow(2,49),ie=128,Ne=127;function Ge(r){if(r<pp)return 1;if(r<yp)return 2;if(r<wp)return 3;if(r<la)return 4;if(r<da)return 5;if(r<fa)return 6;if(r<ha)return 7;if(Number.MAX_SAFE_INTEGER!=null&&r>Number.MAX_SAFE_INTEGER)throw new RangeError("Could not encode varint");return 8}function qs(r,e,t=0){switch(Ge(r)){case 8:e[t++]=r&255|ie,r/=128;case 7:e[t++]=r&255|ie,r/=128;case 6:e[t++]=r&255|ie,r/=128;case 5:e[t++]=r&255|ie,r/=128;case 4:e[t++]=r&255|ie,r>>>=7;case 3:e[t++]=r&255|ie,r>>>=7;case 2:e[t++]=r&255|ie,r>>>=7;case 1:{e[t++]=r&255,r>>>=7;break}default:throw new Error("unreachable")}return e}function bp(r,e,t=0){switch(Ge(r)){case 8:e.set(t++,r&255|ie),r/=128;case 7:e.set(t++,r&255|ie),r/=128;case 6:e.set(t++,r&255|ie),r/=128;case 5:e.set(t++,r&255|ie),r/=128;case 4:e.set(t++,r&255|ie),r>>>=7;case 3:e.set(t++,r&255|ie),r>>>=7;case 2:e.set(t++,r&255|ie),r>>>=7;case 1:{e.set(t++,r&255),r>>>=7;break}default:throw new Error("unreachable")}return e}function Rl(r,e){let t=r[e],n=0;if(n+=t&Ne,t<ie||(t=r[e+1],n+=(t&Ne)<<7,t<ie)||(t=r[e+2],n+=(t&Ne)<<14,t<ie)||(t=r[e+3],n+=(t&Ne)<<21,t<ie)||(t=r[e+4],n+=(t&Ne)*la,t<ie)||(t=r[e+5],n+=(t&Ne)*da,t<ie)||(t=r[e+6],n+=(t&Ne)*fa,t<ie)||(t=r[e+7],n+=(t&Ne)*ha,t<ie))return n;throw new RangeError("Could not decode varint")}function Ep(r,e){let t=r.get(e),n=0;if(n+=t&Ne,t<ie||(t=r.get(e+1),n+=(t&Ne)<<7,t<ie)||(t=r.get(e+2),n+=(t&Ne)<<14,t<ie)||(t=r.get(e+3),n+=(t&Ne)<<21,t<ie)||(t=r.get(e+4),n+=(t&Ne)*la,t<ie)||(t=r.get(e+5),n+=(t&Ne)*da,t<ie)||(t=r.get(e+6),n+=(t&Ne)*fa,t<ie)||(t=r.get(e+7),n+=(t&Ne)*ha,t<ie))return n;throw new RangeError("Could not decode varint")}function En(r,e,t=0){return e==null&&(e=Ct(Ge(r))),e instanceof Uint8Array?qs(r,e,t):bp(r,e,t)}function Wn(r,e=0){return r instanceof Uint8Array?Rl(r,e):Ep(r,e)}const ga=new Float32Array([-0]),Ut=new Uint8Array(ga.buffer);function vp(r,e,t){ga[0]=r,e[t]=Ut[0],e[t+1]=Ut[1],e[t+2]=Ut[2],e[t+3]=Ut[3]}function xp(r,e){return Ut[0]=r[e],Ut[1]=r[e+1],Ut[2]=r[e+2],Ut[3]=r[e+3],ga[0]}const ma=new Float64Array([-0]),Re=new Uint8Array(ma.buffer);function Sp(r,e,t){ma[0]=r,e[t]=Re[0],e[t+1]=Re[1],e[t+2]=Re[2],e[t+3]=Re[3],e[t+4]=Re[4],e[t+5]=Re[5],e[t+6]=Re[6],e[t+7]=Re[7]}function _p(r,e){return Re[0]=r[e],Re[1]=r[e+1],Re[2]=r[e+2],Re[3]=r[e+3],Re[4]=r[e+4],Re[5]=r[e+5],Re[6]=r[e+6],Re[7]=r[e+7],ma[0]}const Ap=BigInt(Number.MAX_SAFE_INTEGER),Ip=BigInt(Number.MIN_SAFE_INTEGER);class Be{constructor(e,t){u(this,"lo");u(this,"hi");this.lo=e|0,this.hi=t|0}toNumber(e=!1){if(!e&&this.hi>>>31>0){const t=~this.lo+1>>>0;let n=~this.hi>>>0;return t===0&&(n=n+1>>>0),-(t+n*4294967296)}return this.lo+this.hi*4294967296}toBigInt(e=!1){if(e)return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n);if(this.hi>>>31){const t=~this.lo+1>>>0;let n=~this.hi>>>0;return t===0&&(n=n+1>>>0),-(BigInt(t)+(BigInt(n)<<32n))}return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n)}toString(e=!1){return this.toBigInt(e).toString()}zzEncode(){const e=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^e)>>>0,this.lo=(this.lo<<1^e)>>>0,this}zzDecode(){const e=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^e)>>>0,this.hi=(this.hi>>>1^e)>>>0,this}length(){const e=this.lo,t=(this.lo>>>28|this.hi<<4)>>>0,n=this.hi>>>24;return n===0?t===0?e<16384?e<128?1:2:e<2097152?3:4:t<16384?t<128?5:6:t<2097152?7:8:n<128?9:10}static fromBigInt(e){if(e===0n)return sr;if(e<Ap&&e>Ip)return this.fromNumber(Number(e));const t=e<0n;t&&(e=-e);let n=e>>32n,s=e-(n<<32n);return t&&(n=~n|0n,s=~s|0n,++s>Ac&&(s=0n,++n>Ac&&(n=0n))),new Be(Number(s),Number(n))}static fromNumber(e){if(e===0)return sr;const t=e<0;t&&(e=-e);let n=e>>>0,s=(e-n)/4294967296>>>0;return t&&(s=~s>>>0,n=~n>>>0,++n>4294967295&&(n=0,++s>4294967295&&(s=0))),new Be(n,s)}static from(e){return typeof e=="number"?Be.fromNumber(e):typeof e=="bigint"?Be.fromBigInt(e):typeof e=="string"?Be.fromBigInt(BigInt(e)):e.low!=null||e.high!=null?new Be(e.low>>>0,e.high>>>0):sr}}const sr=new Be(0,0);sr.toBigInt=function(){return 0n};sr.zzEncode=sr.zzDecode=function(){return this};sr.length=function(){return 1};const Ac=4294967296n;function Cp(r){let e=0,t=0;for(let n=0;n<r.length;++n)t=r.charCodeAt(n),t<128?e+=1:t<2048?e+=2:(t&64512)===55296&&(r.charCodeAt(n+1)&64512)===56320?(++n,e+=4):e+=3;return e}function Lp(r,e,t){if(t-e<1)return"";let s;const i=[];let o=0,a;for(;e<t;)a=r[e++],a<128?i[o++]=a:a>191&&a<224?i[o++]=(a&31)<<6|r[e++]&63:a>239&&a<365?(a=((a&7)<<18|(r[e++]&63)<<12|(r[e++]&63)<<6|r[e++]&63)-65536,i[o++]=55296+(a>>10),i[o++]=56320+(a&1023)):i[o++]=(a&15)<<12|(r[e++]&63)<<6|r[e++]&63,o>8191&&((s??(s=[])).push(String.fromCharCode.apply(String,i)),o=0);return s!=null?(o>0&&s.push(String.fromCharCode.apply(String,i.slice(0,o))),s.join("")):String.fromCharCode.apply(String,i.slice(0,o))}function Bl(r,e,t){const n=t;let s,i;for(let o=0;o<r.length;++o)s=r.charCodeAt(o),s<128?e[t++]=s:s<2048?(e[t++]=s>>6|192,e[t++]=s&63|128):(s&64512)===55296&&((i=r.charCodeAt(o+1))&64512)===56320?(s=65536+((s&1023)<<10)+(i&1023),++o,e[t++]=s>>18|240,e[t++]=s>>12&63|128,e[t++]=s>>6&63|128,e[t++]=s&63|128):(e[t++]=s>>12|224,e[t++]=s>>6&63|128,e[t++]=s&63|128);return t-n}function tt(r,e){return RangeError(`index out of range: ${r.pos} + ${e??1} > ${r.len}`)}function is(r,e){return(r[e-4]|r[e-3]<<8|r[e-2]<<16|r[e-1]<<24)>>>0}class Tp{constructor(e){u(this,"buf");u(this,"pos");u(this,"len");u(this,"_slice",Uint8Array.prototype.subarray);this.buf=e,this.pos=0,this.len=e.length}uint32(){let e=4294967295;if(e=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(e=(e|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return e;if((this.pos+=5)>this.len)throw this.pos=this.len,tt(this,10);return e}int32(){return this.uint32()|0}sint32(){const e=this.uint32();return e>>>1^-(e&1)|0}bool(){return this.uint32()!==0}fixed32(){if(this.pos+4>this.len)throw tt(this,4);return is(this.buf,this.pos+=4)}sfixed32(){if(this.pos+4>this.len)throw tt(this,4);return is(this.buf,this.pos+=4)|0}float(){if(this.pos+4>this.len)throw tt(this,4);const e=xp(this.buf,this.pos);return this.pos+=4,e}double(){if(this.pos+8>this.len)throw tt(this,4);const e=_p(this.buf,this.pos);return this.pos+=8,e}bytes(){const e=this.uint32(),t=this.pos,n=this.pos+e;if(n>this.len)throw tt(this,e);return this.pos+=e,t===n?new Uint8Array(0):this.buf.subarray(t,n)}string(){const e=this.bytes();return Lp(e,0,e.length)}skip(e){if(typeof e=="number"){if(this.pos+e>this.len)throw tt(this,e);this.pos+=e}else do if(this.pos>=this.len)throw tt(this);while(this.buf[this.pos++]&128);return this}skipType(e){switch(e){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(e=this.uint32()&7)!==4;)this.skipType(e);break;case 5:this.skip(4);break;default:throw Error(`invalid wire type ${e} at offset ${this.pos}`)}return this}readLongVarint(){const e=new Be(0,0);let t=0;if(this.len-this.pos>4){for(;t<4;++t)if(e.lo=(e.lo|(this.buf[this.pos]&127)<<t*7)>>>0,this.buf[this.pos++]<128)return e;if(e.lo=(e.lo|(this.buf[this.pos]&127)<<28)>>>0,e.hi=(e.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return e;t=0}else{for(;t<3;++t){if(this.pos>=this.len)throw tt(this);if(e.lo=(e.lo|(this.buf[this.pos]&127)<<t*7)>>>0,this.buf[this.pos++]<128)return e}return e.lo=(e.lo|(this.buf[this.pos++]&127)<<t*7)>>>0,e}if(this.len-this.pos>4){for(;t<5;++t)if(e.hi=(e.hi|(this.buf[this.pos]&127)<<t*7+3)>>>0,this.buf[this.pos++]<128)return e}else for(;t<5;++t){if(this.pos>=this.len)throw tt(this);if(e.hi=(e.hi|(this.buf[this.pos]&127)<<t*7+3)>>>0,this.buf[this.pos++]<128)return e}throw Error("invalid varint encoding")}readFixed64(){if(this.pos+8>this.len)throw tt(this,8);const e=is(this.buf,this.pos+=4),t=is(this.buf,this.pos+=4);return new Be(e,t)}int64(){return this.readLongVarint().toBigInt()}int64Number(){return this.readLongVarint().toNumber()}int64String(){return this.readLongVarint().toString()}uint64(){return this.readLongVarint().toBigInt(!0)}uint64Number(){const e=Rl(this.buf,this.pos);return this.pos+=Ge(e),e}uint64String(){return this.readLongVarint().toString(!0)}sint64(){return this.readLongVarint().zzDecode().toBigInt()}sint64Number(){return this.readLongVarint().zzDecode().toNumber()}sint64String(){return this.readLongVarint().zzDecode().toString()}fixed64(){return this.readFixed64().toBigInt()}fixed64Number(){return this.readFixed64().toNumber()}fixed64String(){return this.readFixed64().toString()}sfixed64(){return this.readFixed64().toBigInt()}sfixed64Number(){return this.readFixed64().toNumber()}sfixed64String(){return this.readFixed64().toString()}}function Dp(r){return new Tp(r instanceof Uint8Array?r:r.subarray())}function ht(r,e,t){const n=Dp(r);return e.decode(n,void 0,t)}function kp(r){let n,s=8192;return function(o){if(o<1||o>4096)return Ct(o);s+o>8192&&(n=Ct(8192),s=0);const a=n.subarray(s,s+=o);return s&7&&(s=(s|7)+1),a}}class mn{constructor(e,t,n){u(this,"fn");u(this,"len");u(this,"next");u(this,"val");this.fn=e,this.len=t,this.next=void 0,this.val=n}}function Oi(){}class Pp{constructor(e){u(this,"head");u(this,"tail");u(this,"len");u(this,"next");this.head=e.head,this.tail=e.tail,this.len=e.len,this.next=e.states}}const Mp=kp();function Np(r){return globalThis.Buffer!=null?Ct(r):Mp(r)}class _o{constructor(){u(this,"len");u(this,"head");u(this,"tail");u(this,"states");this.len=0,this.head=new mn(Oi,0,0),this.tail=this.head,this.states=null}_push(e,t,n){return this.tail=this.tail.next=new mn(e,t,n),this.len+=t,this}uint32(e){return this.len+=(this.tail=this.tail.next=new Bp((e=e>>>0)<128?1:e<16384?2:e<2097152?3:e<268435456?4:5,e)).len,this}int32(e){return e<0?this._push(os,10,Be.fromNumber(e)):this.uint32(e)}sint32(e){return this.uint32((e<<1^e>>31)>>>0)}uint64(e){const t=Be.fromBigInt(e);return this._push(os,t.length(),t)}uint64Number(e){return this._push(qs,Ge(e),e)}uint64String(e){return this.uint64(BigInt(e))}int64(e){return this.uint64(e)}int64Number(e){return this.uint64Number(e)}int64String(e){return this.uint64String(e)}sint64(e){const t=Be.fromBigInt(e).zzEncode();return this._push(os,t.length(),t)}sint64Number(e){const t=Be.fromNumber(e).zzEncode();return this._push(os,t.length(),t)}sint64String(e){return this.sint64(BigInt(e))}bool(e){return this._push($i,1,e?1:0)}fixed32(e){return this._push(fn,4,e>>>0)}sfixed32(e){return this.fixed32(e)}fixed64(e){const t=Be.fromBigInt(e);return this._push(fn,4,t.lo)._push(fn,4,t.hi)}fixed64Number(e){const t=Be.fromNumber(e);return this._push(fn,4,t.lo)._push(fn,4,t.hi)}fixed64String(e){return this.fixed64(BigInt(e))}sfixed64(e){return this.fixed64(e)}sfixed64Number(e){return this.fixed64Number(e)}sfixed64String(e){return this.fixed64String(e)}float(e){return this._push(vp,4,e)}double(e){return this._push(Sp,8,e)}bytes(e){const t=e.length>>>0;return t===0?this._push($i,1,0):this.uint32(t)._push(Fp,t,e)}string(e){const t=Cp(e);return t!==0?this.uint32(t)._push(Bl,t,e):this._push($i,1,0)}fork(){return this.states=new Pp(this),this.head=this.tail=new mn(Oi,0,0),this.len=0,this}reset(){return this.states!=null?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new mn(Oi,0,0),this.len=0),this}ldelim(){const e=this.head,t=this.tail,n=this.len;return this.reset().uint32(n),n!==0&&(this.tail.next=e.next,this.tail=t,this.len+=n),this}finish(){let e=this.head.next;const t=Np(this.len);let n=0;for(;e!=null;)e.fn(e.val,t,n),n+=e.len,e=e.next;return t}}function $i(r,e,t){e[t]=r&255}function Rp(r,e,t){for(;r>127;)e[t++]=r&127|128,r>>>=7;e[t]=r}class Bp extends mn{constructor(t,n){super(Rp,t,n);u(this,"next");this.next=void 0}}function os(r,e,t){for(;r.hi!==0;)e[t++]=r.lo&127|128,r.lo=(r.lo>>>7|r.hi<<25)>>>0,r.hi>>>=7;for(;r.lo>127;)e[t++]=r.lo&127|128,r.lo=r.lo>>>7;e[t++]=r.lo}function fn(r,e,t){e[t]=r&255,e[t+1]=r>>>8&255,e[t+2]=r>>>16&255,e[t+3]=r>>>24}function Fp(r,e,t){e.set(r,t)}globalThis.Buffer!=null&&(_o.prototype.bytes=function(r){const e=r.length>>>0;return this.uint32(e),e>0&&this._push(Op,e,r),this},_o.prototype.string=function(r){const e=globalThis.Buffer.byteLength(r);return this.uint32(e),e>0&&this._push($p,e,r),this});function Op(r,e,t){e.set(r,t)}function $p(r,e,t){r.length<40?Bl(r,e,t):e.utf8Write!=null?e.utf8Write(r,t):e.set(W(r),t)}function Up(){return new _o}function gt(r,e){const t=Up();return e.encode(r,t,{lengthDelimited:!1}),t.finish()}var Ks;(function(r){r[r.VARINT=0]="VARINT",r[r.BIT64=1]="BIT64",r[r.LENGTH_DELIMITED=2]="LENGTH_DELIMITED",r[r.START_GROUP=3]="START_GROUP",r[r.END_GROUP=4]="END_GROUP",r[r.BIT32=5]="BIT32"})(Ks||(Ks={}));function Fl(r,e,t,n){return{name:r,type:e,encode:t,decode:n}}function zp(r){function e(s){if(r[s.toString()]==null)throw new Error("Invalid enum value");return r[s]}const t=function(i,o){const a=e(i);o.int32(a)},n=function(i){const o=i.int32();return e(o)};return Fl("enum",Ks.VARINT,t,n)}function mt(r,e){return Fl("message",Ks.LENGTH_DELIMITED,r,e)}class Ao extends Error{constructor(){super(...arguments);u(this,"code","ERR_MAX_LENGTH");u(this,"name","MaxLengthError")}}class Ic extends Error{constructor(){super(...arguments);u(this,"code","ERR_MAX_SIZE");u(this,"name","MaxSizeError")}}var ge;(function(r){r.RSA="RSA",r.Ed25519="Ed25519",r.secp256k1="secp256k1",r.ECDSA="ECDSA"})(ge||(ge={}));var Io;(function(r){r[r.RSA=0]="RSA",r[r.Ed25519=1]="Ed25519",r[r.secp256k1=2]="secp256k1",r[r.ECDSA=3]="ECDSA"})(Io||(Io={}));(function(r){r.codec=()=>zp(Io)})(ge||(ge={}));var qt;(function(r){let e;r.codec=()=>(e==null&&(e=mt((t,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),t.Type!=null&&(n.uint32(8),ge.codec().encode(t.Type,n)),t.Data!=null&&(n.uint32(18),n.bytes(t.Data)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.Type=ge.codec().decode(t);break}case 2:{i.Data=t.bytes();break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>gt(t,r.codec()),r.decode=(t,n)=>ht(t,r.codec(),n)})(qt||(qt={}));var Vs;(function(r){let e;r.codec=()=>(e==null&&(e=mt((t,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),t.Type!=null&&(n.uint32(8),ge.codec().encode(t.Type,n)),t.Data!=null&&(n.uint32(18),n.bytes(t.Data)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.Type=ge.codec().decode(t);break}case 2:{i.Data=t.bytes();break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>gt(t,r.codec()),r.decode=(t,n)=>ht(t,r.codec(),n)})(Vs||(Vs={}));function Ol(r){if(isNaN(r)||r<=0)throw new Z("random bytes length must be a Number bigger than 0");return Hn(r)}class pa{constructor(e,t){u(this,"type","RSA");u(this,"jwk");u(this,"_raw");u(this,"_multihash");this.jwk=e,this._multihash=t}get raw(){return this._raw==null&&(this._raw=wa(this.jwk)),this._raw}toMultihash(){return this._multihash}toCID(){return ue.createV1(114,this._multihash)}toString(){return Ce.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:Se(this.raw,e.raw)}verify(e,t,n){return r0(this.jwk,t,e,n)}}class $l{constructor(e,t){u(this,"type","RSA");u(this,"jwk");u(this,"_raw");u(this,"publicKey");this.jwk=e,this.publicKey=t}get raw(){return this._raw==null&&(this._raw=Hp(this.jwk)),this._raw}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:Se(this.raw,e.raw)}sign(e,t){return t0(this.jwk,e,t)}}const Ul=8192,ya=18,qp=1062,Kp=Uint8Array.from([48,13,6,9,42,134,72,134,247,13,1,1,1,5,0]);function Vp(r){return{n:X(r[1],"base64url"),e:X(r[2],"base64url"),d:X(r[3],"base64url"),p:X(r[4],"base64url"),q:X(r[5],"base64url"),dp:X(r[6],"base64url"),dq:X(r[7],"base64url"),qi:X(r[8],"base64url"),kty:"RSA"}}function Hp(r){if(r.n==null||r.e==null||r.d==null||r.p==null||r.q==null||r.dp==null||r.dq==null||r.qi==null)throw new Z("JWK was missing components");return At([Ve(Uint8Array.from([0])),Ve(W(r.n,"base64url")),Ve(W(r.e,"base64url")),Ve(W(r.d,"base64url")),Ve(W(r.p,"base64url")),Ve(W(r.q,"base64url")),Ve(W(r.dp,"base64url")),Ve(W(r.dq,"base64url")),Ve(W(r.qi,"base64url"))]).subarray()}function Wp(r){const e=tn(r[1],{offset:0});return{kty:"RSA",n:X(e[0],"base64url"),e:X(e[1],"base64url")}}function wa(r){if(r.n==null||r.e==null)throw new Z("JWK was missing components");return At([Kp,na(At([Ve(W(r.n,"base64url")),Ve(W(r.e,"base64url"))]))]).subarray()}function Gp(r){const e=tn(r);return Zp(e)}function Zp(r){const e=Vp(r);return Xp(e)}function jp(r,e){if(r.byteLength>=qp)throw new jo("Key size is too large");const t=tn(r,{offset:0});return Yp(t,r,e)}function Yp(r,e,t){const n=Wp(r);if(t==null){const s=pi(qt.encode({Type:ge.RSA,Data:e}));t=en(ya,s)}return new pa(n,t)}function Xp(r){if(s0(r)>Ul)throw new Z("Key size is too large");const e=Jp(r),t=pi(qt.encode({Type:ge.RSA,Data:wa(e.publicKey)})),n=en(ya,t);return new $l(e.privateKey,new pa(e.publicKey,n))}async function Qp(r){if(r>Ul)throw new Z("Key size is too large");const e=await e0(r),t=pi(qt.encode({Type:ge.RSA,Data:wa(e.publicKey)})),n=en(ya,t);return new $l(e.privateKey,new pa(e.publicKey,n))}function Jp(r){if(r==null)throw new Z("Missing key parameter");return{privateKey:r,publicKey:{kty:r.kty,n:r.n,e:r.e}}}async function e0(r,e){const t=await Je.get().subtle.generateKey({name:"RSASSA-PKCS1-v1_5",modulusLength:r,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["sign","verify"]),n=await n0(t);return{privateKey:n[0],publicKey:n[1]}}async function t0(r,e,t){var i,o;const n=await Je.get().subtle.importKey("jwk",r,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["sign"]);(i=t==null?void 0:t.signal)==null||i.throwIfAborted();const s=await Je.get().subtle.sign({name:"RSASSA-PKCS1-v1_5"},n,e instanceof Uint8Array?e:e.subarray());return(o=t==null?void 0:t.signal)==null||o.throwIfAborted(),new Uint8Array(s,0,s.byteLength)}async function r0(r,e,t,n){var o,a;const s=await Je.get().subtle.importKey("jwk",r,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["verify"]);(o=n==null?void 0:n.signal)==null||o.throwIfAborted();const i=await Je.get().subtle.verify({name:"RSASSA-PKCS1-v1_5"},s,e,t instanceof Uint8Array?t:t.subarray());return(a=n==null?void 0:n.signal)==null||a.throwIfAborted(),i}async function n0(r,e){if(r.privateKey==null||r.publicKey==null)throw new Z("Private and public key are required");return await Promise.all([Je.get().subtle.exportKey("jwk",r.privateKey),Je.get().subtle.exportKey("jwk",r.publicKey)])}function s0(r){if(r.kty!=="RSA")throw new Z("invalid key type");if(r.n==null)throw new Z("invalid key modulus");return W(r.n,"base64url").length*8}class zl{constructor(e,t){u(this,"oHash");u(this,"iHash");u(this,"blockLen");u(this,"outputLen");u(this,"finished",!1);u(this,"destroyed",!1);if(cl(e),ee(t,void 0,"key"),this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const n=this.blockLen,s=new Uint8Array(n);s.set(t.length>n?e.create().update(t).digest():t);for(let i=0;i<s.length;i++)s[i]^=54;this.iHash.update(s),this.oHash=e.create();for(let i=0;i<s.length;i++)s[i]^=106;this.oHash.update(s),zr(s)}update(e){return Fs(this),this.iHash.update(e),this}digestInto(e){Fs(this),ee(e,this.outputLen,"output"),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:n,finished:s,destroyed:i,blockLen:o,outputLen:a}=this;return e=e,e.finished=s,e.destroyed=i,e.blockLen=o,e.outputLen=a,e.oHash=t._cloneInto(e.oHash),e.iHash=n._cloneInto(e.iHash),e}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const ql=(r,e,t)=>new zl(r,e).update(t).digest();ql.create=(r,e)=>new zl(r,e);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Cc=(r,e)=>(r+(r>=0?e:-e)/Kl)/e;function i0(r,e,t){const[[n,s],[i,o]]=e,a=Cc(o*r,t),c=Cc(-s*r,t);let l=r-a*n-c*i,d=-a*s-c*o;const f=l<_t,h=d<_t;f&&(l=-l),h&&(d=-d);const p=aa(Math.ceil(Dm(t)/2))+Tr;if(l<_t||l>=p||d<_t||d>=p)throw new Error("splitScalar (endomorphism): failed, k="+r);return{k1neg:f,k1:l,k2neg:h,k2:d}}function Co(r){if(!["compact","recovered","der"].includes(r))throw new Error('Signature format must be "compact", "recovered", or "der"');return r}function Ui(r,e){const t={};for(let n of Object.keys(e))t[n]=r[n]===void 0?e[n]:r[n];return ar(t.lowS,"lowS"),ar(t.prehash,"prehash"),t.format!==void 0&&Co(t.format),t}class o0 extends Error{constructor(e=""){super(e)}}const Ft={Err:o0,_tlv:{encode:(r,e)=>{const{Err:t}=Ft;if(r<0||r>256)throw new t("tlv.encode: wrong tag");if(e.length&1)throw new t("tlv.encode: unpadded data");const n=e.length/2,s=ns(n);if(s.length/2&128)throw new t("tlv.encode: long form length too big");const i=n>127?ns(s.length/2|128):"";return ns(r)+i+s+e},decode(r,e){const{Err:t}=Ft;let n=0;if(r<0||r>256)throw new t("tlv.encode: wrong tag");if(e.length<2||e[n++]!==r)throw new t("tlv.decode: wrong tlv");const s=e[n++],i=!!(s&128);let o=0;if(!i)o=s;else{const c=s&127;if(!c)throw new t("tlv.decode(long): indefinite length not supported");if(c>4)throw new t("tlv.decode(long): byte length is too big");const l=e.subarray(n,n+c);if(l.length!==c)throw new t("tlv.decode: length bytes not complete");if(l[0]===0)throw new t("tlv.decode(long): zero leftmost byte");for(const d of l)o=o<<8|d;if(n+=c,o<128)throw new t("tlv.decode(long): not minimal encoding")}const a=e.subarray(n,n+o);if(a.length!==o)throw new t("tlv.decode: wrong value length");return{v:a,l:e.subarray(n+o)}}},_int:{encode(r){const{Err:e}=Ft;if(r<_t)throw new e("integer: negative integers are not allowed");let t=ns(r);if(Number.parseInt(t[0],16)&8&&(t="00"+t),t.length&1)throw new e("unexpected DER parsing assertion: unpadded hex");return t},decode(r){const{Err:e}=Ft;if(r[0]&128)throw new e("invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new e("invalid signature integer: unnecessary leading zero");return yi(r)}},toSig(r){const{Err:e,_int:t,_tlv:n}=Ft,s=ee(r,void 0,"signature"),{v:i,l:o}=n.decode(48,s);if(o.length)throw new e("invalid signature: left bytes after parsing");const{v:a,l:c}=n.decode(2,i),{v:l,l:d}=n.decode(2,c);if(d.length)throw new e("invalid signature: left bytes after parsing");return{r:t.decode(a),s:t.decode(l)}},hexFromSig(r){const{_tlv:e,_int:t}=Ft,n=e.encode(2,t.encode(r.r)),s=e.encode(2,t.encode(r.s)),i=n+s;return e.encode(48,i)}},_t=BigInt(0),Tr=BigInt(1),Kl=BigInt(2),as=BigInt(3),a0=BigInt(4);function c0(r,e={}){const t=Tl("weierstrass",r,e),{Fp:n,Fn:s}=t;let i=t.CURVE;const{h:o,n:a}=i;rn(e,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object"});const{endo:c}=e;if(c&&(!n.is0(i.a)||typeof c.beta!="bigint"||!Array.isArray(c.basises)))throw new Error('invalid endo: expected "beta": bigint and "basises": array');const l=Hl(n,s);function d(){if(!n.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function f(U,w,b){const{x:I,y:k}=w.toAffine(),B=n.toBytes(I);if(ar(b,"isCompressed"),b){d();const F=!n.isOdd(k);return ft(Vl(F),B)}else return ft(Uint8Array.of(4),B,n.toBytes(k))}function h(U){ee(U,void 0,"Point");const{publicKey:w,publicKeyUncompressed:b}=l,I=U.length,k=U[0],B=U.subarray(1);if(I===w&&(k===2||k===3)){const F=n.fromBytes(B);if(!n.isValid(F))throw new Error("bad point: is not on curve, wrong x");const z=y(F);let M;try{M=n.sqrt(z)}catch(de){const ae=de instanceof Error?": "+de.message:"";throw new Error("bad point: is not on curve, sqrt error"+ae)}d();const K=n.isOdd(M);return(k&1)===1!==K&&(M=n.neg(M)),{x:F,y:M}}else if(I===b&&k===4){const F=n.BYTES,z=n.fromBytes(B.subarray(0,F)),M=n.fromBytes(B.subarray(F,F*2));if(!m(z,M))throw new Error("bad point: is not on curve");return{x:z,y:M}}else throw new Error(`bad point: got length ${I}, expected compressed=${w} or uncompressed=${b}`)}const p=e.toBytes||f,g=e.fromBytes||h;function y(U){const w=n.sqr(U),b=n.mul(w,U);return n.add(n.add(b,n.mul(U,i.a)),i.b)}function m(U,w){const b=n.sqr(w),I=y(U);return n.eql(b,I)}if(!m(i.Gx,i.Gy))throw new Error("bad curve params: generator point");const _=n.mul(n.pow(i.a,as),a0),x=n.mul(n.sqr(i.b),BigInt(27));if(n.is0(n.add(_,x)))throw new Error("bad curve params: a or b");function E(U,w,b=!1){if(!n.isValid(w)||b&&n.is0(w))throw new Error(`bad point coordinate ${U}`);return w}function C(U){if(!(U instanceof T))throw new Error("Weierstrass Point expected")}function A(U){if(!c||!c.basises)throw new Error("no endo");return i0(U,c.basises,s.ORDER)}const N=Os((U,w)=>{const{X:b,Y:I,Z:k}=U;if(n.eql(k,n.ONE))return{x:b,y:I};const B=U.is0();w==null&&(w=B?n.ONE:n.inv(k));const F=n.mul(b,w),z=n.mul(I,w),M=n.mul(k,w);if(B)return{x:n.ZERO,y:n.ZERO};if(!n.eql(M,n.ONE))throw new Error("invZ was invalid");return{x:F,y:z}}),R=Os(U=>{if(U.is0()){if(e.allowInfinityPoint&&!n.is0(U.Y))return;throw new Error("bad point: ZERO")}const{x:w,y:b}=U.toAffine();if(!n.isValid(w)||!n.isValid(b))throw new Error("bad point: x or y not field elements");if(!m(w,b))throw new Error("bad point: equation left != right");if(!U.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function L(U,w,b,I,k){return b=new T(n.mul(b.X,U),b.Y,b.Z),w=$s(I,w),b=$s(k,b),w.add(b)}const $=class ${constructor(w,b,I){u(this,"X");u(this,"Y");u(this,"Z");this.X=E("x",w),this.Y=E("y",b,!0),this.Z=E("z",I),Object.freeze(this)}static CURVE(){return i}static fromAffine(w){const{x:b,y:I}=w||{};if(!w||!n.isValid(b)||!n.isValid(I))throw new Error("invalid affine point");if(w instanceof $)throw new Error("projective point not allowed");return n.is0(b)&&n.is0(I)?$.ZERO:new $(b,I,n.ONE)}static fromBytes(w){const b=$.fromAffine(g(ee(w,void 0,"point")));return b.assertValidity(),b}static fromHex(w){return $.fromBytes(In(w))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(w=8,b=!0){return Y.createCache(this,w),b||this.multiply(as),this}assertValidity(){R(this)}hasEvenY(){const{y:w}=this.toAffine();if(!n.isOdd)throw new Error("Field doesn't support isOdd");return!n.isOdd(w)}equals(w){C(w);const{X:b,Y:I,Z:k}=this,{X:B,Y:F,Z:z}=w,M=n.eql(n.mul(b,z),n.mul(B,k)),K=n.eql(n.mul(I,z),n.mul(F,k));return M&&K}negate(){return new $(this.X,n.neg(this.Y),this.Z)}double(){const{a:w,b}=i,I=n.mul(b,as),{X:k,Y:B,Z:F}=this;let z=n.ZERO,M=n.ZERO,K=n.ZERO,j=n.mul(k,k),de=n.mul(B,B),ae=n.mul(F,F),G=n.mul(k,B);return G=n.add(G,G),K=n.mul(k,F),K=n.add(K,K),z=n.mul(w,K),M=n.mul(I,ae),M=n.add(z,M),z=n.sub(de,M),M=n.add(de,M),M=n.mul(z,M),z=n.mul(G,z),K=n.mul(I,K),ae=n.mul(w,ae),G=n.sub(j,ae),G=n.mul(w,G),G=n.add(G,K),K=n.add(j,j),j=n.add(K,j),j=n.add(j,ae),j=n.mul(j,G),M=n.add(M,j),ae=n.mul(B,F),ae=n.add(ae,ae),j=n.mul(ae,G),z=n.sub(z,j),K=n.mul(ae,de),K=n.add(K,K),K=n.add(K,K),new $(z,M,K)}add(w){C(w);const{X:b,Y:I,Z:k}=this,{X:B,Y:F,Z:z}=w;let M=n.ZERO,K=n.ZERO,j=n.ZERO;const de=i.a,ae=n.mul(i.b,as);let G=n.mul(b,B),we=n.mul(I,F),ve=n.mul(k,z),ke=n.add(b,I),fe=n.add(B,F);ke=n.mul(ke,fe),fe=n.add(G,we),ke=n.sub(ke,fe),fe=n.add(b,k);let _e=n.add(B,z);return fe=n.mul(fe,_e),_e=n.add(G,ve),fe=n.sub(fe,_e),_e=n.add(I,k),M=n.add(F,z),_e=n.mul(_e,M),M=n.add(we,ve),_e=n.sub(_e,M),j=n.mul(de,fe),M=n.mul(ae,ve),j=n.add(M,j),M=n.sub(we,j),j=n.add(we,j),K=n.mul(M,j),we=n.add(G,G),we=n.add(we,G),ve=n.mul(de,ve),fe=n.mul(ae,fe),we=n.add(we,ve),ve=n.sub(G,ve),ve=n.mul(de,ve),fe=n.add(fe,ve),G=n.mul(we,fe),K=n.add(K,G),G=n.mul(_e,fe),M=n.mul(ke,M),M=n.sub(M,G),G=n.mul(ke,we),j=n.mul(_e,j),j=n.add(j,G),new $(M,K,j)}subtract(w){return this.add(w.negate())}is0(){return this.equals($.ZERO)}multiply(w){const{endo:b}=e;if(!s.isValidNot0(w))throw new Error("invalid scalar: out of range");let I,k;const B=F=>Y.cached(this,F,z=>bn($,z));if(b){const{k1neg:F,k1:z,k2neg:M,k2:K}=A(w),{p:j,f:de}=B(z),{p:ae,f:G}=B(K);k=de.add(G),I=L(b.beta,j,ae,F,M)}else{const{p:F,f:z}=B(w);I=F,k=z}return bn($,[I,k])[0]}multiplyUnsafe(w){const{endo:b}=e,I=this;if(!s.isValid(w))throw new Error("invalid scalar: out of range");if(w===_t||I.is0())return $.ZERO;if(w===Tr)return I;if(Y.hasCache(this))return this.multiply(w);if(b){const{k1neg:k,k1:B,k2neg:F,k2:z}=A(w),{p1:M,p2:K}=Vm($,I,B,z);return L(b.beta,M,K,k,F)}else return Y.unsafe(I,w)}toAffine(w){return N(this,w)}isTorsionFree(){const{isTorsionFree:w}=e;return o===Tr?!0:w?w($,this):Y.unsafe(this,a).is0()}clearCofactor(){const{clearCofactor:w}=e;return o===Tr?this:w?w($,this):this.multiplyUnsafe(o)}isSmallOrder(){return this.multiplyUnsafe(o).is0()}toBytes(w=!0){return ar(w,"isCompressed"),this.assertValidity(),p($,this,w)}toHex(w=!0){return Vn(this.toBytes(w))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}};u($,"BASE",new $(i.Gx,i.Gy,n.ONE)),u($,"ZERO",new $(n.ZERO,n.ONE,n.ZERO)),u($,"Fp",n),u($,"Fn",s);let T=$;const V=s.BITS,Y=new Ll(T,e.endo?Math.ceil(V/2):V);return T.BASE.precompute(8),T}function Vl(r){return Uint8Array.of(r?2:3)}function Hl(r,e){return{secretKey:e.BYTES,publicKey:1+r.BYTES,publicKeyUncompressed:1+2*r.BYTES,publicKeyHasPrefix:!0,signature:2*e.BYTES}}function u0(r,e={}){const{Fn:t}=r,n=e.randomBytes||Hn,s=Object.assign(Hl(r.Fp,t),{seed:Al(t.ORDER)});function i(p){try{const g=t.fromBytes(p);return t.isValidNot0(g)}catch{return!1}}function o(p,g){const{publicKey:y,publicKeyUncompressed:m}=s;try{const _=p.length;return g===!0&&_!==y||g===!1&&_!==m?!1:!!r.fromBytes(p)}catch{return!1}}function a(p=n(s.seed)){return Km(ee(p,s.seed,"seed"),t.ORDER)}function c(p,g=!0){return r.BASE.multiply(t.fromBytes(p)).toBytes(g)}function l(p){const{secretKey:g,publicKey:y,publicKeyUncompressed:m}=s;if(!mi(p)||"_lengths"in t&&t._lengths||g===y)return;const _=ee(p,void 0,"key").length;return _===y||_===m}function d(p,g,y=!0){if(l(p)===!0)throw new Error("first arg must be private key");if(l(g)===!1)throw new Error("second arg must be public key");const m=t.fromBytes(p);return r.fromBytes(g).multiply(m).toBytes(y)}const f={isValidSecretKey:i,isValidPublicKey:o,randomSecretKey:a},h=ua(a,c);return Object.freeze({getPublicKey:c,getSharedSecret:d,keygen:h,Point:r,utils:f,lengths:s})}function l0(r,e,t={}){cl(e),rn(t,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"}),t=Object.assign({},t);const n=t.randomBytes||Hn,s=t.hmac||((w,b)=>ql(e,w,b)),{Fp:i,Fn:o}=r,{ORDER:a,BITS:c}=o,{keygen:l,getPublicKey:d,getSharedSecret:f,utils:h,lengths:p}=u0(r,t),g={prehash:!0,lowS:typeof t.lowS=="boolean"?t.lowS:!0,format:"compact",extraEntropy:!1},y=a*Kl<i.ORDER;function m(w){const b=a>>Tr;return w>b}function _(w,b){if(!o.isValidNot0(b))throw new Error(`invalid signature ${w}: out of range 1..Point.Fn.ORDER`);return b}function x(){if(y)throw new Error('"recovered" sig type is not supported for cofactor >2 curves')}function E(w,b){Co(b);const I=p.signature,k=b==="compact"?I:b==="recovered"?I+1:void 0;return ee(w,k)}class C{constructor(b,I,k){u(this,"r");u(this,"s");u(this,"recovery");if(this.r=_("r",b),this.s=_("s",I),k!=null){if(x(),![0,1,2,3].includes(k))throw new Error("invalid recovery id");this.recovery=k}Object.freeze(this)}static fromBytes(b,I=g.format){E(b,I);let k;if(I==="der"){const{r:M,s:K}=Ft.toSig(ee(b));return new C(M,K)}I==="recovered"&&(k=b[0],I="compact",b=b.subarray(1));const B=p.signature/2,F=b.subarray(0,B),z=b.subarray(B,B*2);return new C(o.fromBytes(F),o.fromBytes(z),k)}static fromHex(b,I){return this.fromBytes(In(b),I)}assertRecovery(){const{recovery:b}=this;if(b==null)throw new Error("invalid recovery id: must be present");return b}addRecoveryBit(b){return new C(this.r,this.s,b)}recoverPublicKey(b){const{r:I,s:k}=this,B=this.assertRecovery(),F=B===2||B===3?I+a:I;if(!i.isValid(F))throw new Error("invalid recovery id: sig.r+curve.n != R.x");const z=i.toBytes(F),M=r.fromBytes(ft(Vl((B&1)===0),z)),K=o.inv(F),j=N(ee(b,void 0,"msgHash")),de=o.create(-j*K),ae=o.create(k*K),G=r.BASE.multiplyUnsafe(de).add(M.multiplyUnsafe(ae));if(G.is0())throw new Error("invalid recovery: point at infinify");return G.assertValidity(),G}hasHighS(){return m(this.s)}toBytes(b=g.format){if(Co(b),b==="der")return In(Ft.hexFromSig(this));const{r:I,s:k}=this,B=o.toBytes(I),F=o.toBytes(k);return b==="recovered"?(x(),ft(Uint8Array.of(this.assertRecovery()),B,F)):ft(B,F)}toHex(b){return Vn(this.toBytes(b))}}const A=t.bits2int||function(b){if(b.length>8192)throw new Error("input is too large");const I=yi(b),k=b.length*8-c;return k>0?I>>BigInt(k):I},N=t.bits2int_modN||function(b){return o.create(A(b))},R=aa(c);function L(w){return Ln("num < 2^"+c,w,_t,R),o.toBytes(w)}function T(w,b){return ee(w,void 0,"message"),b?ee(e(w),void 0,"prehashed message"):w}function V(w,b,I){const{lowS:k,prehash:B,extraEntropy:F}=Ui(I,g);w=T(w,B);const z=N(w),M=o.fromBytes(b);if(!o.isValidNot0(M))throw new Error("invalid private key");const K=[L(M),L(z)];if(F!=null&&F!==!1){const G=F===!0?n(p.secretKey):F;K.push(ee(G,void 0,"extraEntropy"))}const j=ft(...K),de=z;function ae(G){const we=A(G);if(!o.isValidNot0(we))return;const ve=o.inv(we),ke=r.BASE.multiply(we).toAffine(),fe=o.create(ke.x);if(fe===_t)return;const _e=o.create(ve*o.create(de+fe*M));if(_e===_t)return;let Qn=(ke.x===fe?0:2)|Number(ke.y&Tr),cn=_e;return k&&m(_e)&&(cn=o.neg(_e),Qn^=1),new C(fe,cn,y?void 0:Qn)}return{seed:j,k2sig:ae}}function Y(w,b,I={}){const{seed:k,k2sig:B}=V(w,b,I);return km(e.outputLen,o.BYTES,s)(k,B).toBytes(I.format)}function $(w,b,I,k={}){const{lowS:B,prehash:F,format:z}=Ui(k,g);if(I=ee(I,void 0,"publicKey"),b=T(b,F),!mi(w)){const M=w instanceof C?", use sig.toBytes()":"";throw new Error("verify expects Uint8Array signature"+M)}E(w,z);try{const M=C.fromBytes(w,z),K=r.fromBytes(I);if(B&&M.hasHighS())return!1;const{r:j,s:de}=M,ae=N(b),G=o.inv(de),we=o.create(ae*G),ve=o.create(j*G),ke=r.BASE.multiplyUnsafe(we).add(K.multiplyUnsafe(ve));return ke.is0()?!1:o.create(ke.x)===j}catch{return!1}}function U(w,b,I={}){const{prehash:k}=Ui(I,g);return b=T(b,k),C.fromBytes(w,"recovered").recoverPublicKey(b).toBytes()}return Object.freeze({keygen:l,getPublicKey:d,getSharedSecret:f,utils:h,lengths:p,Point:r,sign:Y,verify:$,recoverPublicKey:U,Signature:C,hash:e})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const ba={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},d0={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},Lc=BigInt(2);function f0(r){const e=ba.p,t=BigInt(3),n=BigInt(6),s=BigInt(11),i=BigInt(22),o=BigInt(23),a=BigInt(44),c=BigInt(88),l=r*r*r%e,d=l*l*r%e,f=pe(d,t,e)*d%e,h=pe(f,t,e)*d%e,p=pe(h,Lc,e)*l%e,g=pe(p,s,e)*p%e,y=pe(g,i,e)*g%e,m=pe(y,a,e)*y%e,_=pe(m,c,e)*m%e,x=pe(_,a,e)*y%e,E=pe(x,t,e)*d%e,C=pe(E,o,e)*g%e,A=pe(C,n,e)*l%e,N=pe(A,Lc,e);if(!Lo.eql(Lo.sqr(N),r))throw new Error("Cannot find square root");return N}const Lo=wi(ba.p,{sqrt:f0}),h0=c0(ba,{Fp:Lo,endo:d0}),Lt=l0(h0,pi);function g0(r,e,t){const n=ra.digest(e instanceof Uint8Array?e:e.subarray());if(Ei(n))return n.then(({digest:s})=>{var i;return(i=t==null?void 0:t.signal)==null||i.throwIfAborted(),Lt.sign(s,r,{prehash:!1,format:"der"})}).catch(s=>{throw s.name==="AbortError"?s:new Sc(String(s))});try{return Lt.sign(n.digest,r,{prehash:!1,format:"der"})}catch(s){throw new Sc(String(s))}}function m0(r,e,t,n){var i;const s=ra.digest(t instanceof Uint8Array?t:t.subarray());if(Ei(s))return s.then(({digest:o})=>{var a;return(a=n==null?void 0:n.signal)==null||a.throwIfAborted(),Lt.verify(e,o,r,{prehash:!1,format:"der"})}).catch(o=>{throw o.name==="AbortError"?o:new _c(String(o))});try{return(i=n==null?void 0:n.signal)==null||i.throwIfAborted(),Lt.verify(e,s.digest,r,{prehash:!1,format:"der"})}catch(o){throw new _c(String(o))}}class Wl{constructor(e){u(this,"type","secp256k1");u(this,"raw");u(this,"_key");this._key=E0(e),this.raw=w0(this._key)}toMultihash(){return qn.digest(ir(this))}toCID(){return ue.createV1(114,this.toMultihash())}toString(){return Ce.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:Se(this.raw,e.raw)}verify(e,t,n){return m0(this._key,t,e,n)}}class Gl{constructor(e,t){u(this,"type","secp256k1");u(this,"raw");u(this,"publicKey");this.raw=b0(e),this.publicKey=new Wl(t??v0(e))}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:Se(this.raw,e.raw)}sign(e,t){return g0(this.raw,e,t)}}function p0(r){return new Gl(r)}function Zl(r){return new Wl(r)}async function y0(){const r=x0();return new Gl(r)}function w0(r){return Lt.Point.fromBytes(r).toBytes()}function b0(r){try{return Lt.getPublicKey(r,!0),r}catch(e){throw new Yo(String(e))}}function E0(r){try{return Lt.Point.fromBytes(r),r}catch(e){throw new jo(String(e))}}function v0(r){try{return Lt.getPublicKey(r,!0)}catch(e){throw new Yo(String(e))}}function x0(){return Lt.utils.randomSecretKey()}async function S0(r,e){if(r==="Ed25519")return mp();if(r==="secp256k1")return y0();if(r==="RSA")return Qp(A0());if(r==="ECDSA")return cm(I0());throw new Jr}function Ea(r,e){const{Type:t,Data:n}=qt.decode(r),s=n??new Uint8Array;switch(t){case ge.RSA:return jp(s,e);case ge.Ed25519:return Nl(s);case ge.secp256k1:return Zl(s);case ge.ECDSA:return ol(s);default:throw new Jr}}function _0(r){const{Type:e,Data:t}=qt.decode(r.digest),n=t??new Uint8Array;switch(e){case ge.Ed25519:return Nl(n);case ge.secp256k1:return Zl(n);case ge.ECDSA:return ol(n);default:throw new Jr}}function ir(r){return qt.encode({Type:ge[r.type],Data:r.raw})}function dx(r){const e=Vs.decode(r),t=e.Data??new Uint8Array;switch(e.Type){case ge.RSA:return Gp(t);case ge.Ed25519:return gp(t);case ge.secp256k1:return p0(t);case ge.ECDSA:return nm(t);default:throw new Jr}}function fx(r){return Vs.encode({Type:ge[r.type],Data:r.raw})}function A0(r){return 2048}function I0(r){return"P-256"}const jl=Symbol.for("nodejs.util.inspect.custom"),C0=114;var yu;class va{constructor(e){u(this,"type");u(this,"multihash");u(this,"publicKey");u(this,"string");u(this,yu,!0);this.type=e.type,this.multihash=e.multihash,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return`PeerId(${this.toString()})`}toString(){return this.string==null&&(this.string=Ce.encode(this.multihash.bytes).slice(1)),this.string}toMultihash(){return this.multihash}toCID(){return ue.createV1(C0,this.multihash)}toJSON(){return this.toString()}equals(e){var t;if(e==null)return!1;if(e instanceof Uint8Array)return Se(this.multihash.bytes,e);if(typeof e=="string")return this.toString()===e;if(((t=e==null?void 0:e.toMultihash())==null?void 0:t.bytes)!=null)return Se(this.multihash.bytes,e.toMultihash().bytes);throw new Error("not valid Id")}[(yu=Jo,jl)](){return`PeerId(${this.toString()})`}}class Yl extends va{constructor(t){super({...t,type:"RSA"});u(this,"type","RSA");u(this,"publicKey");this.publicKey=t.publicKey}}class Xl extends va{constructor(t){super({...t,type:"Ed25519"});u(this,"type","Ed25519");u(this,"publicKey");this.publicKey=t.publicKey}}class Ql extends va{constructor(t){super({...t,type:"secp256k1"});u(this,"type","secp256k1");u(this,"publicKey");this.publicKey=t.publicKey}}const L0=2336;var wu,bu;class Jl{constructor(e){u(this,"type","url");u(this,"multihash");u(this,"publicKey");u(this,"url");u(this,wu,!0);this.url=e.toString(),this.multihash=qn.digest(W(this.url))}[(bu=jl,wu=Jo,bu)](){return`PeerId(${this.url})`}toString(){return this.toCID().toString()}toMultihash(){return this.multihash}toCID(){return ue.createV1(L0,this.toMultihash())}toJSON(){return this.toString()}equals(e){return e==null?!1:(e instanceof Uint8Array&&(e=X(e)),e.toString()===this.toString())}}const T0=114,Tc=2336;function Kr(r,e){let t;if(r.charAt(0)==="1"||r.charAt(0)==="Q")t=hi(Ce.decode(`z${r}`));else{if(r.startsWith("k51qzi5uqu5")||r.startsWith("kzwfwjn5ji4")||r.startsWith("k2k4r8")||r.startsWith("bafz"))return xa(ue.parse(r));throw new Z('Please pass a multibase decoder for strings that do not start with "1" or "Q"')}return vi(t)}function ed(r){if(r.type==="Ed25519")return new Xl({multihash:r.toCID().multihash,publicKey:r});if(r.type==="secp256k1")return new Ql({multihash:r.toCID().multihash,publicKey:r});if(r.type==="RSA")return new Yl({multihash:r.toCID().multihash,publicKey:r});throw new Jr}function D0(r){return ed(r.publicKey)}function vi(r){if(P0(r))return new Yl({multihash:r});if(k0(r))try{const e=_0(r);if(e.type==="Ed25519")return new Xl({multihash:r,publicKey:e});if(e.type==="secp256k1")return new Ql({multihash:r,publicKey:e})}catch{const t=X(r.digest);return new Jl(new URL(t))}throw new zu("Supplied PeerID Multihash is invalid")}function xa(r){if((r==null?void 0:r.multihash)==null||r.version==null||r.version===1&&r.code!==T0&&r.code!==Tc)throw new Uu("Supplied PeerID CID is invalid");if(r.code===Tc){const e=X(r.multihash.digest);return new Jl(new URL(e))}return vi(r.multihash)}function k0(r){return r.code===qn.code}function P0(r){return r.code===ra.code}class We extends Error{constructor(){super(...arguments);u(this,"name","InvalidMultiaddrError")}}u(We,"name","InvalidMultiaddrError");class Vr extends Error{constructor(){super(...arguments);u(this,"name","ValidationError")}}u(Vr,"name","ValidationError");class td extends Error{constructor(){super(...arguments);u(this,"name","InvalidParametersError")}}u(td,"name","InvalidParametersError");class rd extends Error{constructor(){super(...arguments);u(this,"name","UnknownProtocolError")}}u(rd,"name","UnknownProtocolError");class M0{constructor(){u(this,"index",0);u(this,"input","")}new(e){return this.index=0,this.input=e,this}readAtomically(e){const t=this.index,n=e();return n===void 0&&(this.index=t),n}parseWith(e){const t=e();if(this.index===this.input.length)return t}peekChar(){if(!(this.index>=this.input.length))return this.input[this.index]}readChar(){if(!(this.index>=this.input.length))return this.input[this.index++]}readGivenChar(e){return this.readAtomically(()=>{const t=this.readChar();if(t===e)return t})}readSeparator(e,t,n){return this.readAtomically(()=>{if(!(t>0&&this.readGivenChar(e)===void 0))return n()})}readNumber(e,t,n,s){return this.readAtomically(()=>{let i=0,o=0;const a=this.peekChar();if(a===void 0)return;const c=a==="0",l=2**(8*s)-1;for(;;){const d=this.readAtomically(()=>{const f=this.readChar();if(f===void 0)return;const h=Number.parseInt(f,e);if(!Number.isNaN(h))return h});if(d===void 0)break;if(i*=e,i+=d,i>l||(o+=1,t!==void 0&&o>t))return}if(o!==0)return!n&&c&&o>1?void 0:i})}readIPv4Addr(){return this.readAtomically(()=>{const e=new Uint8Array(4);for(let t=0;t<e.length;t++){const n=this.readSeparator(".",t,()=>this.readNumber(10,3,!1,1));if(n===void 0)return;e[t]=n}return e})}readIPv6Addr(){const e=t=>{for(let n=0;n<t.length/2;n++){const s=n*2;if(n<t.length-3){const o=this.readSeparator(":",n,()=>this.readIPv4Addr());if(o!==void 0)return t[s]=o[0],t[s+1]=o[1],t[s+2]=o[2],t[s+3]=o[3],[s+4,!0]}const i=this.readSeparator(":",n,()=>this.readNumber(16,4,!0,2));if(i===void 0)return[s,!1];t[s]=i>>8,t[s+1]=i&255}return[t.length,!1]};return this.readAtomically(()=>{const t=new Uint8Array(16),[n,s]=e(t);if(n===16)return t;if(s||this.readGivenChar(":")===void 0||this.readGivenChar(":")===void 0)return;const i=new Uint8Array(14),o=16-(n+2),[a]=e(i.subarray(0,o));return t.set(i.subarray(0,a),16-a),t})}readIPAddr(){return this.readIPv4Addr()??this.readIPv6Addr()}}const nd=45,N0=15,Hr=new M0;function sd(r){if(!(r.length>N0))return Hr.new(r).parseWith(()=>Hr.readIPv4Addr())}function id(r){if(r.includes("%")&&(r=r.split("%")[0]),!(r.length>nd))return Hr.new(r).parseWith(()=>Hr.readIPv6Addr())}function To(r,e=!1){if(r.includes("%")&&(r=r.split("%")[0]),r.length>nd)return;const t=Hr.new(r).parseWith(()=>Hr.readIPAddr());if(t)return e&&t.length===4?Uint8Array.from([0,0,0,0,0,0,0,0,0,0,255,255,t[0],t[1],t[2],t[3]]):t}function Wr(r){return!!sd(r)}function od(r){return!!id(r)}const Hs=4,Dr=6,ad=273,R0=33,Ws=41,cd=42,Sa=43,ud=53,ld=54,dd=55,fd=56,B0=132,F0=301,O0=302,hd=400,Q=421,$0=444,U0=445,z0=446,q0=447,kr=448,Gs=449,K0=454,gd=460,md=461,pd=465,Dn=466,Pr=480,V0=481,Do=443,_a=477,yd=478,H0=479,W0=277,G0=275,Z0=276,wd=280,vn=281,Aa=290,bd=777;function Dc(r){return e=>X(e,r)}function kc(r){return e=>W(e,r)}function pn(r){return new DataView(r.buffer).getUint16(r.byteOffset).toString()}function xr(r){const e=new ArrayBuffer(2);return new DataView(e).setUint16(0,typeof r=="string"?parseInt(r):r),new Uint8Array(e)}function j0(r){const e=r.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==16)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);const t=W(e[0],"base32"),n=parseInt(e[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");const s=xr(n);return Ur([t,s],t.length+s.length)}function Y0(r){const e=r.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==56)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);const t=zt.decode(`b${e[0]}`),n=parseInt(e[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");const s=xr(n);return Ur([t,s],t.length+s.length)}function Pc(r){const e=r.subarray(0,r.length-2),t=r.subarray(r.length-2),n=X(e,"base32"),s=pn(t);return`${n}:${s}`}const Ed=function(r){r=r.toString().trim();const e=new Uint8Array(4);return r.split(/\./g).forEach((t,n)=>{const s=parseInt(t,10);if(isNaN(s)||s<0||s>255)throw new We("Invalid byte value in IP address");e[n]=s}),e},X0=function(r){let e=0;r=r.toString().trim();const t=r.split(":",8);let n;for(n=0;n<t.length;n++){const i=Wr(t[n]);let o;i&&(o=Ed(t[n]),t[n]=X(o.subarray(0,2),"base16")),o!=null&&++n<8&&t.splice(n,0,X(o.subarray(2,4),"base16"))}if(t[0]==="")for(;t.length<8;)t.unshift("0");else if(t[t.length-1]==="")for(;t.length<8;)t.push("0");else if(t.length<8){for(n=0;n<t.length&&t[n]!=="";n++);const i=[n,1];for(n=9-t.length;n>0;n--)i.push("0");t.splice.apply(t,i)}const s=new Uint8Array(e+16);for(n=0;n<t.length;n++){t[n]===""&&(t[n]="0");const i=parseInt(t[n],16);if(isNaN(i)||i<0||i>65535)throw new We("Invalid byte value in IP address");s[e++]=i>>8&255,s[e++]=i&255}return s},Q0=function(r){if(r.byteLength!==4)throw new We("IPv4 address was incorrect length");const e=[];for(let t=0;t<r.byteLength;t++)e.push(r[t]);return e.join(".")},J0=function(r){if(r.byteLength!==16)throw new We("IPv6 address was incorrect length");const e=[];for(let n=0;n<r.byteLength;n+=2){const s=r[n],i=r[n+1],o=`${s.toString(16).padStart(2,"0")}${i.toString(16).padStart(2,"0")}`;e.push(o)}const t=e.join(":");try{const n=new URL(`http://[${t}]`);return n.hostname.substring(1,n.hostname.length-1)}catch{throw new We(`Invalid IPv6 address "${t}"`)}};function ey(r){try{const e=new URL(`http://[${r}]`);return e.hostname.substring(1,e.hostname.length-1)}catch{throw new We(`Invalid IPv6 address "${r}"`)}}const zi=Object.values(bo).map(r=>r.decoder),ty=function(){let r=zi[0].or(zi[1]);return zi.slice(2).forEach(e=>r=r.or(e)),r}();function ry(r){return ty.decode(r)}function ny(r){return e=>r.encoder.encode(e)}function sy(r){if(parseInt(r).toString()!==r)throw new Vr("Value must be an integer")}function iy(r){if(r<0)throw new Vr("Value must be a positive integer, or zero")}function oy(r){return e=>{if(e>r)throw new Vr(`Value must be smaller than or equal to ${r}`)}}function ay(...r){return e=>{for(const t of r)t(e)}}const cs=ay(sy,iy,oy(65535)),Me=-1;class cy{constructor(){u(this,"protocolsByCode",new Map);u(this,"protocolsByName",new Map)}getProtocol(e){let t;if(typeof e=="string"?t=this.protocolsByName.get(e):t=this.protocolsByCode.get(e),t==null)throw new rd(`Protocol ${e} was unknown`);return t}addProtocol(e){var t;this.protocolsByCode.set(e.code,e),this.protocolsByName.set(e.name,e),(t=e.aliases)==null||t.forEach(n=>{this.protocolsByName.set(n,e)})}removeProtocol(e){var n;const t=this.protocolsByCode.get(e);t!=null&&(this.protocolsByCode.delete(t.code),this.protocolsByName.delete(t.name),(n=t.aliases)==null||n.forEach(s=>{this.protocolsByName.delete(s)}))}}const nn=new cy,uy=[{code:Hs,name:"ip4",size:32,valueToBytes:Ed,bytesToValue:Q0,validate:r=>{if(!Wr(r))throw new Vr(`Invalid IPv4 address "${r}"`)}},{code:Dr,name:"tcp",size:16,valueToBytes:xr,bytesToValue:pn,validate:cs},{code:ad,name:"udp",size:16,valueToBytes:xr,bytesToValue:pn,validate:cs},{code:R0,name:"dccp",size:16,valueToBytes:xr,bytesToValue:pn,validate:cs},{code:Ws,name:"ip6",size:128,valueToBytes:X0,bytesToValue:J0,stringToValue:ey,validate:r=>{if(!od(r))throw new Vr(`Invalid IPv6 address "${r}"`)}},{code:cd,name:"ip6zone",size:Me},{code:Sa,name:"ipcidr",size:8,bytesToValue:Dc("base10"),valueToBytes:kc("base10")},{code:ud,name:"dns",size:Me},{code:ld,name:"dns4",size:Me},{code:dd,name:"dns6",size:Me},{code:fd,name:"dnsaddr",size:Me},{code:B0,name:"sctp",size:16,valueToBytes:xr,bytesToValue:pn,validate:cs},{code:F0,name:"udt"},{code:O0,name:"utp"},{code:hd,name:"unix",size:Me,stringToValue:r=>decodeURIComponent(r),valueToString:r=>encodeURIComponent(r)},{code:Q,name:"p2p",aliases:["ipfs"],size:Me,bytesToValue:Dc("base58btc"),valueToBytes:r=>r.startsWith("Q")||r.startsWith("1")?kc("base58btc")(r):ue.parse(r).multihash.bytes},{code:$0,name:"onion",size:96,bytesToValue:Pc,valueToBytes:j0},{code:U0,name:"onion3",size:296,bytesToValue:Pc,valueToBytes:Y0},{code:z0,name:"garlic64",size:Me},{code:q0,name:"garlic32",size:Me},{code:kr,name:"tls"},{code:Gs,name:"sni",size:Me},{code:K0,name:"noise"},{code:gd,name:"quic"},{code:md,name:"quic-v1"},{code:pd,name:"webtransport"},{code:Dn,name:"certhash",size:Me,bytesToValue:ny(el),valueToBytes:ry},{code:Pr,name:"http"},{code:V0,name:"http-path",size:Me,stringToValue:r=>`/${decodeURIComponent(r)}`,valueToString:r=>encodeURIComponent(r.substring(1))},{code:Do,name:"https"},{code:_a,name:"ws"},{code:yd,name:"wss"},{code:H0,name:"p2p-websocket-star"},{code:W0,name:"p2p-stardust"},{code:G0,name:"p2p-webrtc-star"},{code:Z0,name:"p2p-webrtc-direct"},{code:wd,name:"webrtc-direct"},{code:vn,name:"webrtc"},{code:Aa,name:"p2p-circuit"},{code:bd,name:"memory",size:Me}];uy.forEach(r=>{nn.addProtocol(r)});function ly(r){var n;const e=[];let t=0;for(;t<r.length;){const s=Wn(r,t),i=nn.getProtocol(s),o=Ge(s),a=gy(i,r,t+o);let c=0;a>0&&i.size===Me&&(c=Ge(a));const l=o+c+a,d={code:s,name:i.name,bytes:r.subarray(t,t+l)};if(a>0){const f=t+o+c,h=r.subarray(f,f+a);d.value=((n=i.bytesToValue)==null?void 0:n.call(i,h))??X(h)}e.push(d),t+=l}return e}function dy(r){var n;let e=0;const t=[];for(const s of r){if(s.bytes==null){const i=nn.getProtocol(s.code),o=Ge(s.code);let a,c=0,l=0;s.value!=null&&(a=((n=i.valueToBytes)==null?void 0:n.call(i,s.value))??W(s.value),c=a.byteLength,i.size===Me&&(l=Ge(c)));const d=new Uint8Array(o+l+c);let f=0;qs(s.code,d,f),f+=o,a!=null&&(i.size===Me&&(qs(c,d,f),f+=l),d.set(a,f)),s.bytes=d}t.push(s.bytes),e+=s.bytes.byteLength}return Ur(t,e)}function fy(r){var i;if(r.charAt(0)!=="/")throw new We('String multiaddr must start with "/"');const e=[];let t="protocol",n="",s="";for(let o=1;o<r.length;o++){const a=r.charAt(o);a!=="/"&&(t==="protocol"?s+=r.charAt(o):n+=r.charAt(o));const c=o===r.length-1;if(a==="/"||c){const l=nn.getProtocol(s);if(t==="protocol"){if(l.size==null||l.size===0){e.push({code:l.code,name:l.name}),n="",s="",t="protocol";continue}else if(c)throw new We(`Component ${s} was missing value`);t="value"}else if(t==="value"){const d={code:l.code,name:l.name};if(l.size!=null&&l.size!==0){if(n==="")throw new We(`Component ${s} was missing value`);d.value=((i=l.stringToValue)==null?void 0:i.call(l,n))??n}e.push(d),n="",s="",t="protocol"}}}if(s!==""&&n!=="")throw new We("Incomplete multiaddr");return e}function hy(r){return`/${r.flatMap(e=>{var n;if(e.value==null)return e.name;const t=nn.getProtocol(e.code);if(t==null)throw new We(`Unknown protocol code ${e.code}`);return[e.name,((n=t.valueToString)==null?void 0:n.call(t,e.value))??e.value]}).join("/")}`}function gy(r,e,t){return r.size==null||r.size===0?0:r.size>0?r.size/8:Wn(e,t)}const my=Symbol.for("nodejs.util.inspect.custom"),vd=Symbol.for("@multiformats/multiaddr");function py(r){if(r==null&&(r="/"),xi(r))return r.getComponents();if(r instanceof Uint8Array)return ly(r);if(typeof r=="string")return r=r.replace(/\/(\/)+/,"/").replace(/(\/)+$/,""),r===""&&(r="/"),fy(r);if(Array.isArray(r))return r;throw new We("Must be a string, Uint8Array, Component[], or another Multiaddr")}var Eu,nt,Nr,Rr;const Sr=class Sr{constructor(e="/",t={}){u(this,Eu,!0);se(this,nt);se(this,Nr);se(this,Rr);re(this,nt,py(e)),t.validate!==!1&&yy(this)}get bytes(){return v(this,Rr)==null&&re(this,Rr,dy(v(this,nt))),v(this,Rr)}toString(){return v(this,Nr)==null&&re(this,Nr,hy(v(this,nt))),v(this,Nr)}toJSON(){return this.toString()}getComponents(){return[...v(this,nt).map(e=>({...e}))]}encapsulate(e){const t=new Sr(e);return new Sr([...v(this,nt),...t.getComponents()],{validate:!1})}decapsulate(e){const t=e.toString(),n=this.toString(),s=n.lastIndexOf(t);if(s<0)throw new td(`Address ${this.toString()} does not contain subaddress: ${t}`);return new Sr(n.slice(0,s),{validate:!1})}decapsulateCode(e){let t;for(let n=v(this,nt).length-1;n>-1;n--)if(v(this,nt)[n].code===e){t=n;break}return new Sr(v(this,nt).slice(0,t),{validate:!1})}equals(e){return Se(this.bytes,e.bytes)}[(Eu=vd,my)](){return`Multiaddr(${this.toString()})`}};nt=new WeakMap,Nr=new WeakMap,Rr=new WeakMap;let ko=Sr;function yy(r){r.getComponents().forEach(e=>{var n;const t=nn.getProtocol(e.code);e.value!=null&&((n=t.validate)==null||n.call(t,e.value))})}function xi(r){return!!(r!=null&&r[vd])}function Ee(r){return new ko(r)}function Gr(r){const e=new globalThis.AbortController;function t(){const i=r.filter(o=>(o==null?void 0:o.aborted)===!0).map(o=>o==null?void 0:o.reason).pop();e.abort(i);for(const o of r)(o==null?void 0:o.removeEventListener)!=null&&o.removeEventListener("abort",t)}for(const i of r){if((i==null?void 0:i.aborted)===!0){t();break}(i==null?void 0:i.addEventListener)!=null&&i.addEventListener("abort",t)}function n(){for(const i of r)(i==null?void 0:i.removeEventListener)!=null&&i.removeEventListener("abort",t)}const s=e.signal;return s.clear=n,s}const Zr=1e3,jr=Zr*60,Yr=jr*60,ur=Yr*24,kn=ur*7,Xr=ur*365.25,Pn=Xr/12;function wy(r,e){if(typeof r=="string")return by(r);if(typeof r=="number")return xy(r,e);throw Error(`Value provided to ms() must be a string or number. value=${JSON.stringify(r)}`)}var xd=wy;function by(r){if(typeof r!="string"||r.length===0||r.length>100)throw Error(`Value provided to ms.parse() must be a string with length between 1 and 99. value=${JSON.stringify(r)}`);let e=/^(?<value>-?\d*\.?\d+) *(?<unit>milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|months?|mo|years?|yrs?|y)?$/i.exec(r);if(!(e!=null&&e.groups))return NaN;let{value:t,unit:n="ms"}=e.groups,s=parseFloat(t),i=n.toLowerCase();switch(i){case"years":case"year":case"yrs":case"yr":case"y":return s*Xr;case"months":case"month":case"mo":return s*Pn;case"weeks":case"week":case"w":return s*kn;case"days":case"day":case"d":return s*ur;case"hours":case"hour":case"hrs":case"hr":case"h":return s*Yr;case"minutes":case"minute":case"mins":case"min":case"m":return s*jr;case"seconds":case"second":case"secs":case"sec":case"s":return s*Zr;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return s;default:throw Error(`Unknown unit "${i}" provided to ms.parse(). value=${JSON.stringify(r)}`)}}function Ey(r){let e=Math.abs(r);return e>=Xr?`${Math.round(r/Xr)}y`:e>=Pn?`${Math.round(r/Pn)}mo`:e>=kn?`${Math.round(r/kn)}w`:e>=ur?`${Math.round(r/ur)}d`:e>=Yr?`${Math.round(r/Yr)}h`:e>=jr?`${Math.round(r/jr)}m`:e>=Zr?`${Math.round(r/Zr)}s`:`${r}ms`}function vy(r){let e=Math.abs(r);return e>=Xr?Wt(r,e,Xr,"year"):e>=Pn?Wt(r,e,Pn,"month"):e>=kn?Wt(r,e,kn,"week"):e>=ur?Wt(r,e,ur,"day"):e>=Yr?Wt(r,e,Yr,"hour"):e>=jr?Wt(r,e,jr,"minute"):e>=Zr?Wt(r,e,Zr,"second"):`${r} ms`}function xy(r,e){if(typeof r!="number"||!Number.isFinite(r))throw Error("Value provided to ms.format() must be of type number.");return e!=null&&e.long?vy(r):Ey(r)}function Wt(r,e,t,n){let s=e>=t*1.5;return`${Math.round(r/t)} ${n}${s?"s":""}`}function Sy(r){t.debug=t,t.default=t,t.coerce=c,t.disable=i,t.enable=s,t.enabled=o,t.humanize=xd,t.destroy=l,Object.keys(r).forEach(d=>{t[d]=r[d]}),t.names=[],t.skips=[],t.formatters={};function e(d){let f=0;for(let h=0;h<d.length;h++)f=(f<<5)-f+d.charCodeAt(h),f|=0;return t.colors[Math.abs(f)%t.colors.length]}t.selectColor=e;function t(d,f){let h,p=null,g,y;function m(..._){if(!m.enabled)return;const x=m,E=Number(new Date),C=E-(h||E);x.diff=C,x.prev=h,x.curr=E,h=E,_[0]=t.coerce(_[0]),typeof _[0]!="string"&&_.unshift("%O");let A=0;_[0]=_[0].replace(/%([a-zA-Z%])/g,(R,L)=>{if(R==="%%")return"%";A++;const T=t.formatters[L];if(typeof T=="function"){const V=_[A];R=T.call(x,V),_.splice(A,1),A--}return R}),t.formatArgs.call(x,_),(f==null?void 0:f.onLog)!=null&&f.onLog(..._),(x.log||t.log).apply(x,_)}return m.namespace=d,m.useColors=t.useColors(),m.color=t.selectColor(d),m.extend=n,m.destroy=t.destroy,Object.defineProperty(m,"enabled",{enumerable:!0,configurable:!1,get:()=>p!==null?p:(g!==t.namespaces&&(g=t.namespaces,y=t.enabled(d)),y),set:_=>{p=_}}),typeof t.init=="function"&&t.init(m),m}function n(d,f){const h=t(this.namespace+(typeof f>"u"?":":f)+d);return h.log=this.log,h}function s(d){t.save(d),t.namespaces=d,t.names=[],t.skips=[];let f;const h=(typeof d=="string"?d:"").split(/[\s,]+/),p=h.length;for(f=0;f<p;f++)h[f]&&(d=h[f].replace(/\*/g,".*?"),d[0]==="-"?t.skips.push(new RegExp("^"+d.substr(1)+"$")):t.names.push(new RegExp("^"+d+"$")))}function i(){const d=[...t.names.map(a),...t.skips.map(a).map(f=>"-"+f)].join(",");return t.enable(""),d}function o(d){if(d[d.length-1]==="*")return!0;let f,h;for(f=0,h=t.skips.length;f<h;f++)if(t.skips[f].test(d))return!1;for(f=0,h=t.names.length;f<h;f++)if(t.names[f].test(d))return!0;return!1}function a(d){return d.toString().substring(2,d.toString().length-2).replace(/\.\*\?$/,"*")}function c(d){return d instanceof Error?d.stack??d.message:d}function l(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")}return t.setupFormatters(t.formatters),t.enable(t.load()),t}var _y={};const dt=ky(),Ay=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"];function Iy(){var r,e,t,n,s;return typeof window<"u"&&window.process&&(window.process.type==="renderer"||window.process.__nwjs)?!0:typeof navigator<"u"&&((r=navigator.userAgent)==null?void 0:r.toLowerCase().match(/(edge|trident)\/(\d+)/))!=null?!1:typeof document<"u"&&((t=(e=document.documentElement)==null?void 0:e.style)==null?void 0:t.WebkitAppearance)||typeof window<"u"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator<"u"&&((n=navigator.userAgent)==null?void 0:n.toLowerCase().match(/firefox\/(\d+)/))!=null&&parseInt(RegExp.$1,10)>=31||typeof navigator<"u"&&((s=navigator.userAgent)==null?void 0:s.toLowerCase().match(/applewebkit\/(\d+)/))}function Cy(r){if(r[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+r[0]+(this.useColors?"%c ":" ")+"+"+xd(this.diff),!this.useColors)return;const e="color: "+this.color;r.splice(1,0,e,"color: inherit");let t=0,n=0;r[0].replace(/%[a-zA-Z%]/g,s=>{s!=="%%"&&(t++,s==="%c"&&(n=t))}),r.splice(n,0,e)}const Ly=console.debug??console.log??(()=>{});function Ty(r){try{r?dt==null||dt.setItem("debug",r):dt==null||dt.removeItem("debug")}catch{}}function Dy(){let r;try{r=dt==null?void 0:dt.getItem("debug")}catch{}return!r&&typeof globalThis.process<"u"&&"env"in globalThis.process&&(r=_y.DEBUG),r}function ky(){try{return localStorage}catch{}}function Py(r){r.j=function(e){try{return JSON.stringify(e)}catch(t){return"[UnexpectedJSONParseError]: "+t.message}}}const ze=Sy({formatArgs:Cy,save:Ty,load:Dy,useColors:Iy,setupFormatters:Py,colors:Ay,storage:dt,log:Ly});ze.formatters.b=r=>r==null?"undefined":Ce.baseEncode(r);ze.formatters.t=r=>r==null?"undefined":zt.baseEncode(r);ze.formatters.m=r=>r==null?"undefined":Ju.baseEncode(r);ze.formatters.p=r=>r==null?"undefined":r.toString();ze.formatters.c=r=>r==null?"undefined":r.toString();ze.formatters.k=r=>r==null?"undefined":r.toString();ze.formatters.a=r=>r==null?"undefined":r.toString();function Mc(r,e=""){const t=Nc(r.message),n=Nc(r.stack);return t!=null&&n!=null?n.includes(t)?`${n.split(`
`).join(`
${e}`)}`:`${t}
${e}${n.split(`
`).join(`
${e}`)}`:n!=null?`${n.split(`
`).join(`
${e}`)}`:t!=null?`${t}`:`${r.toString()}`}function My(r){return r instanceof AggregateError||(r==null?void 0:r.name)==="AggregateError"&&Array.isArray(r.errors)}function Sd(r,e=""){if(My(r)){let t=Mc(r,e);return r.errors.length>0?(e=`${e}    `,t+=`
${e}${r.errors.map(n=>`${Sd(n,`${e}`)}`).join(`
${e}`)}`):t+=`
${e}[Error list was empty]`,t.trim()}return Mc(r,e)}ze.formatters.e=r=>r==null?"undefined":Sd(r);function Ny(r){const e=()=>{};return e.enabled=!1,e.color="",e.diff=0,e.log=()=>{},e.namespace=r,e.destroy=()=>!0,e.extend=()=>e,e}function hx(r,e){return{forComponent(t){return Ia(`${r}:${t}`,e)}}}function _d(r){return{forComponent(e){return Ia(e,r)}}}function Ia(r,e){let t=Ny(`${r}:trace`);return ze.enabled(`${r}:trace`)&&ze.names.map(n=>n.toString()).find(n=>n.includes(":trace"))!=null&&(t=ze(`${r}:trace`,e)),Object.assign(ze(r,e),{error:ze(`${r}:error`,e),trace:t,newScope:n=>Ia(`${r}:${n}`,e)})}function gx(r){ze.enable(r)}function Nc(r){if(r!=null&&(r=r.trim(),r.length!==0))return r}const Ry=["Object","RegExp","Date","Error","Map","Set","WeakMap","WeakSet","ArrayBuffer","SharedArrayBuffer","DataView","Promise","URL","HTMLElement","Int8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","BigInt64Array","BigUint64Array"];function By(r){if(r===null)return"null";if(r===void 0)return"undefined";if(r===!0||r===!1)return"boolean";const e=typeof r;if(e==="string"||e==="number"||e==="bigint"||e==="symbol")return e;if(e==="function")return"Function";if(Array.isArray(r))return"Array";if(r instanceof Uint8Array)return"Uint8Array";if(r.constructor===Object)return"Object";const t=Fy(r);return t||"Object"}function Fy(r){const e=Object.prototype.toString.call(r).slice(8,-1);if(Ry.includes(e))return e}class S{constructor(e,t,n){this.major=e,this.majorEncoded=e<<5,this.name=t,this.terminal=n}toString(){return`Type[${this.major}].${this.name}`}compare(e){return this.major<e.major?-1:this.major>e.major?1:0}static equals(e,t){return e===t||e.major===t.major&&e.name===t.name}}S.uint=new S(0,"uint",!0);S.negint=new S(1,"negint",!0);S.bytes=new S(2,"bytes",!0);S.string=new S(3,"string",!0);S.array=new S(4,"array",!1);S.map=new S(5,"map",!1);S.tag=new S(6,"tag",!1);S.float=new S(7,"float",!0);S.false=new S(7,"false",!0);S.true=new S(7,"true",!0);S.null=new S(7,"null",!0);S.undefined=new S(7,"undefined",!0);S.break=new S(7,"break",!0);class q{constructor(e,t,n){this.type=e,this.value=t,this.encodedLength=n,this.encodedBytes=void 0,this.byteValue=void 0}toString(){return`Token[${this.type}].${this.value}`}}const Ad=globalThis.process&&!globalThis.process.browser&&globalThis.Buffer&&typeof globalThis.Buffer.isBuffer=="function",Oy=new TextEncoder;function Po(r){return Ad&&globalThis.Buffer.isBuffer(r)}function $y(r){return r instanceof Uint8Array?Po(r)?new Uint8Array(r.buffer,r.byteOffset,r.byteLength):r:Uint8Array.from(r)}const Uy=24,zy=200,qy=Ad?r=>r.length>=Uy?globalThis.Buffer.from(r):Rc(r):r=>r.length>=zy?Oy.encode(r):Rc(r);function Ky(r,e){if(Po(r)&&Po(e))return r.compare(e);for(let t=0;t<r.length;t++)if(r[t]!==e[t])return r[t]<e[t]?-1:1;return 0}function Rc(r){const e=[];let t=0;for(let n=0;n<r.length;n++){let s=r.charCodeAt(n);s<128?e[t++]=s:s<2048?(e[t++]=s>>6|192,e[t++]=s&63|128):(s&64512)===55296&&n+1<r.length&&(r.charCodeAt(n+1)&64512)===56320?(s=65536+((s&1023)<<10)+(r.charCodeAt(++n)&1023),e[t++]=s>>18|240,e[t++]=s>>12&63|128,e[t++]=s>>6&63|128,e[t++]=s&63|128):(s>=55296&&s<=57343&&(s=65533),e[t++]=s>>12|224,e[t++]=s>>6&63|128,e[t++]=s&63|128)}return e}const J="CBOR decode error:",Id="CBOR encode error:";function sn(r,e,t){if(r.length-e<t)throw new Error(`${J} not enough data for type`)}const Le=[24,256,65536,4294967296,BigInt("18446744073709551616")];function dr(r,e,t){sn(r,e,1);const n=r[e];if(t.strict===!0&&n<Le[0])throw new Error(`${J} integer encoded in more bytes than necessary (strict decode)`);return n}function fr(r,e,t){sn(r,e,2);const n=r[e]<<8|r[e+1];if(t.strict===!0&&n<Le[1])throw new Error(`${J} integer encoded in more bytes than necessary (strict decode)`);return n}function hr(r,e,t){sn(r,e,4);const n=r[e]*16777216+(r[e+1]<<16)+(r[e+2]<<8)+r[e+3];if(t.strict===!0&&n<Le[2])throw new Error(`${J} integer encoded in more bytes than necessary (strict decode)`);return n}function gr(r,e,t){sn(r,e,8);const n=r[e]*16777216+(r[e+1]<<16)+(r[e+2]<<8)+r[e+3],s=r[e+4]*16777216+(r[e+5]<<16)+(r[e+6]<<8)+r[e+7],i=(BigInt(n)<<BigInt(32))+BigInt(s);if(t.strict===!0&&i<Le[3])throw new Error(`${J} integer encoded in more bytes than necessary (strict decode)`);if(i<=Number.MAX_SAFE_INTEGER)return Number(i);if(t.allowBigInt===!0)return i;throw new Error(`${J} integers outside of the safe integer range are not supported`)}function Vy(r,e,t,n){return new q(S.uint,dr(r,e+1,n),2)}function Hy(r,e,t,n){return new q(S.uint,fr(r,e+1,n),3)}function Wy(r,e,t,n){return new q(S.uint,hr(r,e+1,n),5)}function Gy(r,e,t,n){return new q(S.uint,gr(r,e+1,n),9)}function mr(r,e){return et(r,0,e.value)}function et(r,e,t){if(t<Le[0]){const n=Number(t);r.push([e|n])}else if(t<Le[1]){const n=Number(t);r.push([e|24,n])}else if(t<Le[2]){const n=Number(t);r.push([e|25,n>>>8,n&255])}else if(t<Le[3]){const n=Number(t);r.push([e|26,n>>>24&255,n>>>16&255,n>>>8&255,n&255])}else{const n=BigInt(t);if(n<Le[4]){const s=[e|27,0,0,0,0,0,0,0];let i=Number(n&BigInt(4294967295)),o=Number(n>>BigInt(32)&BigInt(4294967295));s[8]=i&255,i=i>>8,s[7]=i&255,i=i>>8,s[6]=i&255,i=i>>8,s[5]=i&255,s[4]=o&255,o=o>>8,s[3]=o&255,o=o>>8,s[2]=o&255,o=o>>8,s[1]=o&255,r.push(s)}else throw new Error(`${J} encountered BigInt larger than allowable range`)}}mr.encodedSize=function(e){return et.encodedSize(e.value)};et.encodedSize=function(e){return e<Le[0]?1:e<Le[1]?2:e<Le[2]?3:e<Le[3]?5:9};mr.compareTokens=function(e,t){return e.value<t.value?-1:e.value>t.value?1:0};function Zy(r,e,t,n){return new q(S.negint,-1-dr(r,e+1,n),2)}function jy(r,e,t,n){return new q(S.negint,-1-fr(r,e+1,n),3)}function Yy(r,e,t,n){return new q(S.negint,-1-hr(r,e+1,n),5)}const Ca=BigInt(-1),Cd=BigInt(1);function Xy(r,e,t,n){const s=gr(r,e+1,n);if(typeof s!="bigint"){const i=-1-s;if(i>=Number.MIN_SAFE_INTEGER)return new q(S.negint,i,9)}if(n.allowBigInt!==!0)throw new Error(`${J} integers outside of the safe integer range are not supported`);return new q(S.negint,Ca-BigInt(s),9)}function La(r,e){const t=e.value,n=typeof t=="bigint"?t*Ca-Cd:t*-1-1;et(r,e.type.majorEncoded,n)}La.encodedSize=function(e){const t=e.value,n=typeof t=="bigint"?t*Ca-Cd:t*-1-1;return n<Le[0]?1:n<Le[1]?2:n<Le[2]?3:n<Le[3]?5:9};La.compareTokens=function(e,t){return e.value<t.value?1:e.value>t.value?-1:0};function Gn(r,e,t,n){sn(r,e,t+n);const s=r.slice(e+t,e+t+n);return new q(S.bytes,s,t+n)}function Qy(r,e,t,n){return Gn(r,e,1,t)}function Jy(r,e,t,n){return Gn(r,e,2,dr(r,e+1,n))}function ew(r,e,t,n){return Gn(r,e,3,fr(r,e+1,n))}function tw(r,e,t,n){return Gn(r,e,5,hr(r,e+1,n))}function rw(r,e,t,n){const s=gr(r,e+1,n);if(typeof s=="bigint")throw new Error(`${J} 64-bit integer bytes lengths not supported`);return Gn(r,e,9,s)}function Zs(r){return r.encodedBytes===void 0&&(r.encodedBytes=S.equals(r.type,S.string)?qy(r.value):r.value),r.encodedBytes}function Si(r,e){const t=Zs(e);et(r,e.type.majorEncoded,t.length),r.push(t)}Si.encodedSize=function(e){const t=Zs(e);return et.encodedSize(t.length)+t.length};Si.compareTokens=function(e,t){return nw(Zs(e),Zs(t))};function nw(r,e){return r.length<e.length?-1:r.length>e.length?1:Ky(r,e)}const Bc=new TextDecoder,sw=32;function iw(r,e,t){if(t-e<sw){let s="";for(let i=e;i<t;i++){const o=r[i];if(o&128)return Bc.decode(r.subarray(e,t));s+=String.fromCharCode(o)}return s}return Bc.decode(r.subarray(e,t))}function Zn(r,e,t,n,s){const i=t+n;sn(r,e,i);const o=new q(S.string,iw(r,e+t,e+i),i);return s.retainStringBytes===!0&&(o.byteValue=r.slice(e+t,e+i)),o}function ow(r,e,t,n){return Zn(r,e,1,t,n)}function aw(r,e,t,n){return Zn(r,e,2,dr(r,e+1,n),n)}function cw(r,e,t,n){return Zn(r,e,3,fr(r,e+1,n),n)}function uw(r,e,t,n){return Zn(r,e,5,hr(r,e+1,n),n)}function lw(r,e,t,n){const s=gr(r,e+1,n);if(typeof s=="bigint")throw new Error(`${J} 64-bit integer string lengths not supported`);return Zn(r,e,9,s,n)}const dw=Si;function on(r,e,t,n){return new q(S.array,n,t)}function fw(r,e,t,n){return on(r,e,1,t)}function hw(r,e,t,n){return on(r,e,2,dr(r,e+1,n))}function gw(r,e,t,n){return on(r,e,3,fr(r,e+1,n))}function mw(r,e,t,n){return on(r,e,5,hr(r,e+1,n))}function pw(r,e,t,n){const s=gr(r,e+1,n);if(typeof s=="bigint")throw new Error(`${J} 64-bit integer array lengths not supported`);return on(r,e,9,s)}function yw(r,e,t,n){if(n.allowIndefinite===!1)throw new Error(`${J} indefinite length items not allowed`);return on(r,e,1,1/0)}function Ta(r,e){et(r,S.array.majorEncoded,e.value)}Ta.compareTokens=mr.compareTokens;Ta.encodedSize=function(e){return et.encodedSize(e.value)};function an(r,e,t,n){return new q(S.map,n,t)}function ww(r,e,t,n){return an(r,e,1,t)}function bw(r,e,t,n){return an(r,e,2,dr(r,e+1,n))}function Ew(r,e,t,n){return an(r,e,3,fr(r,e+1,n))}function vw(r,e,t,n){return an(r,e,5,hr(r,e+1,n))}function xw(r,e,t,n){const s=gr(r,e+1,n);if(typeof s=="bigint")throw new Error(`${J} 64-bit integer map lengths not supported`);return an(r,e,9,s)}function Sw(r,e,t,n){if(n.allowIndefinite===!1)throw new Error(`${J} indefinite length items not allowed`);return an(r,e,1,1/0)}function Da(r,e){et(r,S.map.majorEncoded,e.value)}Da.compareTokens=mr.compareTokens;Da.encodedSize=function(e){return et.encodedSize(e.value)};function _w(r,e,t,n){return new q(S.tag,t,1)}function Aw(r,e,t,n){return new q(S.tag,dr(r,e+1,n),2)}function Iw(r,e,t,n){return new q(S.tag,fr(r,e+1,n),3)}function Cw(r,e,t,n){return new q(S.tag,hr(r,e+1,n),5)}function Lw(r,e,t,n){return new q(S.tag,gr(r,e+1,n),9)}function ka(r,e){et(r,S.tag.majorEncoded,e.value)}ka.compareTokens=mr.compareTokens;ka.encodedSize=function(e){return et.encodedSize(e.value)};const Ld=20,Td=21,Dd=22,kd=23;function Tw(r,e,t,n){if(n.allowUndefined===!1)throw new Error(`${J} undefined values are not supported`);return n.coerceUndefinedToNull===!0?new q(S.null,null,1):new q(S.undefined,void 0,1)}function Dw(r,e,t,n){if(n.allowIndefinite===!1)throw new Error(`${J} indefinite length items not allowed`);return new q(S.break,void 0,1)}function Pa(r,e,t){if(t){if(t.allowNaN===!1&&Number.isNaN(r))throw new Error(`${J} NaN values are not supported`);if(t.allowInfinity===!1&&(r===1/0||r===-1/0))throw new Error(`${J} Infinity values are not supported`)}return new q(S.float,r,e)}function kw(r,e,t,n){return Pa(Na(r,e+1),3,n)}function Pw(r,e,t,n){return Pa(Ra(r,e+1),5,n)}function Mw(r,e,t,n){return Pa(Rd(r,e+1),9,n)}function Ma(r,e,t){const n=e.value;if(n===!1)r.push([S.float.majorEncoded|Ld]);else if(n===!0)r.push([S.float.majorEncoded|Td]);else if(n===null)r.push([S.float.majorEncoded|Dd]);else if(n===void 0)r.push([S.float.majorEncoded|kd]);else{let s,i=!1;(!t||t.float64!==!0)&&(Md(n),s=Na(rt,1),n===s||Number.isNaN(n)?(rt[0]=249,r.push(rt.slice(0,3)),i=!0):(Nd(n),s=Ra(rt,1),n===s&&(rt[0]=250,r.push(rt.slice(0,5)),i=!0))),i||(Nw(n),s=Rd(rt,1),rt[0]=251,r.push(rt.slice(0,9)))}}Ma.encodedSize=function(e,t){const n=e.value;if(n===!1||n===!0||n===null||n===void 0)return 1;if(!t||t.float64!==!0){Md(n);let s=Na(rt,1);if(n===s||Number.isNaN(n))return 3;if(Nd(n),s=Ra(rt,1),n===s)return 5}return 9};const Pd=new ArrayBuffer(9),Ze=new DataView(Pd,1),rt=new Uint8Array(Pd,0);function Md(r){if(r===1/0)Ze.setUint16(0,31744,!1);else if(r===-1/0)Ze.setUint16(0,64512,!1);else if(Number.isNaN(r))Ze.setUint16(0,32256,!1);else{Ze.setFloat32(0,r);const e=Ze.getUint32(0),t=(e&2139095040)>>23,n=e&8388607;if(t===255)Ze.setUint16(0,31744,!1);else if(t===0)Ze.setUint16(0,(r&2147483648)>>16|n>>13,!1);else{const s=t-127;s<-24?Ze.setUint16(0,0):s<-14?Ze.setUint16(0,(e&2147483648)>>16|1<<24+s,!1):Ze.setUint16(0,(e&2147483648)>>16|s+15<<10|n>>13,!1)}}}function Na(r,e){if(r.length-e<2)throw new Error(`${J} not enough data for float16`);const t=(r[e]<<8)+r[e+1];if(t===31744)return 1/0;if(t===64512)return-1/0;if(t===32256)return NaN;const n=t>>10&31,s=t&1023;let i;return n===0?i=s*2**-24:n!==31?i=(s+1024)*2**(n-25):i=s===0?1/0:NaN,t&32768?-i:i}function Nd(r){Ze.setFloat32(0,r,!1)}function Ra(r,e){if(r.length-e<4)throw new Error(`${J} not enough data for float32`);const t=(r.byteOffset||0)+e;return new DataView(r.buffer,t,4).getFloat32(0,!1)}function Nw(r){Ze.setFloat64(0,r,!1)}function Rd(r,e){if(r.length-e<8)throw new Error(`${J} not enough data for float64`);const t=(r.byteOffset||0)+e;return new DataView(r.buffer,t,8).getFloat64(0,!1)}Ma.compareTokens=mr.compareTokens;function ne(r,e,t){throw new Error(`${J} encountered invalid minor (${t}) for major ${r[e]>>>5}`)}function _i(r){return()=>{throw new Error(`${J} ${r}`)}}const D=[];for(let r=0;r<=23;r++)D[r]=ne;D[24]=Vy;D[25]=Hy;D[26]=Wy;D[27]=Gy;D[28]=ne;D[29]=ne;D[30]=ne;D[31]=ne;for(let r=32;r<=55;r++)D[r]=ne;D[56]=Zy;D[57]=jy;D[58]=Yy;D[59]=Xy;D[60]=ne;D[61]=ne;D[62]=ne;D[63]=ne;for(let r=64;r<=87;r++)D[r]=Qy;D[88]=Jy;D[89]=ew;D[90]=tw;D[91]=rw;D[92]=ne;D[93]=ne;D[94]=ne;D[95]=_i("indefinite length bytes/strings are not supported");for(let r=96;r<=119;r++)D[r]=ow;D[120]=aw;D[121]=cw;D[122]=uw;D[123]=lw;D[124]=ne;D[125]=ne;D[126]=ne;D[127]=_i("indefinite length bytes/strings are not supported");for(let r=128;r<=151;r++)D[r]=fw;D[152]=hw;D[153]=gw;D[154]=mw;D[155]=pw;D[156]=ne;D[157]=ne;D[158]=ne;D[159]=yw;for(let r=160;r<=183;r++)D[r]=ww;D[184]=bw;D[185]=Ew;D[186]=vw;D[187]=xw;D[188]=ne;D[189]=ne;D[190]=ne;D[191]=Sw;for(let r=192;r<=215;r++)D[r]=_w;D[216]=Aw;D[217]=Iw;D[218]=Cw;D[219]=Lw;D[220]=ne;D[221]=ne;D[222]=ne;D[223]=ne;for(let r=224;r<=243;r++)D[r]=_i("simple values are not supported");D[244]=ne;D[245]=ne;D[246]=ne;D[247]=Tw;D[248]=_i("simple values are not supported");D[249]=kw;D[250]=Pw;D[251]=Mw;D[252]=ne;D[253]=ne;D[254]=ne;D[255]=Dw;const pt=[];for(let r=0;r<24;r++)pt[r]=new q(S.uint,r,1);for(let r=-1;r>=-24;r--)pt[31-r]=new q(S.negint,r,1);pt[64]=new q(S.bytes,new Uint8Array(0),1);pt[96]=new q(S.string,"",1);pt[128]=new q(S.array,0,1);pt[160]=new q(S.map,0,1);pt[244]=new q(S.false,!1,1);pt[245]=new q(S.true,!0,1);pt[246]=new q(S.null,null,1);function Rw(){const r=[];return r[S.uint.major]=mr,r[S.negint.major]=La,r[S.bytes.major]=Si,r[S.string.major]=dw,r[S.array.major]=Ta,r[S.map.major]=Da,r[S.tag.major]=ka,r[S.float.major]=Ma,r}Rw();class js{constructor(e,t){this.obj=e,this.parent=t}includes(e){let t=this;do if(t.obj===e)return!0;while(t=t.parent);return!1}static createCheck(e,t){if(e&&e.includes(t))throw new Error(`${Id} object contains circular references`);return new js(t,e)}}const Bt={null:new q(S.null,null),undefined:new q(S.undefined,void 0),true:new q(S.true,!0),false:new q(S.false,!1),emptyArray:new q(S.array,0),emptyMap:new q(S.map,0)},Kt={number(r,e,t,n){return!Number.isInteger(r)||!Number.isSafeInteger(r)?new q(S.float,r):r>=0?new q(S.uint,r):new q(S.negint,r)},bigint(r,e,t,n){return r>=BigInt(0)?new q(S.uint,r):new q(S.negint,r)},Uint8Array(r,e,t,n){return new q(S.bytes,r)},string(r,e,t,n){return new q(S.string,r)},boolean(r,e,t,n){return r?Bt.true:Bt.false},null(r,e,t,n){return Bt.null},undefined(r,e,t,n){return Bt.undefined},ArrayBuffer(r,e,t,n){return new q(S.bytes,new Uint8Array(r))},DataView(r,e,t,n){return new q(S.bytes,new Uint8Array(r.buffer,r.byteOffset,r.byteLength))},Array(r,e,t,n){if(!r.length)return t.addBreakTokens===!0?[Bt.emptyArray,new q(S.break)]:Bt.emptyArray;n=js.createCheck(n,r);const s=[];let i=0;for(const o of r)s[i++]=qi(o,t,n);return t.addBreakTokens?[new q(S.array,r.length),s,new q(S.break)]:[new q(S.array,r.length),s]},Object(r,e,t,n){const s=e!=="Object",i=s?r.keys():Object.keys(r),o=s?r.size:i.length;let a;if(o){a=new Array(o),n=js.createCheck(n,r);const c=!s&&t.ignoreUndefinedProperties;let l=0;for(const d of i){const f=s?r.get(d):r[d];c&&f===void 0||(a[l++]=[qi(d,t,n),qi(f,t,n)])}l<o&&(a.length=l)}return a!=null&&a.length?(Bw(a,t),t.addBreakTokens?[new q(S.map,a.length),a,new q(S.break)]:[new q(S.map,a.length),a]):t.addBreakTokens===!0?[Bt.emptyMap,new q(S.break)]:Bt.emptyMap}};Kt.Map=Kt.Object;Kt.Buffer=Kt.Uint8Array;for(const r of"Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" "))Kt[`${r}Array`]=Kt.DataView;function qi(r,e={},t){const n=By(r),s=e&&e.typeEncoders&&e.typeEncoders[n]||Kt[n];if(typeof s=="function"){const o=s(r,n,e,t);if(o!=null)return o}const i=Kt[n];if(!i)throw new Error(`${Id} unsupported type: ${n}`);return i(r,n,e,t)}function Bw(r,e){e.mapSorter&&r.sort(e.mapSorter)}S.uint.majorEncoded;S.negint.majorEncoded;S.bytes.majorEncoded;S.string.majorEncoded;S.array.majorEncoded;S.float.majorEncoded|Ld;S.float.majorEncoded|Td;S.float.majorEncoded|Dd;S.float.majorEncoded|kd;BigInt(-1);BigInt(1);const Fw={strict:!1,allowIndefinite:!0,allowUndefined:!0,allowBigInt:!0};class Ow{constructor(e,t={}){this._pos=0,this.data=e,this.options=t}pos(){return this._pos}done(){return this._pos>=this.data.length}next(){const e=this.data[this._pos];let t=pt[e];if(t===void 0){const n=D[e];if(!n)throw new Error(`${J} no decoder for major type ${e>>>5} (byte 0x${e.toString(16).padStart(2,"0")})`);const s=e&31;t=n(this.data,this._pos,s,this.options)}return this._pos+=t.encodedLength,t}}const Mn=Symbol.for("DONE"),Ai=Symbol.for("BREAK");function $w(r,e,t){const n=[];for(let s=0;s<r.value;s++){const i=Nn(e,t);if(i===Ai){if(r.value===1/0)break;throw new Error(`${J} got unexpected break to lengthed array`)}if(i===Mn)throw new Error(`${J} found array but not enough entries (got ${s}, expected ${r.value})`);n[s]=i}return n}function Uw(r,e,t){const n=t.useMaps===!0,s=t.rejectDuplicateMapKeys===!0,i=n?void 0:{},o=n?new Map:void 0;for(let a=0;a<r.value;a++){const c=Nn(e,t);if(c===Ai){if(r.value===1/0)break;throw new Error(`${J} got unexpected break to lengthed map`)}if(c===Mn)throw new Error(`${J} found map but not enough entries (got ${a} [no key], expected ${r.value})`);if(!n&&typeof c!="string")throw new Error(`${J} non-string keys not supported (got ${typeof c})`);if(s&&(n&&o.has(c)||!n&&Object.hasOwn(i,c)))throw new Error(`${J} found repeat map key "${c}"`);const l=Nn(e,t);if(l===Mn)throw new Error(`${J} found map but not enough entries (got ${a} [no value], expected ${r.value})`);n?o.set(c,l):i[c]=l}return n?o:i}function Nn(r,e){if(r.done())return Mn;const t=r.next();if(S.equals(t.type,S.break))return Ai;if(t.type.terminal)return t.value;if(S.equals(t.type,S.array))return $w(t,r,e);if(S.equals(t.type,S.map))return Uw(t,r,e);if(S.equals(t.type,S.tag)){if(e.tags&&typeof e.tags[t.value]=="function"){const n=Nn(r,e);return e.tags[t.value](n)}throw new Error(`${J} tag not supported (${t.value})`)}throw new Error("unsupported")}function zw(r,e){if(!(r instanceof Uint8Array))throw new Error(`${J} data to decode must be a Uint8Array`);e=Object.assign({},Fw,e);const t=$y(r),n=e.tokenizer||new Ow(t,e),s=Nn(n,e);if(s===Mn)throw new Error(`${J} did not find any content to decode`);if(s===Ai)throw new Error(`${J} got unexpected break`);return[s,r.subarray(n.pos())]}function mx(r,e){const[t,n]=zw(r,e);if(n.length>0)throw new Error(`${J} too many terminals, data makes no sense`);return t}function Xe(){const r={};return r.promise=new Promise((e,t)=>{r.resolve=e,r.reject=t}),r}var Bd={exports:{}};(function(r){var e=Object.prototype.hasOwnProperty,t="~";function n(){}Object.create&&(n.prototype=Object.create(null),new n().__proto__||(t=!1));function s(c,l,d){this.fn=c,this.context=l,this.once=d||!1}function i(c,l,d,f,h){if(typeof d!="function")throw new TypeError("The listener must be a function");var p=new s(d,f||c,h),g=t?t+l:l;return c._events[g]?c._events[g].fn?c._events[g]=[c._events[g],p]:c._events[g].push(p):(c._events[g]=p,c._eventsCount++),c}function o(c,l){--c._eventsCount===0?c._events=new n:delete c._events[l]}function a(){this._events=new n,this._eventsCount=0}a.prototype.eventNames=function(){var l=[],d,f;if(this._eventsCount===0)return l;for(f in d=this._events)e.call(d,f)&&l.push(t?f.slice(1):f);return Object.getOwnPropertySymbols?l.concat(Object.getOwnPropertySymbols(d)):l},a.prototype.listeners=function(l){var d=t?t+l:l,f=this._events[d];if(!f)return[];if(f.fn)return[f.fn];for(var h=0,p=f.length,g=new Array(p);h<p;h++)g[h]=f[h].fn;return g},a.prototype.listenerCount=function(l){var d=t?t+l:l,f=this._events[d];return f?f.fn?1:f.length:0},a.prototype.emit=function(l,d,f,h,p,g){var y=t?t+l:l;if(!this._events[y])return!1;var m=this._events[y],_=arguments.length,x,E;if(m.fn){switch(m.once&&this.removeListener(l,m.fn,void 0,!0),_){case 1:return m.fn.call(m.context),!0;case 2:return m.fn.call(m.context,d),!0;case 3:return m.fn.call(m.context,d,f),!0;case 4:return m.fn.call(m.context,d,f,h),!0;case 5:return m.fn.call(m.context,d,f,h,p),!0;case 6:return m.fn.call(m.context,d,f,h,p,g),!0}for(E=1,x=new Array(_-1);E<_;E++)x[E-1]=arguments[E];m.fn.apply(m.context,x)}else{var C=m.length,A;for(E=0;E<C;E++)switch(m[E].once&&this.removeListener(l,m[E].fn,void 0,!0),_){case 1:m[E].fn.call(m[E].context);break;case 2:m[E].fn.call(m[E].context,d);break;case 3:m[E].fn.call(m[E].context,d,f);break;case 4:m[E].fn.call(m[E].context,d,f,h);break;default:if(!x)for(A=1,x=new Array(_-1);A<_;A++)x[A-1]=arguments[A];m[E].fn.apply(m[E].context,x)}}return!0},a.prototype.on=function(l,d,f){return i(this,l,d,f,!1)},a.prototype.once=function(l,d,f){return i(this,l,d,f,!0)},a.prototype.removeListener=function(l,d,f,h){var p=t?t+l:l;if(!this._events[p])return this;if(!d)return o(this,p),this;var g=this._events[p];if(g.fn)g.fn===d&&(!h||g.once)&&(!f||g.context===f)&&o(this,p);else{for(var y=0,m=[],_=g.length;y<_;y++)(g[y].fn!==d||h&&!g[y].once||f&&g[y].context!==f)&&m.push(g[y]);m.length?this._events[p]=m.length===1?m[0]:m:o(this,p)}return this},a.prototype.removeAllListeners=function(l){var d;return l?(d=t?t+l:l,this._events[d]&&o(this,d)):(this._events=new n,this._eventsCount=0),this},a.prototype.off=a.prototype.removeListener,a.prototype.addListener=a.prototype.on,a.prefixed=t,a.EventEmitter=a,r.exports=a})(Bd);var qw=Bd.exports;const Kw=Fu(qw);class Ba extends Error{constructor(t,n){var s;super(t,n);u(this,"name","TimeoutError");(s=Error.captureStackTrace)==null||s.call(Error,this,Ba)}}const Fc=r=>r.reason??new DOMException("This operation was aborted.","AbortError");function Fd(r,e){const{milliseconds:t,fallback:n,message:s,customTimers:i={setTimeout,clearTimeout},signal:o}=e;let a,c;const d=new Promise((f,h)=>{if(typeof t!="number"||Math.sign(t)!==1)throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${t}\``);if(o!=null&&o.aborted){h(Fc(o));return}if(o&&(c=()=>{h(Fc(o))},o.addEventListener("abort",c,{once:!0})),r.then(f,h),t===Number.POSITIVE_INFINITY)return;const p=new Ba;a=i.setTimeout.call(void 0,()=>{if(n){try{f(n())}catch(g){h(g)}return}typeof r.cancel=="function"&&r.cancel(),s===!1?f():s instanceof Error?h(s):(p.message=s??`Promise timed out after ${t} milliseconds`,h(p))},t)}).finally(()=>{d.clear(),c&&o&&o.removeEventListener("abort",c)});return d.clear=()=>{i.clearTimeout.call(void 0,a),a=void 0},d}function Vw(r,e,t){let n=0,s=r.length;for(;s>0;){const i=Math.trunc(s/2);let o=n+i;t(r[o],e)<=0?(n=++o,s-=i+1):s=i}return n}var je,vu;let Hw=(vu=class{constructor(){se(this,je,[])}enqueue(e,t){const{priority:n=0,id:s}=t??{},i={priority:n,id:s,run:e};if(this.size===0||v(this,je)[this.size-1].priority>=n){v(this,je).push(i);return}const o=Vw(v(this,je),i,(a,c)=>c.priority-a.priority);v(this,je).splice(o,0,i)}setPriority(e,t){const n=v(this,je).findIndex(i=>i.id===e);if(n===-1)throw new ReferenceError(`No promise function with the id "${e}" exists in the queue.`);const[s]=v(this,je).splice(n,1);this.enqueue(s.run,{priority:t,id:e})}dequeue(){const e=v(this,je).shift();return e==null?void 0:e.run}filter(e){return v(this,je).filter(t=>t.priority===e.priority).map(t=>t.run)}get size(){return v(this,je).length}},je=new WeakMap,vu);var Br,st,it,$t,tr,Fr,ut,On,Or,lt,xt,Ye,Ue,Fe,be,$n,Ae,rr,St,ui,nr,P,vs,Od,$d,xs,Ud,zd,qd,Kd,Vd,Ss,_s,Mo,As,No,Ro,Is,Gt,Hd,vr,Wd,Bo;class Ww extends Kw{constructor(t){var n,s;super();se(this,P);se(this,Br);se(this,st);se(this,it,0);se(this,$t);se(this,tr,!1);se(this,Fr,!1);se(this,ut);se(this,On,0);se(this,Or,0);se(this,lt);se(this,xt);se(this,Ye);se(this,Ue,[]);se(this,Fe,0);se(this,be);se(this,$n);se(this,Ae,0);se(this,rr);se(this,St);se(this,ui,1n);se(this,nr,new Map);u(this,"timeout");if(t={carryoverIntervalCount:!1,intervalCap:Number.POSITIVE_INFINITY,interval:0,concurrency:Number.POSITIVE_INFINITY,autoStart:!0,queueClass:Hw,strict:!1,...t},!(typeof t.intervalCap=="number"&&t.intervalCap>=1))throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${((n=t.intervalCap)==null?void 0:n.toString())??""}\` (${typeof t.intervalCap})`);if(t.interval===void 0||!(Number.isFinite(t.interval)&&t.interval>=0))throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${((s=t.interval)==null?void 0:s.toString())??""}\` (${typeof t.interval})`);if(t.strict&&t.interval===0)throw new TypeError("The `strict` option requires a non-zero `interval`");if(t.strict&&t.intervalCap===Number.POSITIVE_INFINITY)throw new TypeError("The `strict` option requires a finite `intervalCap`");if(re(this,Br,t.carryoverIntervalCount??t.carryoverConcurrencyCount??!1),re(this,st,t.intervalCap===Number.POSITIVE_INFINITY||t.interval===0),re(this,$t,t.intervalCap),re(this,ut,t.interval),re(this,Ye,t.strict),re(this,be,new t.queueClass),re(this,$n,t.queueClass),this.concurrency=t.concurrency,t.timeout!==void 0&&!(Number.isFinite(t.timeout)&&t.timeout>0))throw new TypeError(`Expected \`timeout\` to be a positive finite number, got \`${t.timeout}\` (${typeof t.timeout})`);this.timeout=t.timeout,re(this,St,t.autoStart===!1),O(this,P,Hd).call(this)}get concurrency(){return v(this,rr)}set concurrency(t){if(!(typeof t=="number"&&t>=1))throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${t}\` (${typeof t})`);re(this,rr,t),O(this,P,Is).call(this)}setPriority(t,n){if(typeof n!="number"||!Number.isFinite(n))throw new TypeError(`Expected \`priority\` to be a finite number, got \`${n}\` (${typeof n})`);v(this,be).setPriority(t,n)}async add(t,n={}){return n={timeout:this.timeout,...n,id:n.id??(Ht(this,ui)._++).toString()},new Promise((s,i)=>{const o=Symbol(`task-${n.id}`);v(this,be).enqueue(async()=>{var c,l;Ht(this,Ae)._++,v(this,nr).set(o,{id:n.id,priority:n.priority??0,startTime:Date.now(),timeout:n.timeout});let a;try{try{(c=n.signal)==null||c.throwIfAborted()}catch(h){throw O(this,P,Wd).call(this),v(this,nr).delete(o),h}re(this,Or,Date.now());let d=t({signal:n.signal});if(n.timeout&&(d=Fd(Promise.resolve(d),{milliseconds:n.timeout,message:`Task timed out after ${n.timeout}ms (queue has ${v(this,Ae)} running, ${v(this,be).size} waiting)`})),n.signal){const{signal:h}=n;d=Promise.race([d,new Promise((p,g)=>{a=()=>{g(h.reason)},h.addEventListener("abort",a,{once:!0})})])}const f=await d;s(f),this.emit("completed",f)}catch(d){i(d),this.emit("error",d)}finally{a&&((l=n.signal)==null||l.removeEventListener("abort",a)),v(this,nr).delete(o),queueMicrotask(()=>{O(this,P,qd).call(this)})}},n),this.emit("add"),O(this,P,As).call(this)})}async addAll(t,n){return Promise.all(t.map(async s=>this.add(s,n)))}start(){return v(this,St)?(re(this,St,!1),O(this,P,Is).call(this),this):this}pause(){re(this,St,!0)}clear(){re(this,be,new(v(this,$n))),O(this,P,_s).call(this),O(this,P,Bo).call(this),this.emit("empty"),v(this,Ae)===0&&(O(this,P,Mo).call(this),this.emit("idle")),this.emit("next")}async onEmpty(){v(this,be).size!==0&&await O(this,P,Gt).call(this,"empty")}async onSizeLessThan(t){v(this,be).size<t||await O(this,P,Gt).call(this,"next",()=>v(this,be).size<t)}async onIdle(){v(this,Ae)===0&&v(this,be).size===0||await O(this,P,Gt).call(this,"idle")}async onPendingZero(){v(this,Ae)!==0&&await O(this,P,Gt).call(this,"pendingZero")}async onRateLimit(){this.isRateLimited||await O(this,P,Gt).call(this,"rateLimit")}async onRateLimitCleared(){this.isRateLimited&&await O(this,P,Gt).call(this,"rateLimitCleared")}onError(){return new Promise((t,n)=>{const s=i=>{this.off("error",s),n(i)};this.on("error",s)})}get size(){return v(this,be).size}sizeBy(t){return v(this,be).filter(t).length}get pending(){return v(this,Ae)}get isPaused(){return v(this,St)}get isRateLimited(){return v(this,tr)}get isSaturated(){return v(this,Ae)===v(this,rr)&&v(this,be).size>0||this.isRateLimited&&v(this,be).size>0}get runningTasks(){return[...v(this,nr).values()].map(t=>({...t}))}}Br=new WeakMap,st=new WeakMap,it=new WeakMap,$t=new WeakMap,tr=new WeakMap,Fr=new WeakMap,ut=new WeakMap,On=new WeakMap,Or=new WeakMap,lt=new WeakMap,xt=new WeakMap,Ye=new WeakMap,Ue=new WeakMap,Fe=new WeakMap,be=new WeakMap,$n=new WeakMap,Ae=new WeakMap,rr=new WeakMap,St=new WeakMap,ui=new WeakMap,nr=new WeakMap,P=new WeakSet,vs=function(t){for(;v(this,Fe)<v(this,Ue).length;){const s=v(this,Ue)[v(this,Fe)];if(s!==void 0&&t-s>=v(this,ut))Ht(this,Fe)._++;else break}(v(this,Fe)>100&&v(this,Fe)>v(this,Ue).length/2||v(this,Fe)===v(this,Ue).length)&&(re(this,Ue,v(this,Ue).slice(v(this,Fe))),re(this,Fe,0))},Od=function(t){v(this,Ye)?v(this,Ue).push(t):Ht(this,it)._++},$d=function(){v(this,Ye)?v(this,Ue).length>v(this,Fe)&&v(this,Ue).pop():v(this,it)>0&&Ht(this,it)._--},xs=function(){return v(this,Ue).length-v(this,Fe)},Ud=function(){return v(this,st)?!0:v(this,Ye)?O(this,P,xs).call(this)<v(this,$t):v(this,it)<v(this,$t)},zd=function(){return v(this,Ae)<v(this,rr)},qd=function(){Ht(this,Ae)._--,v(this,Ae)===0&&this.emit("pendingZero"),O(this,P,As).call(this),this.emit("next")},Kd=function(){re(this,xt,void 0),O(this,P,Ro).call(this),O(this,P,No).call(this)},Vd=function(t){if(v(this,Ye)){if(O(this,P,vs).call(this,t),O(this,P,xs).call(this)>=v(this,$t)){const s=v(this,Ue)[v(this,Fe)],i=v(this,ut)-(t-s);return O(this,P,Ss).call(this,i),!0}return!1}if(v(this,lt)===void 0){const n=v(this,On)-t;if(n<0){if(v(this,Or)>0){const s=t-v(this,Or);if(s<v(this,ut))return O(this,P,Ss).call(this,v(this,ut)-s),!0}re(this,it,v(this,Br)?v(this,Ae):0)}else return O(this,P,Ss).call(this,n),!0}return!1},Ss=function(t){v(this,xt)===void 0&&re(this,xt,setTimeout(()=>{O(this,P,Kd).call(this)},t))},_s=function(){v(this,lt)&&(clearInterval(v(this,lt)),re(this,lt,void 0))},Mo=function(){v(this,xt)&&(clearTimeout(v(this,xt)),re(this,xt,void 0))},As=function(){if(v(this,be).size===0){if(O(this,P,_s).call(this),this.emit("empty"),v(this,Ae)===0){if(O(this,P,Mo).call(this),v(this,Ye)&&v(this,Fe)>0){const n=Date.now();O(this,P,vs).call(this,n)}this.emit("idle")}return!1}let t=!1;if(!v(this,St)){const n=Date.now(),s=!O(this,P,Vd).call(this,n);if(v(this,P,Ud)&&v(this,P,zd)){const i=v(this,be).dequeue();v(this,st)||(O(this,P,Od).call(this,n),O(this,P,vr).call(this)),this.emit("active"),i(),s&&O(this,P,No).call(this),t=!0}}return t},No=function(){v(this,st)||v(this,lt)!==void 0||v(this,Ye)||(re(this,lt,setInterval(()=>{O(this,P,Ro).call(this)},v(this,ut))),re(this,On,Date.now()+v(this,ut)))},Ro=function(){v(this,Ye)||(v(this,it)===0&&v(this,Ae)===0&&v(this,lt)&&O(this,P,_s).call(this),re(this,it,v(this,Br)?v(this,Ae):0)),O(this,P,Is).call(this),O(this,P,vr).call(this)},Is=function(){for(;O(this,P,As).call(this););},Gt=async function(t,n){return new Promise(s=>{const i=()=>{n&&!n()||(this.off(t,i),s())};this.on(t,i)})},Hd=function(){v(this,st)||(this.on("add",()=>{v(this,be).size>0&&O(this,P,vr).call(this)}),this.on("next",()=>{O(this,P,vr).call(this)}))},vr=function(){v(this,st)||v(this,Fr)||(re(this,Fr,!0),queueMicrotask(()=>{re(this,Fr,!1),O(this,P,Bo).call(this)}))},Wd=function(){v(this,st)||(O(this,P,$d).call(this),O(this,P,vr).call(this))},Bo=function(){const t=v(this,tr);if(v(this,st)||v(this,be).size===0){t&&(re(this,tr,!1),this.emit("rateLimitCleared"));return}let n;if(v(this,Ye)){const i=Date.now();O(this,P,vs).call(this,i),n=O(this,P,xs).call(this)}else n=v(this,it);const s=n>=v(this,$t);s!==t&&(re(this,tr,s),this.emit(s?"rateLimit":"rateLimitCleared"))};function Gw(r){const[e,t]=r[Symbol.asyncIterator]!=null?[r[Symbol.asyncIterator](),Symbol.asyncIterator]:[r[Symbol.iterator](),Symbol.iterator],n=[];return{peek:()=>e.next(),push:s=>{n.push(s)},next:()=>n.length>0?{done:!1,value:n.shift()}:e.next(),[t](){return this}}}async function Zw(r){var e,t;if(r.connectionProtector===null&&((t=(e=globalThis.process)==null?void 0:e.env)==null?void 0:t.LIBP2P_FORCE_PNET)!=null)throw new Z("Private network is enforced, but no protector was provided");return r}function xn(r,e){const t={[Symbol.iterator]:()=>t,next:()=>{const n=r.next(),s=n.value;return n.done===!0||s==null?{done:!0,value:void 0}:{done:!1,value:e(s)}}};return t}function Ki(r){const e=hi(Ce.decode(`z${r}`));return vi(e)}class jn{constructor(e){u(this,"map");if(this.map=new Map,e!=null)for(const[t,n]of e.entries())this.map.set(t.toString(),{key:t,value:n})}[Symbol.iterator](){return this.entries()}clear(){this.map.clear()}delete(e){return this.map.delete(e.toString())}entries(){return xn(this.map.entries(),e=>[e[1].key,e[1].value])}forEach(e){this.map.forEach((t,n)=>{e(t.value,t.key,this)})}get(e){var t;return(t=this.map.get(e.toString()))==null?void 0:t.value}has(e){return this.map.has(e.toString())}set(e,t){this.map.set(e.toString(),{key:e,value:t})}keys(){return xn(this.map.values(),e=>e.key)}values(){return xn(this.map.values(),e=>e.value)}get size(){return this.map.size}}class Mr{constructor(e){u(this,"set");if(this.set=new Set,e!=null)for(const t of e)this.set.add(t.toString())}get size(){return this.set.size}[Symbol.iterator](){return this.values()}add(e){this.set.add(e.toString())}clear(){this.set.clear()}delete(e){this.set.delete(e.toString())}entries(){return xn(this.set.entries(),e=>{const t=Ki(e[0]);return[t,t]})}forEach(e){this.set.forEach(t=>{const n=Ki(t);e(n,n,this)})}has(e){return this.set.has(e.toString())}values(){return xn(this.set.values(),e=>Ki(e))}intersection(e){const t=new Mr;for(const n of e)this.has(n)&&t.add(n);return t}difference(e){const t=new Mr;for(const n of this)e.has(n)||t.add(n);return t}union(e){const t=new Mr;for(const n of e)t.add(n);for(const n of this)t.add(n);return t}}const Fa={32:16777619n,64:1099511628211n,128:309485009821345068724781371n,256:374144419156711147060143317175368453031918731002211n,512:35835915874844867368919076489095108449946327955754392558399825615420669938882575126094039892345713852759n,1024:5016456510113118655434598811035278955030765345404790744303017523831112055108147451509157692220295382716162651878526895249385292291816524375083746691371804094271873160484737966720260389217684476157468082573n},Gd={32:2166136261n,64:14695981039346656037n,128:144066263297769815596495629667062367629n,256:100029257958052580907070968620625704837092796014241193945225284501741471925557n,512:9659303129496669498009435400716310466090418745672637896108374329434462657994582932197716438449813051892206539805784495328239340083876191928701583869517785n,1024:14197795064947621068722070641403218320880622795441933960878474914617582723252296732303717722150864096521202355549365628174669108571814760471015076148029755969804077320157692458563003215304957150157403644460363550505412711285966361610267868082893823963790439336411086884584107735010676915n},Zd=new globalThis.TextEncoder;function jw(r,e){const t=Fa[e];let n=Gd[e];for(let s=0;s<r.length;s++)n^=BigInt(r[s]),n=BigInt.asUintN(e,n*t);return n}function Yw(r,e,t){if(t.length===0)throw new Error("The `utf8Buffer` option must have a length greater than zero");const n=Fa[e];let s=Gd[e],i=r;for(;i.length>0;){const o=Zd.encodeInto(i,t);i=i.slice(o.read);for(let a=0;a<o.written;a++)s^=BigInt(t[a]),s=BigInt.asUintN(e,s*n)}return s}function Xw(r,{size:e=32,utf8Buffer:t}={}){if(!Fa[e])throw new Error("The `size` option must be one of 32, 64, 128, 256, 512, or 1024");if(typeof r=="string"){if(t)return Yw(r,e,t);r=Zd.encode(r)}return jw(r,e)}const Oa={hash:r=>Number(Xw(r,{size:32})),hashV:(r,e)=>Qw(Oa.hash(r,e))};function Qw(r){let e=r.toString(16);return e.length%2===1&&(e=`0${e}`),W(e,"base16")}const jd=64;class Xt{constructor(e,t,n,s=2){u(this,"fp");u(this,"h");u(this,"seed");if(s>jd)throw new TypeError("Invalid Fingerprint Size");const i=t.hashV(e,n),o=Ie(s);for(let a=0;a<o.length;a++)o[a]=i[a];o.length===0&&(o[0]=7),this.fp=o,this.h=t,this.seed=n}hash(){return this.h.hash(this.fp,this.seed)}equals(e){return(e==null?void 0:e.fp)instanceof Uint8Array?Se(this.fp,e.fp):!1}}function Ys(r,e){return Math.floor(Math.random()*(e-r))+r}class us{constructor(e){u(this,"contents");this.contents=new Array(e).fill(null)}has(e){if(!(e instanceof Xt))throw new TypeError("Invalid Fingerprint");return this.contents.some(t=>e.equals(t))}add(e){if(!(e instanceof Xt))throw new TypeError("Invalid Fingerprint");for(let t=0;t<this.contents.length;t++)if(this.contents[t]==null)return this.contents[t]=e,!0;return!0}swap(e){if(!(e instanceof Xt))throw new TypeError("Invalid Fingerprint");const t=Ys(0,this.contents.length-1),n=this.contents[t];return this.contents[t]=e,n}remove(e){if(!(e instanceof Xt))throw new TypeError("Invalid Fingerprint");const t=this.contents.findIndex(n=>e.equals(n));return t>-1?(this.contents[t]=null,!0):!1}}const Jw=500;class Oc{constructor(e){u(this,"bucketSize");u(this,"filterSize");u(this,"fingerprintSize");u(this,"buckets");u(this,"count");u(this,"hash");u(this,"seed");this.filterSize=e.filterSize,this.bucketSize=e.bucketSize??4,this.fingerprintSize=e.fingerprintSize??2,this.count=0,this.buckets=[],this.hash=e.hash??Oa,this.seed=e.seed??Ys(0,Math.pow(2,10))}add(e){typeof e=="string"&&(e=W(e));const t=new Xt(e,this.hash,this.seed,this.fingerprintSize),n=this.hash.hash(e,this.seed)%this.filterSize,s=(n^t.hash())%this.filterSize;if(this.buckets[n]==null&&(this.buckets[n]=new us(this.bucketSize)),this.buckets[s]==null&&(this.buckets[s]=new us(this.bucketSize)),this.buckets[n].add(t)||this.buckets[s].add(t))return this.count++,!0;const i=[n,s];let o=i[Ys(0,i.length-1)];this.buckets[o]==null&&(this.buckets[o]=new us(this.bucketSize));for(let a=0;a<Jw;a++){const c=this.buckets[o].swap(t);if(c!=null&&(o=(o^c.hash())%this.filterSize,this.buckets[o]==null&&(this.buckets[o]=new us(this.bucketSize)),this.buckets[o].add(c)))return this.count++,!0}return!1}has(e){var o,a;typeof e=="string"&&(e=W(e));const t=new Xt(e,this.hash,this.seed,this.fingerprintSize),n=this.hash.hash(e,this.seed)%this.filterSize,s=((o=this.buckets[n])==null?void 0:o.has(t))??!1;if(s)return s;const i=(n^t.hash())%this.filterSize;return((a=this.buckets[i])==null?void 0:a.has(t))??!1}remove(e){var a,c;typeof e=="string"&&(e=W(e));const t=new Xt(e,this.hash,this.seed,this.fingerprintSize),n=this.hash.hash(e,this.seed)%this.filterSize,s=((a=this.buckets[n])==null?void 0:a.remove(t))??!1;if(s)return this.count--,s;const i=(n^t.hash())%this.filterSize,o=((c=this.buckets[i])==null?void 0:c.remove(t))??!1;return o&&this.count--,o}get reliable(){return Math.floor(100*(this.count/this.filterSize))<=90}}const eb={1:.5,2:.84,4:.95,8:.98};function tb(r=.001){return r>.002?2:r>1e-5?4:8}function rb(r,e=.001){const t=tb(e),n=eb[t],s=Math.round(r/n),i=Math.min(Math.ceil(Math.log2(1/e)+Math.log2(2*t)),jd);return{filterSize:s,bucketSize:t,fingerprintSize:i}}class nb{constructor(e){u(this,"filterSize");u(this,"bucketSize");u(this,"fingerprintSize");u(this,"scale");u(this,"filterSeries");u(this,"hash");u(this,"seed");this.bucketSize=e.bucketSize??4,this.filterSize=e.filterSize??(1<<18)/this.bucketSize,this.fingerprintSize=e.fingerprintSize??2,this.scale=e.scale??2,this.hash=e.hash??Oa,this.seed=e.seed??Ys(0,Math.pow(2,10)),this.filterSeries=[new Oc({filterSize:this.filterSize,bucketSize:this.bucketSize,fingerprintSize:this.fingerprintSize,hash:this.hash,seed:this.seed})]}add(e){if(typeof e=="string"&&(e=W(e)),this.has(e))return!0;let t=this.filterSeries.find(n=>n.reliable);if(t==null){const n=this.filterSize*Math.pow(this.scale,this.filterSeries.length);t=new Oc({filterSize:n,bucketSize:this.bucketSize,fingerprintSize:this.fingerprintSize,hash:this.hash,seed:this.seed}),this.filterSeries.push(t)}return t.add(e)}has(e){typeof e=="string"&&(e=W(e));for(let t=0;t<this.filterSeries.length;t++)if(this.filterSeries[t].has(e))return!0;return!1}remove(e){typeof e=="string"&&(e=W(e));for(let t=0;t<this.filterSeries.length;t++)if(this.filterSeries[t].remove(e))return!0;return!1}get count(){return this.filterSeries.reduce((e,t)=>e+t.count,0)}}function $a(r,e=.001,t){return new nb({...rb(r,e)})}function le(r){var s,i,o,a,c,l;const e=r.getComponents(),t={};let n=0;if(((s=e[n])==null?void 0:s.name)==="ip6zone"&&(t.zone=`${e[n].value}`,n++),e[n].name==="ip4"||e[n].name==="ip6"||e[n].name==="dns"||e[n].name==="dns4"||e[n].name==="dns6"?(t.type=e[n].name,t.host=e[n].value,n++):e[n].name==="dnsaddr"&&(t.type=e[n].name,t.host=`_dnsaddr.${e[n].value}`,n++),(((i=e[n])==null?void 0:i.name)==="tcp"||((o=e[n])==null?void 0:o.name)==="udp")&&(t.protocol=e[n].name==="tcp"?"tcp":"udp",t.port=parseInt(`${e[n].value}`),n++),((a=e[n])==null?void 0:a.name)==="ipcidr"&&(t.type==="ip4"?t.cidr=parseInt(`${e[n].value}`):t.type==="ip6"&&(t.cidr=`${e[n].value}`),n++),t.type==null||t.host==null)throw new Z(`Multiaddr ${r} was not an IPv4, IPv6, DNS, DNS4, DNS6 or DNSADDR address`);return((c=e[n])==null?void 0:c.name)==="tls"&&((l=e[n+1])==null?void 0:l.name)==="sni"&&(t.sni=e[n+1].value,n+=2),t}function sb(r,e,t){let n=0;for(const s of r)if(!(n<e)){if(n>t)break;if(s!==255)return!1;n++}return!0}function ib(r,e,t,n){let s=0;for(const i of r)if(!(s<t)){if(s>n)break;if(i!==e[s])return!1;s++}return!0}function ob(r){switch(r.length){case Rn:return r.join(".");case Bn:{const e=[];for(let t=0;t<r.length;t++)t%2===0&&e.push(r[t].toString(16).padStart(2,"0")+r[t+1].toString(16).padStart(2,"0"));return e.join(":")}default:throw new Error("Invalid ip length")}}function ab(r){let e=0;for(let[t,n]of r.entries()){if(n===255){e+=8;continue}for(;n&128;)e++,n=n<<1;if(n&128)return-1;for(let s=t+1;s<r.length;s++)if(r[s]!=0)return-1;break}return e}function cb(r){let e="0x";for(const t of r)e+=(t>>4).toString(16)+(t&15).toString(16);return e}const Rn=4,Bn=16,ub=new Uint8Array([0,0,0,0,0,0,0,0,0,0,255,255]);function Yd(r,e){e.length===Bn&&r.length===Rn&&sb(e,0,11)&&(e=e.slice(12)),e.length===Rn&&r.length===Bn&&ib(r,ub,0,11)&&(r=r.slice(12));const t=r.length;if(t!=e.length)throw new Error("Failed to mask ip");const n=new Uint8Array(t);for(let s=0;s<t;s++)n[s]=r[s]&e[s];return n}function lb(r,e){if(typeof e=="string"&&(e=To(e)),e==null)throw new Error("Invalid ip");if(e.length!==r.network.length)return!1;for(let t=0;t<e.length;t++)if((r.network[t]&r.mask[t])!==(e[t]&r.mask[t]))return!1;return!0}function db(r){const[e,t]=r.split("/");if(!e||!t)throw new Error("Failed to parse given CIDR: "+r);let n=Rn,s=sd(e);if(s==null&&(n=Bn,s=id(e),s==null))throw new Error("Failed to parse given CIDR: "+r);const i=parseInt(t,10);if(Number.isNaN(i)||String(i).length!==t.length||i<0||i>n*8)throw new Error("Failed to parse given CIDR: "+r);const o=Xd(i,8*n);return{network:Yd(s,o),mask:o}}function Xd(r,e){if(e!==8*Rn&&e!==8*Bn)throw new Error("Invalid CIDR mask");if(r<0||r>e)throw new Error("Invalid CIDR mask");const t=e/8,n=new Uint8Array(t);for(let s=0;s<t;s++){if(r>=8){n[s]=255,r-=8;continue}n[s]=255-(255>>r),r=0}return n}class Qd{constructor(e,t){if(t==null)({network:this.network,mask:this.mask}=db(e));else{const n=To(e);if(n==null)throw new Error("Failed to parse network");t=String(t);const s=parseInt(t,10);if(Number.isNaN(s)||String(s).length!==t.length||s<0||s>n.length*8){const i=To(t);if(i==null)throw new Error("Failed to parse mask");this.mask=i}else this.mask=Xd(s,8*n.length);this.network=Yd(n,this.mask)}}contains(e){return lb({network:this.network,mask:this.mask},e)}toString(){const e=ab(this.mask),t=e!==-1?String(e):cb(this.mask);return ob(this.network)+"/"+t}}function fb(r,e){return new Qd(r).contains(e)}function yx(r){try{const e=le(r);switch(e.type){case"ip6":return fb("2000::/3",e.host);default:return!1}}catch{return!1}}function hb(r){try{const e=le(r);switch(e.type){case"ip4":return e.host.startsWith("169.254.");case"ip6":return e.host.toLowerCase().startsWith("fe80");default:return!1}}catch{return!1}}function gb(r){return/^127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(r)||/^::1$/.test(r)}function Fo(r){try{const e=le(r);switch(e.type){case"ip4":case"ip6":return gb(e.host);default:return!1}}catch{return!1}}function ot(r){try{return le(r),!0}catch{return!1}}var Jd;(function(){var r,e,t,n,s,i,o,a;a=function(c){var l,d,f,h;return l=(c&255<<24)>>>24,d=(c&255<<16)>>>16,f=(c&65280)>>>8,h=c&255,[l,d,f,h].join(".")},o=function(c){var l,d,f,h,p,g;for(l=[],f=h=0;h<=3&&c.length!==0;f=++h){if(f>0){if(c[0]!==".")throw new Error("Invalid IP");c=c.substring(1)}g=e(c),p=g[0],d=g[1],c=c.substring(d),l.push(p)}if(c.length!==0)throw new Error("Invalid IP");switch(l.length){case 1:if(l[0]>4294967295)throw new Error("Invalid IP");return l[0]>>>0;case 2:if(l[0]>255||l[1]>16777215)throw new Error("Invalid IP");return(l[0]<<24|l[1])>>>0;case 3:if(l[0]>255||l[1]>255||l[2]>65535)throw new Error("Invalid IP");return(l[0]<<24|l[1]<<16|l[2])>>>0;case 4:if(l[0]>255||l[1]>255||l[2]>255||l[3]>255)throw new Error("Invalid IP");return(l[0]<<24|l[1]<<16|l[2]<<8|l[3])>>>0;default:throw new Error("Invalid IP")}},t=function(c){return c.charCodeAt(0)},n=t("0"),i=t("a"),s=t("A"),e=function(c){var l,d,f,h,p;for(h=0,l=10,d="9",f=0,c.length>1&&c[f]==="0"&&(c[f+1]==="x"||c[f+1]==="X"?(f+=2,l=16):"0"<=c[f+1]&&c[f+1]<="9"&&(f++,l=8,d="7")),p=f;f<c.length;){if("0"<=c[f]&&c[f]<=d)h=h*l+(t(c[f])-n)>>>0;else if(l===16)if("a"<=c[f]&&c[f]<="f")h=h*l+(10+t(c[f])-i)>>>0;else if("A"<=c[f]&&c[f]<="F")h=h*l+(10+t(c[f])-s)>>>0;else break;else break;if(h>4294967295)throw new Error("too large");f++}if(f===p)throw new Error("empty octet");return[h,f]},r=function(){function c(l,d){var f,h,p;if(typeof l!="string")throw new Error("Missing `net' parameter");if(d||(p=l.split("/",2),l=p[0],d=p[1]),d||(d=32),typeof d=="string"&&d.indexOf(".")>-1){try{this.maskLong=o(d)}catch{throw new Error("Invalid mask: "+d)}for(f=h=32;h>=0;f=--h)if(this.maskLong===4294967295<<32-f>>>0){this.bitmask=f;break}}else if(d||d===0)this.bitmask=parseInt(d,10),this.maskLong=0,this.bitmask>0&&(this.maskLong=4294967295<<32-this.bitmask>>>0);else throw new Error("Invalid mask: empty");try{this.netLong=(o(l)&this.maskLong)>>>0}catch{throw new Error("Invalid net address: "+l)}if(!(this.bitmask<=32))throw new Error("Invalid mask for ip4: "+d);this.size=Math.pow(2,32-this.bitmask),this.base=a(this.netLong),this.mask=a(this.maskLong),this.hostmask=a(~this.maskLong),this.first=this.bitmask<=30?a(this.netLong+1):this.base,this.last=this.bitmask<=30?a(this.netLong+this.size-2):a(this.netLong+this.size-1),this.broadcast=this.bitmask<=30?a(this.netLong+this.size-1):void 0}return c.prototype.contains=function(l){return typeof l=="string"&&(l.indexOf("/")>0||l.split(".").length!==4)&&(l=new c(l)),l instanceof c?this.contains(l.base)&&this.contains(l.broadcast||l.last):(o(l)&this.maskLong)>>>0===(this.netLong&this.maskLong)>>>0},c.prototype.next=function(l){return l==null&&(l=1),new c(a(this.netLong+this.size*l),this.mask)},c.prototype.forEach=function(l){var d,f,h;for(h=o(this.first),f=o(this.last),d=0;h<=f;)l(a(h),h,d),d++,h++},c.prototype.toString=function(){return this.base+"/"+this.bitmask},c}(),Jd=r}).call(uh);const mb=["0.0.0.0/8","10.0.0.0/8","100.64.0.0/10","127.0.0.0/8","169.254.0.0/16","172.16.0.0/12","192.0.0.0/24","192.0.0.0/29","192.0.0.8/32","192.0.0.9/32","192.0.0.10/32","192.0.0.170/32","192.0.0.171/32","192.0.2.0/24","192.31.196.0/24","192.52.193.0/24","192.88.99.0/24","192.168.0.0/16","192.175.48.0/24","198.18.0.0/15","198.51.100.0/24","203.0.113.0/24","240.0.0.0/4","255.255.255.255/32"],pb=mb.map(r=>new Jd(r));function Ua(r){for(const e of pb)if(e.contains(r))return!0;return!1}function yb(r){return/^::ffff:([0-9a-fA-F]{1,4}):([0-9a-fA-F]{1,4})$/.test(r)}function wb(r){const e=r.split(":");if(e.length<2)return!1;const t=e[e.length-1].padStart(4,"0"),n=e[e.length-2].padStart(4,"0"),s=`${parseInt(n.substring(0,2),16)}.${parseInt(n.substring(2),16)}.${parseInt(t.substring(0,2),16)}.${parseInt(t.substring(2),16)}`;return Ua(s)}function bb(r){return/^::ffff:([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(r)}function Eb(r){const e=r.split(":"),t=e[e.length-1];return Ua(t)}function vb(r){return/^::$/.test(r)||/^::1$/.test(r)||/^64:ff9b::([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(r)||/^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^f[c-d]([0-9a-fA-F]{2,2}):/i.test(r)||/^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(r)||/^ff([0-9a-fA-F]{2,2}):/i.test(r)}function za(r){if(Wr(r))return Ua(r);if(yb(r))return wb(r);if(bb(r))return Eb(r);if(od(r))return vb(r)}function Fn(r){try{const e=le(r);switch(e.type){case"ip4":case"ip6":return za(e.host)??!1;default:return e.host==="localhost"}}catch{return!1}}class $c{constructor(e){u(this,"buffer");u(this,"mask");u(this,"top");u(this,"btm");u(this,"next");if(!(e>0)||e-1&e)throw new Error("Max size for a FixedFIFO should be a power of two");this.buffer=new Array(e),this.mask=e-1,this.top=0,this.btm=0,this.next=null}push(e){return this.buffer[this.top]!==void 0?!1:(this.buffer[this.top]=e,this.top=this.top+1&this.mask,!0)}shift(){const e=this.buffer[this.btm];if(e!==void 0)return this.buffer[this.btm]=void 0,this.btm=this.btm+1&this.mask,e}isEmpty(){return this.buffer[this.btm]===void 0}}class Vi{constructor(e={}){u(this,"size");u(this,"hwm");u(this,"head");u(this,"tail");this.hwm=e.splitLimit??16,this.head=new $c(this.hwm),this.tail=this.head,this.size=0}calculateSize(e){return(e==null?void 0:e.byteLength)!=null?e.byteLength:1}push(e){if((e==null?void 0:e.value)!=null&&(this.size+=this.calculateSize(e.value)),!this.head.push(e)){const t=this.head;this.head=t.next=new $c(2*this.head.buffer.length),this.head.push(e)}}shift(){let e=this.tail.shift();if(e===void 0&&this.tail.next!=null){const t=this.tail.next;this.tail.next=null,this.tail=t,e=this.tail.shift()}return(e==null?void 0:e.value)!=null&&(this.size-=this.calculateSize(e.value)),e}isEmpty(){return this.head.isEmpty()}}let xb=class extends Error{constructor(t,n){super(t??"The operation was aborted");u(this,"type");u(this,"code");this.type="aborted",this.code=n??"ABORT_ERR"}};function Yn(r={}){return Sb(t=>{const n=t.shift();if(n==null)return{done:!0};if(n.error!=null)throw n.error;return{done:n.done===!0,value:n.value}},r)}function Sb(r,e){e=e??{};let t=e.onEnd,n=new Vi,s,i,o,a=Xe();const c=async()=>{try{return n.isEmpty()?o?{done:!0}:await new Promise((m,_)=>{i=x=>{i=null,n.push(x);try{m(r(n))}catch(E){_(E)}return s}}):r(n)}finally{n.isEmpty()&&queueMicrotask(()=>{a.resolve(),a=Xe()})}},l=m=>i!=null?i(m):(n.push(m),s),d=m=>(n=new Vi,i!=null?i({error:m}):(n.push({error:m}),s)),f=m=>{if(o)return s;if((e==null?void 0:e.objectMode)!==!0&&(m==null?void 0:m.byteLength)==null)throw new Error("objectMode was not true but tried to push non-Uint8Array value");return l({done:!1,value:m})},h=m=>o?s:(o=!0,m!=null?d(m):l({done:!0})),p=()=>(n=new Vi,h(),{done:!0}),g=m=>(h(m),{done:!0});if(s={[Symbol.asyncIterator](){return this},next:c,return:p,throw:g,push:f,end:h,get readableLength(){return n.size},onEmpty:async m=>{const _=m==null?void 0:m.signal;if(_==null||_.throwIfAborted(),n.isEmpty())return;let x,E;_!=null&&(x=new Promise((C,A)=>{E=()=>{A(new xb)},_.addEventListener("abort",E)}));try{await Promise.race([a.promise,x])}finally{E!=null&&_!=null&&(_==null||_.removeEventListener("abort",E))}}},t==null)return s;const y=s;return s={[Symbol.asyncIterator](){return this},next(){return y.next()},throw(m){return y.throw(m),t!=null&&(t(m),t=void 0),{done:!0}},return(){return y.return(),t!=null&&(t(),t=void 0),{done:!0}},push:f,end(m){return y.end(m),t!=null&&(t(m),t=void 0),s},get readableLength(){return y.readableLength},onEmpty:m=>y.onEmpty(m)},s}const _b=r=>{const e=r.addEventListener||r.on||r.addListener,t=r.removeEventListener||r.off||r.removeListener;if(!e||!t)throw new TypeError("Emitter is not compatible");return{addListener:e.bind(r),removeListener:t.bind(r)}};function Ab(r,e,t){let n;const s=new Promise((i,o)=>{var p;if(t={rejectionEvents:["error"],multiArgs:!1,rejectionMultiArgs:!1,resolveImmediately:!1,...t},!(t.count>=0&&(t.count===Number.POSITIVE_INFINITY||Number.isInteger(t.count))))throw new TypeError("The `count` option should be at least 0 or more");(p=t.signal)==null||p.throwIfAborted();const a=[e].flat(),c=[],{addListener:l,removeListener:d}=_b(r),f=async(...g)=>{const y=t.multiArgs?g:g[0];if(t.filter)try{if(!await t.filter(y))return}catch(m){n(),o(m);return}c.push(y),t.count===c.length&&(n(),i(c))},h=(...g)=>{n(),o(t.rejectionMultiArgs?g:g[0])};n=()=>{for(const g of a)d(g,f);for(const g of t.rejectionEvents)a.includes(g)||d(g,h)};for(const g of a)l(g,f);for(const g of t.rejectionEvents)a.includes(g)||l(g,h);t.signal&&t.signal.addEventListener("abort",()=>{h(t.signal.reason)},{once:!0}),t.resolveImmediately&&i(c)});if(s.cancel=n,typeof t.timeout=="number"){const i=Fd(s,{milliseconds:t.timeout});return i.cancel=()=>{n(),i.clear()},i}return s}function Qe(r,e,t){typeof t=="function"&&(t={filter:t}),t={...t,count:1,resolveImmediately:!1};const n=Ab(r,e,t),s=n.then(i=>i[0]);return s.cancel=n.cancel,s}function Xs(r,e){let t;const n=function(){const s=function(){t=void 0,r()};clearTimeout(t),t=setTimeout(s,e)};return n.start=()=>{},n.stop=()=>{clearTimeout(t)},n}class Ib extends Error{constructor(t="Rate limit exceeded",n){super(t);u(this,"remainingPoints");u(this,"msBeforeNext");u(this,"consumedPoints");u(this,"isFirstInDuration");this.name="RateLimitError",this.remainingPoints=n.remainingPoints,this.msBeforeNext=n.msBeforeNext,this.consumedPoints=n.consumedPoints,this.isFirstInDuration=n.isFirstInDuration}}var co;let Cb=(co=class extends Error{constructor(e="The queue was full"){super(e),this.name="QueueFullError"}},u(co,"name","QueueFullError"),co);var uo;let Qs=(uo=class extends Error{constructor(){super(...arguments);u(this,"name","UnexpectedEOFError")}},u(uo,"name","UnexpectedEOFError"),uo);class ef extends Error{constructor(){super(...arguments);u(this,"name","MaxEarlyStreamsError")}}u(ef,"name","MaxEarlyStreamsError");class tf extends Error{constructor(){super(...arguments);u(this,"name","StreamClosedError")}}u(tf,"name","StreamClosedError");function Lb(r){return r.reason}async function Tt(r,e,t){if(e==null)return r;const n=(t==null?void 0:t.translateError)??Lb;if(e.aborted)return r.catch(()=>{}),Promise.reject(n(e));let s;try{return await Promise.race([r,new Promise((i,o)=>{s=()=>{o(n(e))},e.addEventListener("abort",s)})])}finally{s!=null&&e.removeEventListener("abort",s)}}let Tb=class{constructor(e){u(this,"deferred");u(this,"signal");var t;this.signal=e,this.deferred=Xe(),this.onAbort=this.onAbort.bind(this),(t=this.signal)==null||t.addEventListener("abort",this.onAbort)}onAbort(){var e;this.deferred.reject(((e=this.signal)==null?void 0:e.reason)??new _n)}cleanup(){var e;(e=this.signal)==null||e.removeEventListener("abort",this.onAbort)}};function Db(){return`${parseInt(String(Math.random()*1e9),10).toString()}${Date.now()}`}let kb=class{constructor(e,t){u(this,"id");u(this,"fn");u(this,"options");u(this,"recipients");u(this,"status");u(this,"timeline");u(this,"controller");this.id=Db(),this.status="queued",this.fn=e,this.options=t,this.recipients=[],this.timeline={created:Date.now()},this.controller=new AbortController,this.controller.signal,this.onAbort=this.onAbort.bind(this)}abort(e){this.controller.abort(e)}onAbort(){this.recipients.reduce((t,n)=>{var s;return t&&((s=n.signal)==null?void 0:s.aborted)===!0},!0)&&(this.controller.abort(new _n),this.cleanup())}async join(e={}){var n;const t=new Tb(e.signal);return this.recipients.push(t),(n=e.signal)==null||n.addEventListener("abort",this.onAbort),t.deferred.promise}async run(){this.status="running",this.timeline.started=Date.now();try{this.controller.signal.throwIfAborted();const e=await Tt(this.fn({...this.options??{},signal:this.controller.signal}),this.controller.signal);this.recipients.forEach(t=>{t.deferred.resolve(e)}),this.status="complete"}catch(e){this.recipients.forEach(t=>{t.deferred.reject(e)}),this.status="errored"}finally{this.timeline.finished=Date.now(),this.cleanup()}}cleanup(){this.recipients.forEach(e=>{var t;e.cleanup(),(t=e.signal)==null||t.removeEventListener("abort",this.onAbort)})}},rf=class extends It{constructor(t={}){var n;super();u(this,"concurrency");u(this,"maxSize");u(this,"queue");u(this,"pending");u(this,"sort");u(this,"paused");this.concurrency=t.concurrency??Number.POSITIVE_INFINITY,this.maxSize=t.maxSize??Number.POSITIVE_INFINITY,this.pending=0,this.paused=!1,t.metricName!=null&&((n=t.metrics)==null||n.registerMetricGroup(t.metricName,{calculate:()=>({size:this.queue.length,running:this.pending,queued:this.queue.length-this.pending})})),this.sort=t.sort,this.queue=[],this.emitEmpty=Xs(this.emitEmpty.bind(this),1),this.emitIdle=Xs(this.emitIdle.bind(this),1)}emitEmpty(){this.size===0&&this.safeDispatchEvent("empty")}emitIdle(){this.running===0&&this.safeDispatchEvent("idle")}pause(){this.paused=!0}resume(){this.paused&&(this.paused=!1,this.tryToStartAnother())}tryToStartAnother(){if(this.paused)return!1;if(this.size===0)return this.emitEmpty(),this.running===0&&this.emitIdle(),!1;if(this.pending<this.concurrency){let t;for(const n of this.queue)if(n.status==="queued"){t=n;break}return t==null?!1:(this.safeDispatchEvent("active"),this.pending++,t.run().finally(()=>{for(let n=0;n<this.queue.length;n++)if(this.queue[n]===t){this.queue.splice(n,1);break}this.pending--,this.tryToStartAnother(),this.safeDispatchEvent("next")}),!0)}return!1}enqueue(t){this.queue.push(t),this.sort!=null&&this.queue.sort(this.sort)}async add(t,n){var i;if((i=n==null?void 0:n.signal)==null||i.throwIfAborted(),this.size===this.maxSize)throw new Cb;const s=new kb(t,n);return this.enqueue(s),this.safeDispatchEvent("add"),this.tryToStartAnother(),s.join(n).then(o=>(this.safeDispatchEvent("completed",{detail:o}),this.safeDispatchEvent("success",{detail:{job:s,result:o}}),o)).catch(o=>{if(s.status==="queued"){for(let a=0;a<this.queue.length;a++)if(this.queue[a]===s){this.queue.splice(a,1);break}}throw this.safeDispatchEvent("failure",{detail:{job:s,error:o}}),o})}clear(){this.queue.splice(0,this.queue.length)}abort(){this.queue.forEach(t=>{t.abort(new _n)}),this.clear()}async onEmpty(t){this.size!==0&&await Qe(this,"empty",t)}async onSizeLessThan(t,n){this.size<t||await Qe(this,"next",{...n,filter:()=>this.size<t})}async onIdle(t){this.pending===0&&this.size===0||await Qe(this,"idle",t)}get size(){return this.queue.length}get queued(){return this.queue.length-this.pending}get running(){return this.pending}async*toGenerator(t){var l,d,f;(l=t==null?void 0:t.signal)==null||l.throwIfAborted();const n=Yn({objectMode:!0}),s=h=>{h!=null?this.abort():this.clear(),n.end(h)},i=h=>{h.detail!=null&&n.push(h.detail)},o=h=>{s(h.detail.error)},a=()=>{s()},c=()=>{s(new _n("Queue aborted"))};this.addEventListener("completed",i),this.addEventListener("failure",o),this.addEventListener("idle",a),(d=t==null?void 0:t.signal)==null||d.addEventListener("abort",c);try{yield*n}finally{this.removeEventListener("completed",i),this.removeEventListener("failure",o),this.removeEventListener("idle",a),(f=t==null?void 0:t.signal)==null||f.removeEventListener("abort",c),s()}}};const Pb=Math.pow(2,20)*4;class nf extends It{constructor(t){super();u(this,"status");u(this,"timeline");u(this,"inactivityTimeout");u(this,"maxReadBufferLength");u(this,"maxWriteBufferLength");u(this,"log");u(this,"direction");u(this,"maxMessageSize");u(this,"readStatus");u(this,"writeStatus");u(this,"remoteReadStatus");u(this,"remoteWriteStatus");u(this,"writableNeedsDrain");u(this,"readBuffer");u(this,"writeBuffer");u(this,"sendingData");u(this,"onDrainPromise");this.status="open",this.log=t.log,this.direction=t.direction??"outbound",this.inactivityTimeout=t.inactivityTimeout??12e4,this.maxReadBufferLength=t.maxReadBufferLength??Pb,this.maxWriteBufferLength=t.maxWriteBufferLength,this.maxMessageSize=t.maxMessageSize,this.readBuffer=new ce,this.writeBuffer=new ce,this.readStatus="readable",this.remoteReadStatus="readable",this.writeStatus="writable",this.remoteWriteStatus="writable",this.sendingData=!1,this.writableNeedsDrain=!1,this.timeline={open:Date.now()},this.processSendQueue=this.processSendQueue.bind(this);const n=()=>{var i;this.writableNeedsDrain&&(this.log.trace("drain event received, continue sending data"),this.writableNeedsDrain=!1,this.processSendQueue()),(i=this.onDrainPromise)==null||i.resolve()};this.addEventListener("drain",n);const s=i=>{var o;(o=this.onDrainPromise)==null||o.reject(i.error??new tf)};this.addEventListener("close",s)}get readBufferLength(){return this.readBuffer.byteLength}get writeBufferLength(){return this.writeBuffer.byteLength}async onDrain(t){return this.writableNeedsDrain!==!0?Promise.resolve():(this.onDrainPromise==null&&(this.onDrainPromise=Promise.withResolvers()),Tt(this.onDrainPromise.promise,t==null?void 0:t.signal))}async*[Symbol.asyncIterator](){if(this.readStatus!=="readable"&&this.readStatus!=="paused")return;const t=Yn(),n=o=>{t.push(o.data)};this.addEventListener("message",n);const s=o=>{t.end(o.error)};this.addEventListener("close",s);const i=()=>{t.end()};this.addEventListener("remoteCloseWrite",i);try{yield*t}finally{this.removeEventListener("message",n),this.removeEventListener("close",s),this.removeEventListener("remoteCloseWrite",i)}}isReadable(){return this.status==="open"}send(t){if(this.writeStatus==="closed"||this.writeStatus==="closing")throw new Er(`Cannot write to a stream that is ${this.writeStatus}`);return this.log.trace("append %d bytes to write buffer",t.byteLength),this.writeBuffer.append(t),this.processSendQueue()}abort(t){if(!(this.status==="aborted"||this.status==="reset"||this.status==="closed")){this.log.error("abort with error - %e",t),this.status="aborted",this.readBuffer.byteLength>0&&this.readBuffer.consume(this.readBuffer.byteLength),this.writeBuffer.byteLength>0&&(this.writeBuffer.consume(this.writeBuffer.byteLength),this.safeDispatchEvent("idle")),this.writeStatus="closed",this.remoteWriteStatus="closed",this.readStatus="closed",this.remoteReadStatus="closed",this.timeline.close=Date.now();try{this.sendReset(t)}catch(n){this.log("failed to send reset to remote - %e",n)}this.dispatchEvent(new wh(t))}}pause(){if(this.readStatus==="closed"||this.readStatus==="closing")throw new Er("Cannot pause a stream that is closing/closed");this.readStatus!=="paused"&&(this.readStatus="paused",this.sendPause())}resume(){if(this.readStatus==="closed"||this.readStatus==="closing")throw new Er("Cannot resume a stream that is closing/closed");this.readStatus!=="readable"&&(this.readStatus="readable",this.dispatchReadBuffer(),this.sendResume())}push(t){if(this.readStatus==="closed"||this.readStatus==="closing")throw new Er(`Cannot push data onto a stream that is ${this.readStatus}`);if(t.byteLength!==0){if(this.readBuffer.append(t),this.readStatus==="paused"||this.listenerCount("message")===0){this.checkReadBufferLength();return}setTimeout(()=>{this.dispatchReadBuffer()},0)}}unshift(t){if(this.readStatus==="closed"||this.readStatus==="closing")throw new Er(`Cannot push data onto a stream that is ${this.readStatus}`);if(t.byteLength!==0){if(this.readBuffer.prepend(t),this.readStatus==="paused"||this.listenerCount("message")===0){this.checkReadBufferLength();return}setTimeout(()=>{this.dispatchReadBuffer()},0)}}onData(t){if(t.byteLength!==0){if(this.readStatus==="closing"||this.readStatus==="closed"){this.log("ignoring data - read status %s",this.readStatus);return}this.readBuffer.append(t),this.dispatchReadBuffer()}}addEventListener(...t){super.addEventListener.apply(this,t),t[0]==="message"&&this.readBuffer.byteLength>0&&queueMicrotask(()=>{this.dispatchReadBuffer()})}onRemoteReset(){this.log("remote reset"),this.status="reset",this.writeStatus="closed",this.remoteWriteStatus="closed",this.remoteReadStatus="closed",this.timeline.close=Date.now(),this.readBuffer.byteLength===0&&(this.readStatus="closed");const t=new $u;this.dispatchEvent(new bh(t))}onTransportClosed(t){this.log("transport closed"),this.readStatus==="readable"&&this.readBuffer.byteLength===0&&(this.log("close readable end after transport closed and read buffer is empty"),this.readStatus="closed"),this.remoteReadStatus!=="closed"&&(this.remoteReadStatus="closed"),this.remoteWriteStatus!=="closed"&&(this.remoteWriteStatus="closed"),this.writeStatus!=="closed"&&(this.writeStatus="closed"),t!=null?this.abort(t):(this.status==="open"||this.status==="closing")&&(this.timeline.close=Date.now(),this.status="closed",this.writeStatus="closed",this.remoteWriteStatus="closed",this.remoteReadStatus="closed",this.dispatchEvent(new li))}onRemoteCloseWrite(){this.remoteWriteStatus!=="closed"&&(this.log.trace("on remote close write"),this.remoteWriteStatus="closed",this.safeDispatchEvent("remoteCloseWrite"),this.writeStatus==="closed"&&this.onTransportClosed())}onRemoteCloseRead(){this.log.trace("on remote close read"),this.remoteReadStatus="closed",this.writeBuffer.byteLength>0&&(this.writeBuffer.consume(this.writeBuffer.byteLength),this.safeDispatchEvent("idle"))}processSendQueue(){if(this.writableNeedsDrain)return this.log.trace("not processing send queue as drain is required"),this.checkWriteBufferLength(),!1;if(this.writeBuffer.byteLength===0)return this.log.trace("not processing send queue as no bytes to send"),!0;if(this.sendingData)return this.log.trace("not processing send queue as already sending data"),!0;this.sendingData=!0,this.log.trace("processing send queue with %d queued bytes",this.writeBuffer.byteLength);try{let t=!0;const n=this.writeBuffer.byteLength;let s=0;for(;this.writeBuffer.byteLength>0;){const i=Math.min(this.maxMessageSize??this.writeBuffer.byteLength,this.writeBuffer.byteLength);if(i===0){t=!1;break}const o=this.writeBuffer.sublist(0,i),a=new ce(o);this.writeBuffer.consume(o.byteLength);const c=this.sendData(o);if(t=c.canSendMore,s+=c.sentBytes,c.sentBytes!==a.byteLength&&(a.consume(c.sentBytes),this.writeBuffer.prepend(a)),!t)break}return t||(this.log.trace("sent %d/%d bytes, pausing sending because underlying stream is full, %d bytes left in the write buffer",s,n,this.writeBuffer.byteLength),this.writableNeedsDrain=!0,this.checkWriteBufferLength()),this.writeBuffer.byteLength===0&&this.safeDispatchEvent("idle"),t}finally{this.sendingData=!1}}dispatchReadBuffer(){try{if(this.listenerCount("message")===0){this.log.trace("not dispatching pause buffer as there are no listeners for the message event");return}if(this.readBuffer.byteLength===0){this.log.trace("not dispatching pause buffer as there is no data to dispatch");return}if(this.readStatus==="paused"){this.log.trace("not dispatching pause buffer we are paused");return}if(this.readStatus==="closing"||this.readStatus==="closed"){this.log("dropping %d bytes because the readable end is %s",this.readBuffer.byteLength,this.readStatus),this.readBuffer.consume(this.readBuffer.byteLength);return}const t=this.readBuffer.sublist();this.readBuffer.consume(t.byteLength),this.dispatchEvent(new yh(t))}finally{this.readBuffer.byteLength===0&&this.remoteWriteStatus==="closed"&&(this.log("close readable end after dispatching read buffer and remote writable end is closed"),this.readStatus="closed"),this.checkReadBufferLength()}}checkReadBufferLength(){this.readBuffer.byteLength>this.maxReadBufferLength&&this.abort(new fo(`Read buffer length of ${this.readBuffer.byteLength} exceeded limit of ${this.maxReadBufferLength}, read status is ${this.readStatus}`))}checkWriteBufferLength(){this.maxWriteBufferLength!=null&&this.writeBuffer.byteLength>this.maxWriteBufferLength&&this.abort(new fo(`Write buffer length of ${this.writeBuffer.byteLength} exceeded limit of ${this.maxWriteBufferLength}, write status is ${this.writeStatus}`))}onMuxerNeedsDrain(){this.writableNeedsDrain=!0}onMuxerDrain(){this.safeDispatchEvent("drain")}}class _x extends nf{constructor(t){super(t);u(this,"remoteAddr");u(this,"metricPrefix");u(this,"metrics");this.metricPrefix=t.metricPrefix??"",this.metrics=t.metrics,this.remoteAddr=t.remoteAddr,this.addEventListener("close",n=>{var s,i,o,a,c;(s=this.metrics)==null||s.increment({[`${this.metricPrefix}end`]:!0}),n.error!=null?n.local?(i=this.metrics)==null||i.increment({[`${this.metricPrefix}abort`]:!0}):(o=this.metrics)==null||o.increment({[`${this.metricPrefix}reset`]:!0}):n.local?(a=this.metrics)==null||a.increment({[`${this.metricPrefix}_local_close`]:!0}):(c=this.metrics)==null||c.increment({[`${this.metricPrefix}_remote_close`]:!0})})}async close(t){this.status==="open"&&(this.status="closing",this.writeStatus="closing",this.remoteWriteStatus="closing",this.remoteReadStatus="closing",(this.sendingData||this.writeBuffer.byteLength>0)&&(this.log("waiting for write queue to become idle before closing writable end of stream, %d unsent bytes",this.writeBuffer.byteLength),await Qe(this,"idle",{...t,rejectionEvents:["close"]})),this.writableNeedsDrain&&(this.log("waiting for write queue to drain before closing writable end of stream, %d unsent bytes",this.writeBuffer.byteLength),await Qe(this,"drain",{...t,rejectionEvents:["close"]})),await this.sendClose(t),this.onTransportClosed())}}function Mb(r){return r==null?!1:typeof r.then=="function"&&typeof r.catch=="function"&&typeof r.finally=="function"}class Ax extends It{constructor(t,n){super();u(this,"streams");u(this,"protocol");u(this,"status");u(this,"log");u(this,"maConn");u(this,"streamOptions");u(this,"earlyStreams");u(this,"maxEarlyStreams");u(this,"metrics");this.maConn=t,this.protocol=n.protocol,this.streams=[],this.earlyStreams=[],this.status="open",this.log=t.log.newScope(n.name),this.streamOptions=n.streamOptions,this.maxEarlyStreams=n.maxEarlyStreams??10,this.metrics=n.metrics;const s=a=>{try{this.onData(a.data)}catch(c){this.abort(c),this.maConn.abort(c)}};this.maConn.addEventListener("message",s);const i=()=>{this.log("underlying stream drained, signal %d streams to continue writing",this.streams.length),this.streams.forEach(a=>{a.onMuxerDrain()})};this.maConn.addEventListener("drain",i);const o=()=>{this.log("underlying stream closed with status %s and %d streams",this.status,this.streams.length),this.onTransportClosed()};this.maConn.addEventListener("close",o)}send(t){const n=this.maConn.send(t);return n===!1&&(this.log("underlying stream saturated, signal %d streams to pause writing",this.streams.length),this.streams.forEach(s=>{s.onMuxerNeedsDrain()})),n}async close(t){this.status==="closed"||this.status==="closing"||(this.status="closing",await Tt(Promise.all([...this.streams].map(async n=>{await n.close(t)})),t==null?void 0:t.signal),this.status="closed")}abort(t){this.status!=="closed"&&(this.status="closing",[...this.streams].forEach(n=>{n.abort(t)}),this.status="closed")}onTransportClosed(t){this.status="closing";try{[...this.streams].forEach(n=>{n.onTransportClosed(t)})}catch(n){this.abort(n)}this.status="closed"}async createStream(t){if(this.status!=="open")throw new Ou;let n=this.onCreateStream({...this.streamOptions,...t});return Mb(n)&&(n=await n),this.streams.push(n),this.cleanUpStream(n),n}onRemoteStream(t){if(this.streams.push(t),this.cleanUpStream(t),this.listenerCount("stream")===0){this.earlyStreams.push(t),this.earlyStreams.length>this.maxEarlyStreams&&this.abort(new ef(`Too many early streams were opened - ${this.earlyStreams.length}/${this.maxEarlyStreams}`));return}this.safeDispatchEvent("stream",{detail:t})}cleanUpStream(t){var s;const n=i=>{var a,c,l;const o=this.streams.findIndex(d=>d===t);o!==-1&&this.streams.splice(o,1),i.error!=null?i.local?(a=this.metrics)==null||a.increment({[`${t.direction}_stream_reset`]:!0}):(c=this.metrics)==null||c.increment({[`${t.direction}_stream_abort`]:!0}):(l=this.metrics)==null||l.increment({[`${t.direction}_stream_end`]:!0})};t.addEventListener("close",n),(s=this.metrics)==null||s.increment({[`${t.direction}_stream`]:!0})}addEventListener(...t){super.addEventListener.apply(this,t),t[0]==="stream"&&this.earlyStreams.length>0&&queueMicrotask(()=>{this.earlyStreams.forEach(n=>{this.safeDispatchEvent("stream",{detail:n})}),this.earlyStreams=[]})}}class Ix extends nf{constructor(t){super(t);u(this,"id");u(this,"protocol");this.id=t.id,this.protocol=t.protocol??""}async close(t){this.writeStatus==="closing"||this.writeStatus==="closed"||(this.writeStatus="closing",(this.sendingData||this.writeBuffer.byteLength>0)&&(this.log("waiting for write queue to become idle before closing writable end of stream, %d unsent bytes",this.writeBuffer.byteLength),await Qe(this,"idle",{...t,rejectionEvents:["close"]})),this.writableNeedsDrain&&(this.log("waiting for write queue to drain before closing writable end of stream, %d unsent bytes, sending %s",this.writeBuffer.byteLength,this.sendingData),await Qe(this,"drain",{...t,rejectionEvents:["close"]}),this.log("write queue drained, closing writable end of stream, %d unsent bytes, sending %s",this.writeBuffer.byteLength,this.sendingData)),await this.sendCloseWrite(t),this.writeStatus="closed",this.log("closed writable end gracefully"),this.remoteWriteStatus==="closed"&&this.onTransportClosed())}async closeRead(t){this.readStatus==="closing"||this.readStatus==="closed"||(this.readBuffer.byteLength>0&&this.readBuffer.consume(this.readBuffer.byteLength),this.readStatus="closing",await this.sendCloseRead(t),this.readStatus="closed",this.log("closed readable end gracefully"))}}class Hi{constructor(e){u(this,"movingAverage");u(this,"variance");u(this,"deviation");u(this,"forecast");u(this,"timeSpan");u(this,"previousTime");this.timeSpan=e,this.movingAverage=0,this.variance=0,this.deviation=0,this.forecast=0}alpha(e,t){return 1-Math.exp(-(e-t)/this.timeSpan)}push(e,t=Date.now()){if(this.previousTime!=null){const n=this.alpha(t,this.previousTime),s=e-this.movingAverage,i=n*s;this.movingAverage=n*e+(1-n)*this.movingAverage,this.variance=(1-n)*(this.variance+s*i),this.deviation=Math.sqrt(this.variance),this.forecast=this.movingAverage+n*s}else this.movingAverage=e;this.previousTime=t}}const Nb=1.2,Rb=2,Bb=5e3,Fb=6e4,Ob=5e3;class $b{constructor(e={}){u(this,"success");u(this,"failure");u(this,"next");u(this,"metric");u(this,"timeoutMultiplier");u(this,"failureMultiplier");u(this,"minTimeout");u(this,"maxTimeout");var n;const t=e.interval??Ob;this.success=new Hi(t),this.failure=new Hi(t),this.next=new Hi(t),this.failureMultiplier=e.failureMultiplier??Rb,this.timeoutMultiplier=e.timeoutMultiplier??Nb,this.minTimeout=e.minTimeout??Bb,this.maxTimeout=e.maxTimeout??Fb,e.metricName!=null&&(this.metric=(n=e.metrics)==null?void 0:n.registerMetricGroup(e.metricName))}getTimeoutSignal(e={}){let t=Math.round(this.next.movingAverage*(e.timeoutFactor??this.timeoutMultiplier));t<this.minTimeout&&(t=this.minTimeout),t>this.maxTimeout&&(t=this.maxTimeout);const n=AbortSignal.timeout(t),s=Gr([e.signal,n]);return s.start=Date.now(),s.timeout=t,s}cleanUp(e){var n,s;const t=Date.now()-e.start;e.aborted?(this.failure.push(t),this.next.push(t*this.failureMultiplier),(n=this.metric)==null||n.update({failureMovingAverage:this.failure.movingAverage,failureDeviation:this.failure.deviation,failureForecast:this.failure.forecast,failureVariance:this.failure.variance,failure:t})):(this.success.push(t),this.next.push(t),(s=this.metric)==null||s.update({successMovingAverage:this.success.movingAverage,successDeviation:this.success.deviation,successForecast:this.success.forecast,successVariance:this.success.variance,success:t}))}}class Ub{constructor(){u(this,"readNext");u(this,"haveNext");u(this,"ended");u(this,"nextResult");u(this,"error");this.ended=!1,this.readNext=Xe(),this.haveNext=Xe()}[Symbol.asyncIterator](){return this}async next(){if(this.nextResult==null&&await this.haveNext.promise,this.nextResult==null)throw new Error("HaveNext promise resolved but nextResult was undefined");const e=this.nextResult;return this.nextResult=void 0,this.readNext.resolve(),this.readNext=Xe(),e}async throw(e){return this.ended=!0,this.error=e,e!=null&&(this.haveNext.promise.catch(()=>{}),this.haveNext.reject(e)),{done:!0,value:void 0}}async return(){const e={done:!0,value:void 0};return this.ended=!0,this.nextResult=e,this.haveNext.resolve(),e}async push(e,t){await this._push(e,t)}async end(e,t){e!=null?await this.throw(e):await this._push(void 0,t)}async _push(e,t){if(e!=null&&this.ended)throw this.error??new Error("Cannot push value onto an ended pushable");for(;this.nextResult!=null;)await this.readNext.promise;e!=null?this.nextResult={done:!1,value:e}:(this.ended=!0,this.nextResult={done:!0,value:void 0}),this.haveNext.resolve(),this.haveNext=Xe(),await Tt(this.readNext.promise,t==null?void 0:t.signal,t)}}function zb(){return new Ub}function qb(r){return r[Symbol.asyncIterator]!=null}async function Kb(r,e,t){try{await Promise.all(r.map(async n=>{for await(const s of n)await e.push(s,{signal:t}),t.throwIfAborted()})),await e.end(void 0,{signal:t})}catch(n){await e.end(n,{signal:t}).catch(()=>{})}}async function*Vb(r){const e=new AbortController,t=zb();Kb(r,t,e.signal).catch(()=>{});try{yield*t}finally{e.abort()}}function*Hb(r){for(const e of r)yield*e}function Js(...r){const e=[];for(const t of r)qb(t)||e.push(t);return e.length===r.length?Hb(e):Vb(r)}function Wb(r,...e){if(r==null)throw new Error("Empty pipeline");if(Wi(r)){const n=r;r=()=>n.source}else if(of(r)||sf(r)){const n=r;r=()=>n}const t=[r,...e];if(t.length>1&&Wi(t[t.length-1])&&(t[t.length-1]=t[t.length-1].sink),t.length>2)for(let n=1;n<t.length-1;n++)Wi(t[n])&&(t[n]=Zb(t[n]));return Gb(...t)}const Gb=(...r)=>{let e;for(;r.length>0;)e=r.shift()(e);return e},sf=r=>(r==null?void 0:r[Symbol.asyncIterator])!=null,of=r=>(r==null?void 0:r[Symbol.iterator])!=null,Wi=r=>r==null?!1:r.sink!=null&&r.source!=null,Zb=r=>e=>{const t=r.sink(e);if((t==null?void 0:t.then)!=null){const n=Yn({objectMode:!0});t.then(()=>{n.end()},o=>{n.end(o)});let s;const i=r.source;if(sf(i))s=async function*(){yield*i,n.end()};else if(of(i))s=function*(){yield*i,n.end()};else throw new Error("Unknown duplex source type - must be Iterable or AsyncIterable");return Js(n,s())}return r.source},jb=4194304;class Oo extends Error{constructor(){super(...arguments);u(this,"name","UnwrappedError")}}u(Oo,"name","UnwrappedError");let af=class extends Error{constructor(){super(...arguments);u(this,"name","InvalidMessageLengthError");u(this,"code","ERR_INVALID_MSG_LENGTH")}},Yb=class extends Error{constructor(){super(...arguments);u(this,"name","InvalidDataLengthError");u(this,"code","ERR_MSG_DATA_TOO_LONG")}},Xb=class extends Error{constructor(){super(...arguments);u(this,"name","InvalidDataLengthLengthError");u(this,"code","ERR_MSG_LENGTH_TOO_LONG")}};function Qb(r){return typeof(r==null?void 0:r.closeRead)=="function"}function Jb(r){return typeof(r==null?void 0:r.close)=="function"}function Gi(r){return Qb(r)?r.remoteWriteStatus!=="writable"&&r.readBufferLength===0:Jb(r)?r.status!=="open":!1}function eE(r){return(r==null?void 0:r.addEventListener)!=null&&(r==null?void 0:r.removeEventListener)!=null&&(r==null?void 0:r.send)!=null&&(r==null?void 0:r.push)!=null&&(r==null?void 0:r.log)!=null}function cf(r,e){const t=(e==null?void 0:e.maxBufferSize)??jb,n=new ce;let s,i=!1;if(!eE(r))throw new Z("Argument should be a Stream or a Multiaddr");const o=d=>{if(n.append(d.data),n.byteLength>t){const f=n.byteLength;n.consume(n.byteLength),s==null||s.reject(new Error(`Read buffer overflow - ${f} > ${t}`))}s==null||s.resolve()};r.addEventListener("message",o);const a=d=>{d.error!=null?s==null||s.reject(d.error):s==null||s.resolve()};r.addEventListener("close",a);const c=()=>{s==null||s.resolve()};r.addEventListener("remoteCloseWrite",c);const l={readBuffer:n,async read(d){if(i===!0)throw new Oo("Stream was unwrapped");if(Gi(r)){if((d==null?void 0:d.bytes)==null)return null;if(n.byteLength<d.bytes)throw r.log.error("closed after reading %d/%d bytes",n.byteLength,d.bytes),new Qs(`Unexpected EOF - stream closed after reading ${n.byteLength}/${d.bytes} bytes`)}const f=(d==null?void 0:d.bytes)??1;for(s=Promise.withResolvers();;){if(n.byteLength>=f){s.resolve();break}if(await Tt(s.promise,d==null?void 0:d.signal),Gi(r)){if(n.byteLength===0&&(d==null?void 0:d.bytes)==null)return null;break}s=Promise.withResolvers()}const h=(d==null?void 0:d.bytes)??n.byteLength;if(n.byteLength<h){if(Gi(r))throw r.log.error("closed while reading %d/%d bytes",n.byteLength,h),new Qs(`Unexpected EOF - stream closed while reading ${n.byteLength}/${h} bytes`);return l.read(d)}const p=n.sublist(0,h);return n.consume(h),p},async write(d,f){if(i===!0)throw new Oo("Stream was unwrapped");r.send(d)||await Qe(r,"drain",{signal:f==null?void 0:f.signal,rejectionEvents:["close"]})},unwrap(){return i||(i=!0,r.removeEventListener("message",o),r.removeEventListener("close",a),r.removeEventListener("remoteCloseWrite",c),n.byteLength>0&&(r.log("stream unwrapped with %d unread bytes",n.byteLength),r.push(n))),r}};return l}function qa(r,e={}){const t=cf(r,e);e.maxDataLength!=null&&e.maxLengthLength==null&&(e.maxLengthLength=Ge(e.maxDataLength));const n=(e==null?void 0:e.lengthDecoder)??Wn,s=(e==null?void 0:e.lengthEncoder)??En;return{async read(o){let a=-1;const c=new ce;for(;;){const d=await t.read({...o,bytes:1});if(d==null)break;c.append(d);try{a=n(c)}catch(f){if(f instanceof RangeError)continue;throw f}if(a<0)throw new af("Invalid message length");if((e==null?void 0:e.maxLengthLength)!=null&&c.byteLength>e.maxLengthLength)throw new Xb(`Message length length too long - ${c.byteLength} > ${e.maxLengthLength}`);if(a>-1)break}if((e==null?void 0:e.maxDataLength)!=null&&a>e.maxDataLength)throw new Yb(`Message length too long - ${a} > ${e.maxDataLength}`);const l=await t.read({...o,bytes:a});if(l==null)throw r.log.error("tried to read %d bytes but the stream closed",a),new Qs(`Unexpected EOF - tried to read ${a} bytes but the stream closed`);if(l.byteLength!==a)throw r.log.error("read %d/%d bytes before the stream closed",l.byteLength,a),new Qs(`Unexpected EOF - read ${l.byteLength}/${a} bytes before the stream closed`);return l},async write(o,a){await t.write(new ce(s(o.byteLength),o),a)},async writeV(o,a){const c=new ce(...o.flatMap(l=>[s(l.byteLength),l]));await t.write(c,a)},unwrap(){return t.unwrap()}}}function Dx(r,e){const t=qa(r,e),n={read:async(s,i)=>{const o=await t.read(i);return s.decode(o)},write:async(s,i,o)=>{await t.write(i.encode(s),o)},writeV:async(s,i,o)=>{await t.writeV(s.map(a=>i.encode(a)),o)},pb:s=>({read:async i=>n.read(s,i),write:async(i,o)=>n.write(i,s,o),writeV:async(i,o)=>n.writeV(i,s,o),unwrap:()=>n}),unwrap:()=>t.unwrap()};return n}function tE(r){return(r==null?void 0:r.addEventListener)!=null}function rE(r){const e=Yn();let t;const n=o=>{e.push(o.data)},s=()=>{e.end(),r.removeEventListener("message",n),r.removeEventListener("close",i),r.removeEventListener("remoteCloseWrite",s)},i=o=>{e.end(o.error),o.error!=null&&(t==null||t.reject(o.error)),r.removeEventListener("message",n),r.removeEventListener("close",i),r.removeEventListener("remoteCloseWrite",s)};return r.addEventListener("message",n),r.addEventListener("close",i,{once:!0}),r.addEventListener("remoteCloseWrite",s,{once:!0}),{source:e,async sink(o){async function*a(){yield*o}const c=a();for(;;){t=Promise.withResolvers();const{done:l,value:d}=await Promise.race([c.next(),t.promise]);if(r.writeStatus==="closing"||r.writeStatus==="closed"||(d!=null&&(r.send(d)||await Promise.race([Qe(r,"drain",{rejectionEvents:["close"]})])),l===!0))break}await r.close()}}}function kx(...r){const e=r.map(t=>tE(t)?rE(t):t);return Wb(...e)}const nE=1024*1024*4,sE=1024*1024*4;class Px{constructor(e={}){u(this,"buffer");u(this,"maxBufferSize");u(this,"lengthDecoder");u(this,"maxDataLength");u(this,"encodingLength");this.buffer=new ce,this.maxBufferSize=e.maxBufferSize??nE,this.maxDataLength=e.maxDataLength??sE,this.lengthDecoder=e.lengthDecoder??Wn,this.encodingLength=e.encodingLength??Ge}*decode(e){if(this.buffer.append(e),this.buffer.byteLength>this.maxBufferSize)throw new Z(`Buffer length limit exceeded - ${this.buffer.byteLength}/${this.maxBufferSize}`);for(;;){let t;try{t=this.lengthDecoder(this.buffer)}catch(i){if(i instanceof RangeError)break;throw i}if(t<0||t>this.maxDataLength)throw new af("Invalid message length");const n=this.encodingLength(t),s=n+t;if(this.buffer.byteLength>=s){const i=this.buffer.sublist(n,s);this.buffer.consume(s),i.byteLength>0&&(yield i)}else break}}}const iE=8,Ka=1024*1024*4;class oE extends Error{constructor(){super(...arguments);u(this,"name","InvalidMessageLengthError");u(this,"code","ERR_INVALID_MSG_LENGTH")}}class uf extends Error{constructor(){super(...arguments);u(this,"name","InvalidDataLengthError");u(this,"code","ERR_MSG_DATA_TOO_LONG")}}class aE extends Error{constructor(){super(...arguments);u(this,"name","InvalidDataLengthLengthError");u(this,"code","ERR_MSG_LENGTH_TOO_LONG")}}class Uc extends Error{constructor(){super(...arguments);u(this,"name","UnexpectedEOFError");u(this,"code","ERR_UNEXPECTED_EOF")}}function lf(r){return r[Symbol.asyncIterator]!=null}function df(r,e){if(r.byteLength>e)throw new uf("Message length too long")}const Ii=r=>{const e=Ge(r),t=Ct(e);return En(r,t),Ii.bytes=e,t};Ii.bytes=0;function ff(r,e){e=e??{};const t=e.lengthEncoder??Ii,n=(e==null?void 0:e.maxDataLength)??Ka;function*s(i){df(i,n);const o=t(i.byteLength);o instanceof Uint8Array?yield o:yield*o,i instanceof Uint8Array?yield i:yield*i}return lf(r)?async function*(){for await(const i of r)yield*s(i)}():function*(){for(const i of r)yield*s(i)}()}ff.single=(r,e)=>{e=e??{};const t=e.lengthEncoder??Ii,n=(e==null?void 0:e.maxDataLength)??Ka;return df(r,n),new ce(t(r.byteLength),r)};var Zt;(function(r){r[r.LENGTH=0]="LENGTH",r[r.DATA=1]="DATA"})(Zt||(Zt={}));const Va=r=>{const e=Wn(r);return Va.bytes=Ge(e),e};Va.bytes=0;function zc(r,e){const t=new ce;let n=Zt.LENGTH,s=-1;const i=(e==null?void 0:e.lengthDecoder)??Va,o=(e==null?void 0:e.maxLengthLength)??iE,a=(e==null?void 0:e.maxDataLength)??Ka;function*c(){for(;t.byteLength>0;){if(n===Zt.LENGTH)try{if(s=i(t),s<0)throw new oE("Invalid message length");if(s>a)throw new uf("Message length too long");const l=i.bytes;t.consume(l),(e==null?void 0:e.onLength)!=null&&e.onLength(s),n=Zt.DATA}catch(l){if(l instanceof RangeError){if(t.byteLength>o)throw new aE("Message length length too long");break}throw l}if(n===Zt.DATA){if(t.byteLength<s)break;const l=t.sublist(0,s);t.consume(s),(e==null?void 0:e.onData)!=null&&e.onData(l),yield l,n=Zt.LENGTH}}}return lf(r)?async function*(){for await(const l of r)t.append(l),yield*c();if(t.byteLength>0)throw new Uc("Unexpected end of input")}():function*(){for(const l of r)t.append(l),yield*c();if(t.byteLength>0)throw new Uc("Unexpected end of input")}()}zc.fromReader=(r,e)=>{let t=1;const n=async function*(){for(;;)try{const{done:i,value:o}=await r.next(t);if(i===!0)return;o!=null&&(yield o)}catch(i){if(i.code==="ERR_UNDER_READ")return{done:!0,value:null};throw i}finally{t=1}}();return zc(n,{...e??{},onLength:i=>{t=i}})};const qc=2147483647,hf=Symbol.for("sindresorhus/unlimited-timeout#brand");function cE(r,e,...t){if(typeof r!="function")throw new TypeError("Expected callback to be a function");e??(e=0),e=Number(e);let n=!1;const s={[hf]:!0,id:void 0,cleared:!1,ref(){var a,c;return n=!1,(c=(a=s.id)==null?void 0:a.ref)==null||c.call(a),s},unref(){var a,c;return n=!0,(c=(a=s.id)==null?void 0:a.unref)==null||c.call(a),s}};if(e===Number.POSITIVE_INFINITY||e>Number.MAX_SAFE_INTEGER)return s;(!Number.isFinite(e)||e<0)&&(e=0);const i=performance.now()+e,o=a=>{var c,l,d,f;s.cleared||(a<=qc?(s.id=globalThis.setTimeout(()=>{s.cleared||r(...t)},a),n&&((l=(c=s.id)==null?void 0:c.unref)==null||l.call(c))):(s.id=globalThis.setTimeout(()=>{const h=performance.now(),p=Math.max(0,i-h);o(p)},qc),n&&((f=(d=s.id)==null?void 0:d.unref)==null||f.call(d))))};return o(e),s}function uE(r){!r||typeof r!="object"||!r[hf]||(r.cleared=!0,r.id!==void 0&&(globalThis.clearTimeout(r.id),r.id=void 0))}const lE=new WeakMap;function dE({clearTimeout:r,setTimeout:e}={}){return(t,{value:n,signal:s}={})=>{if(s!=null&&s.aborted)return Promise.reject(s.reason);let i,o,a;const c=r??clearTimeout,l=()=>{c(i),a(s.reason)},d=()=>{s&&s.removeEventListener("abort",l)},f=new Promise((h,p)=>{o=()=>{d(),h(n)},a=p,i=(e??setTimeout)(o,t)});return s&&s.addEventListener("abort",l,{once:!0}),lE.set(f,()=>{c(i),i=null,o()}),f}}const Mx=dE({setTimeout:cE,clearTimeout:uE});class fE extends rf{has(e){return this.find(e)!=null}find(e){return this.queue.find(t=>e.equals(t.options.peerId))}}class hE extends rf{constructor(e={}){super({...e,sort:(t,n)=>t.options.priority>n.options.priority?-1:t.options.priority<n.options.priority?1:0})}}class gE{constructor(e={}){u(this,"memoryStorage");u(this,"points");u(this,"duration");u(this,"blockDuration");u(this,"keyPrefix");this.points=e.points??4,this.duration=e.duration??1,this.blockDuration=e.blockDuration??0,this.keyPrefix=e.keyPrefix??"rlflx",this.memoryStorage=new mE}consume(e,t=1,n={}){const s=this.getKey(e),i=this._getKeySecDuration(n);let o=this.memoryStorage.incrby(s,t,i);if(o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o.consumedPoints>this.points)throw this.blockDuration>0&&o.consumedPoints<=this.points+t&&(o=this.memoryStorage.set(s,o.consumedPoints,this.blockDuration)),new Ib("Rate limit exceeded",o);return o}penalty(e,t=1,n={}){const s=this.getKey(e),i=this._getKeySecDuration(n),o=this.memoryStorage.incrby(s,t,i);return o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o}reward(e,t=1,n={}){const s=this.getKey(e),i=this._getKeySecDuration(n),o=this.memoryStorage.incrby(s,-t,i);return o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o}block(e,t){const n=t*1e3,s=this.points+1;return this.memoryStorage.set(this.getKey(e),s,t),{remainingPoints:0,msBeforeNext:n===0?-1:n,consumedPoints:s,isFirstInDuration:!1}}set(e,t,n=0){const s=(n>=0?n:this.duration)*1e3;return this.memoryStorage.set(this.getKey(e),t,n),{remainingPoints:0,msBeforeNext:s===0?-1:s,consumedPoints:t,isFirstInDuration:!1}}get(e){const t=this.memoryStorage.get(this.getKey(e));return t!=null&&(t.remainingPoints=Math.max(this.points-t.consumedPoints,0)),t}delete(e){this.memoryStorage.delete(this.getKey(e))}_getKeySecDuration(e){return(e==null?void 0:e.customDuration)!=null&&e.customDuration>=0?e.customDuration:this.duration}getKey(e){return this.keyPrefix.length>0?`${this.keyPrefix}:${e}`:e}parseKey(e){return e.substring(this.keyPrefix.length)}}class mE{constructor(){u(this,"storage");this.storage=new Map}incrby(e,t,n){const s=this.storage.get(e);if(s!=null){const i=s.expiresAt!=null?s.expiresAt.getTime()-new Date().getTime():-1;return s.expiresAt==null||i>0?(s.value+=t,{remainingPoints:0,msBeforeNext:i,consumedPoints:s.value,isFirstInDuration:!1}):this.set(e,t,n)}return this.set(e,t,n)}set(e,t,n){const s=n*1e3,i=this.storage.get(e);i!=null&&clearTimeout(i.timeoutId);const o={value:t,expiresAt:s>0?new Date(Date.now()+s):void 0};return this.storage.set(e,o),s>0&&(o.timeoutId=setTimeout(()=>{this.storage.delete(e)},s),o.timeoutId.unref!=null&&o.timeoutId.unref()),{remainingPoints:0,msBeforeNext:s===0?-1:s,consumedPoints:o.value,isFirstInDuration:!0}}get(e){const t=this.storage.get(e);if(t!=null)return{remainingPoints:0,msBeforeNext:t.expiresAt!=null?t.expiresAt.getTime()-new Date().getTime():-1,consumedPoints:t.value,isFirstInDuration:!1}}delete(e){const t=this.storage.get(e);return t!=null?(t.timeoutId!=null&&clearTimeout(t.timeoutId),this.storage.delete(e),!0):!1}}function Nx(r,e,t){let n,s,i=!1;function o(){const l={signal:s.signal};if((t==null?void 0:t.timeout)!=null){const d=Gr([s.signal,AbortSignal.timeout(t.timeout)]);l.signal=d}i=!0,Promise.resolve().then(async()=>{await r(l)}).catch(()=>{}).finally(()=>{i=!1,!s.signal.aborted&&(n=setTimeout(o,e))})}const a=Xs(o,(t==null?void 0:t.debounce)??100);let c=!1;return{setInterval:l=>{e!==l&&(e=l,n!=null&&(clearTimeout(n),n=setTimeout(o,e)))},setTimeout:l=>{t??(t={}),t.timeout=l},run:()=>{i||(clearTimeout(n),a())},start:()=>{c||(c=!0,s=new AbortController,s.signal,(t==null?void 0:t.runImmediately)===!0?queueMicrotask(()=>{o()}):n=setTimeout(o,e))},stop:()=>{clearTimeout(n),s==null||s.abort(),c=!1}}}class pE extends Map{constructor(t){super();u(this,"metric");const{name:n,metrics:s}=t;this.metric=s.registerMetric(n),this.updateComponentMetric()}set(t,n){return super.set(t,n),this.updateComponentMetric(),this}delete(t){const n=super.delete(t);return this.updateComponentMetric(),n}clear(){super.clear(),this.updateComponentMetric()}updateComponentMetric(){this.metric.update(this.size)}}function Dt(r){const{name:e,metrics:t}=r;let n;return t!=null?n=new pE({name:e,metrics:t}):n=new Map,n}class yE{constructor(e,t){u(this,"filter");this.filter=$a(e,t)}has(e){return this.filter.has(e.toMultihash().bytes)}add(e){this.filter.add(e.toMultihash().bytes)}remove(e){var t,n;(n=(t=this.filter).remove)==null||n.call(t,e.toMultihash().bytes)}}function Rx(r,e=.001){return new yE(r,e)}class wE extends jn{constructor(t){super();u(this,"metric");const{name:n,metrics:s}=t;this.metric=s.registerMetric(n),this.updateComponentMetric()}set(t,n){return super.set(t,n),this.updateComponentMetric(),this}delete(t){const n=super.delete(t);return this.updateComponentMetric(),n}clear(){super.clear(),this.updateComponentMetric()}updateComponentMetric(){this.metric.update(this.size)}}function bE(r){const{name:e,metrics:t}=r;let n;return t!=null?n=new wE({name:e,metrics:t}):n=new jn,n}var ei;(function(r){let e;r.codec=()=>(e==null&&(e=mt((t,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),t.publicKey!=null&&t.publicKey.byteLength>0&&(n.uint32(10),n.bytes(t.publicKey)),t.payloadType!=null&&t.payloadType.byteLength>0&&(n.uint32(18),n.bytes(t.payloadType)),t.payload!=null&&t.payload.byteLength>0&&(n.uint32(26),n.bytes(t.payload)),t.signature!=null&&t.signature.byteLength>0&&(n.uint32(42),n.bytes(t.signature)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={publicKey:Ie(0),payloadType:Ie(0),payload:Ie(0),signature:Ie(0)},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.publicKey=t.bytes();break}case 2:{i.payloadType=t.bytes();break}case 3:{i.payload=t.bytes();break}case 5:{i.signature=t.bytes();break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>gt(t,r.codec()),r.decode=(t,n)=>ht(t,r.codec(),n)})(ei||(ei={}));class EE extends Error{constructor(e="Invalid signature"){super(e),this.name="InvalidSignatureError"}}const Ot=class Ot{constructor(e){u(this,"publicKey");u(this,"payloadType");u(this,"payload");u(this,"signature");u(this,"marshaled");const{publicKey:t,payloadType:n,payload:s,signature:i}=e;this.publicKey=t,this.payloadType=n,this.payload=s,this.signature=i}marshal(){return this.marshaled==null&&(this.marshaled=ei.encode({publicKey:ir(this.publicKey),payloadType:this.payloadType,payload:this.payload.subarray(),signature:this.signature})),this.marshaled}equals(e){return e==null?!1:Se(this.marshal(),e.marshal())}async validate(e,t){const n=Kc(e,this.payloadType,this.payload);return this.publicKey.verify(n.subarray(),this.signature,t)}};u(Ot,"createFromProtobuf",e=>{const t=ei.decode(e),n=Ea(t.publicKey);return new Ot({publicKey:n,payloadType:t.payloadType,payload:t.payload,signature:t.signature})}),u(Ot,"seal",async(e,t,n)=>{if(t==null)throw new Error("Missing private key");const s=e.domain,i=e.codec,o=e.marshal(),a=Kc(s,i,o),c=await t.sign(a.subarray(),n);return new Ot({publicKey:t.publicKey,payloadType:i,payload:o,signature:c})}),u(Ot,"openAndCertify",async(e,t,n)=>{const s=Ot.createFromProtobuf(e);if(!await s.validate(t,n))throw new EE("Envelope signature is not valid for the given domain");return s});let ti=Ot;const Kc=(r,e,t)=>{const n=W(r),s=En(n.byteLength),i=En(e.length),o=En(t.length);return new ce(s,n,i,e,o,t)},vE="libp2p-peer-record",xE=Uint8Array.from([3,1]);var ri;(function(r){(function(t){let n;t.codec=()=>(n==null&&(n=mt((s,i,o={})=>{o.lengthDelimited!==!1&&i.fork(),s.multiaddr!=null&&s.multiaddr.byteLength>0&&(i.uint32(10),i.bytes(s.multiaddr)),o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{const a={multiaddr:Ie(0)},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const l=s.uint32();switch(l>>>3){case 1:{a.multiaddr=s.bytes();break}default:{s.skipType(l&7);break}}}return a})),n),t.encode=s=>gt(s,t.codec()),t.decode=(s,i)=>ht(s,t.codec(),i)})(r.AddressInfo||(r.AddressInfo={}));let e;r.codec=()=>(e==null&&(e=mt((t,n,s={})=>{if(s.lengthDelimited!==!1&&n.fork(),t.peerId!=null&&t.peerId.byteLength>0&&(n.uint32(10),n.bytes(t.peerId)),t.seq!=null&&t.seq!==0n&&(n.uint32(16),n.uint64(t.seq)),t.addresses!=null)for(const i of t.addresses)n.uint32(26),r.AddressInfo.codec().encode(i,n);s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{var a,c;const i={peerId:Ie(0),seq:0n,addresses:[]},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const l=t.uint32();switch(l>>>3){case 1:{i.peerId=t.bytes();break}case 2:{i.seq=t.uint64();break}case 3:{if(((a=s.limits)==null?void 0:a.addresses)!=null&&i.addresses.length===s.limits.addresses)throw new Ao('Decode error - map field "addresses" had too many elements');i.addresses.push(r.AddressInfo.codec().decode(t,t.uint32(),{limits:(c=s.limits)==null?void 0:c.addresses$}));break}default:{t.skipType(l&7);break}}}return i})),e),r.encode=t=>gt(t,r.codec()),r.decode=(t,n)=>ht(t,r.codec(),n)})(ri||(ri={}));function SE(r,e){const t=(n,s)=>n.toString().localeCompare(s.toString());return r.length!==e.length?!1:(e.sort(t),r.sort(t).every((n,s)=>e[s].equals(n)))}const Et=class Et{constructor(e){u(this,"peerId");u(this,"multiaddrs");u(this,"seqNumber");u(this,"domain",Et.DOMAIN);u(this,"codec",Et.CODEC);u(this,"marshaled");const{peerId:t,multiaddrs:n,seqNumber:s}=e;this.peerId=t,this.multiaddrs=n??[],this.seqNumber=s??BigInt(Date.now())}marshal(){return this.marshaled==null&&(this.marshaled=ri.encode({peerId:this.peerId.toMultihash().bytes,seq:BigInt(this.seqNumber),addresses:this.multiaddrs.map(e=>({multiaddr:e.bytes}))})),this.marshaled}equals(e){return!(!(e instanceof Et)||!this.peerId.equals(e.peerId)||this.seqNumber!==e.seqNumber||!SE(this.multiaddrs,e.multiaddrs))}};u(Et,"createFromProtobuf",e=>{const t=ri.decode(e),n=vi(hi(t.peerId)),s=(t.addresses??[]).map(o=>Ee(o.multiaddr)),i=t.seq;return new Et({peerId:n,multiaddrs:s,seqNumber:i})}),u(Et,"DOMAIN",vE),u(Et,"CODEC",xE);let Sn=Et;function _E(r){return r[Symbol.asyncIterator]!=null}function $o(r){if(_E(r))return(async()=>{const t=[];for await(const n of r)t.push(n);return t})();const e=[];for(const t of r)e.push(t);return e}var lo;let Qr=(lo=class extends Error{constructor(t="The operation was aborted",...n){super(t,...n);u(this,"name","AbortError")}},u(lo,"name","AbortError"),lo);async function Zi(r,e,t,n){const s=new Qr(n==null?void 0:n.errorMessage);(n==null?void 0:n.errorCode)!=null&&(s.code=n.errorCode);const i=(n==null?void 0:n.errorEvent)??"error";return(t==null?void 0:t.aborted)===!0?Promise.reject(s):new Promise((o,a)=>{function c(){Yi(t,"abort",f),Yi(r,e,l),Yi(r,i,d)}const l=h=>{var p;try{if(((p=n==null?void 0:n.filter)==null?void 0:p.call(n,h))===!1)return}catch(g){c(),a(g);return}c(),o(h)},d=h=>{if(c(),h instanceof Error){a(h);return}a(h.detail??(n==null?void 0:n.error)??new Error(`The "${n==null?void 0:n.errorEvent}" event was emitted but the event had no '.detail' field. Pass an 'error' option to race-event to change this message.`))},f=()=>{c(),a(s)};ji(t,"abort",f),ji(r,e,l),ji(r,i,d)})}function ji(r,e,t){r!=null&&(gf(r)?r.addEventListener(e,t):r.addListener(e,t))}function Yi(r,e,t){r!=null&&(gf(r)?r.removeEventListener(e,t):r.removeListener(e,t))}function gf(r){return typeof r.addEventListener=="function"&&typeof r.removeEventListener=="function"}class mf extends Error{constructor(e="The queue was full"){super(e),this.name="QueueFullError"}}u(mf,"name","QueueFullError");class AE{constructor(e){u(this,"deferred");u(this,"signal");var t;this.signal=e,this.deferred=Promise.withResolvers(),this.onAbort=this.onAbort.bind(this),(t=this.signal)==null||t.addEventListener("abort",this.onAbort)}onAbort(){var e;this.deferred.reject(((e=this.signal)==null?void 0:e.reason)??new Qr)}cleanup(){var e;(e=this.signal)==null||e.removeEventListener("abort",this.onAbort)}}function IE(){return`${parseInt(String(Math.random()*1e9),10).toString()}${Date.now()}`}class CE{constructor(e,t){u(this,"id");u(this,"fn");u(this,"options");u(this,"recipients");u(this,"status");u(this,"timeline");u(this,"controller");this.id=IE(),this.status="queued",this.fn=e,this.options=t,this.recipients=[],this.timeline={created:Date.now()},this.controller=new AbortController,this.controller.signal,this.onAbort=this.onAbort.bind(this)}abort(e){this.controller.abort(e)}onAbort(){this.recipients.reduce((t,n)=>{var s;return t&&((s=n.signal)==null?void 0:s.aborted)===!0},!0)&&(this.controller.abort(new Qr),this.cleanup())}async join(e={}){var n;const t=new AE(e.signal);return this.recipients.push(t),(n=e.signal)==null||n.addEventListener("abort",this.onAbort),t.deferred.promise}async run(){this.status="running",this.timeline.started=Date.now();try{this.controller.signal.throwIfAborted();const e=await Tt(this.fn({...this.options??{},signal:this.controller.signal}),this.controller.signal);this.recipients.forEach(t=>{t.deferred.resolve(e)}),this.status="complete"}catch(e){this.recipients.forEach(t=>{t.deferred.reject(e)}),this.status="errored"}finally{this.timeline.finished=Date.now(),this.cleanup()}}cleanup(){this.recipients.forEach(e=>{var t;e.cleanup(),(t=e.signal)==null||t.removeEventListener("abort",this.onAbort)})}}function Vc(r,e){let t;const n=function(){const s=function(){t=void 0,r()};clearTimeout(t),t=setTimeout(s,e)};return n.start=()=>{},n.stop=()=>{clearTimeout(t)},n}class Hc extends It{constructor(t={}){super();u(this,"concurrency");u(this,"maxSize");u(this,"queue");u(this,"pending");u(this,"sort");u(this,"autoStart");this.concurrency=t.concurrency??Number.POSITIVE_INFINITY,this.maxSize=t.maxSize??Number.POSITIVE_INFINITY,this.pending=0,this.autoStart=t.autoStart??!0,this.sort=t.sort,this.queue=[],this.emitEmpty=Vc(this.emitEmpty.bind(this),1),this.emitIdle=Vc(this.emitIdle.bind(this),1)}[Symbol.asyncIterator](){return this.toGenerator()}emitEmpty(){this.size===0&&this.safeDispatchEvent("empty")}emitIdle(){this.running===0&&this.safeDispatchEvent("idle")}tryToStartAnother(){if(this.size===0)return this.emitEmpty(),this.running===0&&this.emitIdle(),!1;if(this.pending<this.concurrency){let t;for(const n of this.queue)if(n.status==="queued"){t=n;break}return t==null?!1:(this.safeDispatchEvent("active"),this.pending++,t.run().finally(()=>{for(let n=0;n<this.queue.length;n++)if(this.queue[n]===t){this.queue.splice(n,1);break}this.pending--,this.safeDispatchEvent("next"),this.autoStart&&this.tryToStartAnother()}),!0)}return!1}enqueue(t){this.queue.push(t),this.sort!=null&&this.queue.sort(this.sort)}start(){this.autoStart===!1&&(this.autoStart=!0,this.tryToStartAnother())}pause(){this.autoStart=!1}async add(t,n){var i;if((i=n==null?void 0:n.signal)==null||i.throwIfAborted(),this.size===this.maxSize)throw new mf;const s=new CE(t,n);return this.enqueue(s),this.safeDispatchEvent("add"),this.autoStart&&this.tryToStartAnother(),s.join(n).then(o=>(this.safeDispatchEvent("success",{detail:{job:s,result:o}}),o)).catch(o=>{if(s.status==="queued"){for(let a=0;a<this.queue.length;a++)if(this.queue[a]===s){this.queue.splice(a,1);break}}throw this.safeDispatchEvent("failure",{detail:{job:s,error:o}}),o})}clear(){this.queue.splice(0,this.queue.length)}abort(){this.queue.forEach(t=>{t.abort(new Qr)}),this.clear()}async onEmpty(t){this.size!==0&&await Zi(this,"empty",t==null?void 0:t.signal)}async onSizeLessThan(t,n){this.size<t||await Zi(this,"next",n==null?void 0:n.signal,{filter:()=>this.size<t})}async onIdle(t){this.pending===0&&this.size===0||await Zi(this,"idle",t==null?void 0:t.signal)}get size(){return this.queue.length}get queued(){return this.queue.length-this.pending}get running(){return this.pending}async*toGenerator(t){var l,d,f;(l=t==null?void 0:t.signal)==null||l.throwIfAborted();const n=Yn({objectMode:!0}),s=h=>{h!=null?this.abort():this.clear(),n.end(h)},i=h=>{h.detail!=null&&n.push(h.detail.result)},o=h=>{s(h.detail.error)},a=()=>{s()},c=()=>{s(new Qr("Queue aborted"))};this.addEventListener("success",i),this.addEventListener("failure",o),this.addEventListener("idle",a),(d=t==null?void 0:t.signal)==null||d.addEventListener("abort",c);try{yield*n}finally{this.removeEventListener("success",i),this.removeEventListener("failure",o),this.removeEventListener("idle",a),(f=t==null?void 0:t.signal)==null||f.removeEventListener("abort",c),s()}}}const pf="lock:worker:request-read",yf="lock:worker:abort-read-request",wf="lock:worker:release-read",bf="lock:master:grant-read",Ef="lock:master:error-read",vf="lock:worker:request-write",xf="lock:worker:abort-write-request",Sf="lock:worker:release-write",_f="lock:master:grant-write",Af="lock:master:error-write",If="lock:worker:finalize",Cf="mortice",LE={singleProcess:!1},Wc=(r,e,t,n,s,i,o,a,c)=>l=>{if(l.data==null)return;const d={type:l.data.type,name:l.data.name,identifier:l.data.identifier};d.type===s&&r.safeDispatchEvent(t,{detail:{name:d.name,identifier:d.identifier,handler:async()=>{e.postMessage({type:c,name:d.name,identifier:d.identifier}),await new Promise(f=>{const h=p=>{if((p==null?void 0:p.data)==null)return;const g={type:p.data.type,name:p.data.name,identifier:p.data.identifier};g.type===a&&g.identifier===d.identifier&&(e.removeEventListener("message",h),f())};e.addEventListener("message",h)})},onError:f=>{e.postMessage({type:o,name:d.name,identifier:d.identifier,error:{message:f.message,name:f.name,stack:f.stack}})}}}),d.type===i&&r.safeDispatchEvent(n,{detail:{name:d.name,identifier:d.identifier}}),d.type===If&&r.safeDispatchEvent("finalizeRequest",{detail:{name:d.name}})},TE=(r=10)=>Math.random().toString().substring(2,r+2);class DE{constructor(e){u(this,"name");u(this,"channel");this.name=e,this.channel=new BroadcastChannel(Cf)}readLock(e){return this.sendRequest(pf,yf,bf,Ef,wf,e)}writeLock(e){return this.sendRequest(vf,xf,_f,Af,Sf,e)}finalize(){this.channel.postMessage({type:If,name:this.name}),this.channel.close()}async sendRequest(e,t,n,s,i,o){var c;(c=o==null?void 0:o.signal)==null||c.throwIfAborted();const a=TE();return this.channel.postMessage({type:e,identifier:a,name:this.name}),new Promise((l,d)=>{var p;const f=()=>{this.channel.postMessage({type:t,identifier:a,name:this.name})};(p=o==null?void 0:o.signal)==null||p.addEventListener("abort",f,{once:!0});const h=g=>{var y,m,_,x;if(((y=g.data)==null?void 0:y.identifier)===a&&(((m=g.data)==null?void 0:m.type)===n&&(this.channel.removeEventListener("message",h),(_=o==null?void 0:o.signal)==null||_.removeEventListener("abort",f),l(()=>{this.channel.postMessage({type:i,identifier:a,name:this.name})})),g.data.type===s)){this.channel.removeEventListener("message",h),(x=o==null?void 0:o.signal)==null||x.removeEventListener("abort",f);const E=new Error;g.data.error!=null&&(E.message=g.data.error.message,E.name=g.data.error.name,E.stack=g.data.error.stack),d(E)}};this.channel.addEventListener("message",h)})}}const kE=r=>{if(r=Object.assign({},LE,r),!!globalThis.document||r.singleProcess){const t=new BroadcastChannel(Cf),n=new It;return t.addEventListener("message",Wc(n,t,"requestReadLock","abortReadLockRequest",pf,yf,Ef,wf,bf)),t.addEventListener("message",Wc(n,t,"requestWriteLock","abortWriteLockRequest",vf,xf,Af,Sf,_f)),n}return new DE(r.name)},Qt=new Map;let hn;function Lf(r){return typeof(r==null?void 0:r.readLock)=="function"&&typeof(r==null?void 0:r.writeLock)=="function"}function PE(r){if(hn==null&&(hn=kE(r),!Lf(hn))){const e=hn;e.addEventListener("requestReadLock",t=>{const n=t.detail.name,s=t.detail.identifier,i=Qt.get(n);if(i==null)return;const o=new AbortController,a=c=>{c.detail.name!==n||c.detail.identifier!==s||o.abort()};e.addEventListener("abortReadLockRequest",a),i.readLock({signal:o.signal}).then(async c=>{await t.detail.handler().finally(()=>{c()})}).catch(c=>{t.detail.onError(c)}).finally(()=>{e.removeEventListener("abortReadLockRequest",a)})}),e.addEventListener("requestWriteLock",t=>{const n=t.detail.name,s=t.detail.identifier,i=Qt.get(n);if(i==null)return;const o=new AbortController,a=c=>{c.detail.name!==n||c.detail.identifier!==s||o.abort()};e.addEventListener("abortWriteLockRequest",a),i.writeLock({signal:o.signal}).then(async c=>{await t.detail.handler().finally(()=>{c()})}).catch(c=>{t.detail.onError(c)}).finally(()=>{e.removeEventListener("abortWriteLockRequest",a)})}),e.addEventListener("finalizeRequest",t=>{const n=t.detail.name,s=Qt.get(n);s!=null&&s.finalize()})}return hn}async function Xi(r,e){var o;let t,n;const s=new Promise((a,c)=>{t=a,n=c}),i=()=>{n(new Qr)};return(o=e==null?void 0:e.signal)==null||o.addEventListener("abort",i,{once:!0}),r.add(async()=>{await new Promise(a=>{t(()=>{var c;(c=e==null?void 0:e.signal)==null||c.removeEventListener("abort",i),a()})})},{signal:e==null?void 0:e.signal}).catch(a=>{n(a)}),s}const ME=(r,e)=>{let t=Qt.get(r);if(t!=null)return t;const n=PE(e);if(Lf(n))return t=n,Qt.set(r,t),t;const s=new Hc({concurrency:1});let i;return t={async readLock(o){if(i!=null)return Xi(i,o);i=new Hc({concurrency:e.concurrency,autoStart:!1});const a=i,c=Xi(i,o);return s.add(async()=>{a.start(),await a.onIdle().then(()=>{i===a&&(i=null)})}),c},async writeLock(o){return i=null,Xi(s,o)},finalize:()=>{Qt.delete(r)},queue:s},Qt.set(r,t),e.autoFinalize===!0&&s.addEventListener("idle",()=>{t.finalize()},{once:!0}),t},NE={name:"lock",concurrency:1/0,singleProcess:!1,autoFinalize:!1};function RE(r){const e=Object.assign({},NE,r);return ME(e.name,e)}const BE=36e5,FE=216e5;var Jt;(function(r){(function(t){let n;t.codec=()=>(n==null&&(n=mt((s,i,o={})=>{o.lengthDelimited!==!1&&i.fork(),s.key!=null&&s.key!==""&&(i.uint32(10),i.string(s.key)),s.value!=null&&s.value.byteLength>0&&(i.uint32(18),i.bytes(s.value)),o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{const a={key:"",value:Ie(0)},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const l=s.uint32();switch(l>>>3){case 1:{a.key=s.string();break}case 2:{a.value=s.bytes();break}default:{s.skipType(l&7);break}}}return a})),n),t.encode=s=>gt(s,t.codec()),t.decode=(s,i)=>ht(s,t.codec(),i)})(r.Peer$metadataEntry||(r.Peer$metadataEntry={})),function(t){let n;t.codec=()=>(n==null&&(n=mt((s,i,o={})=>{o.lengthDelimited!==!1&&i.fork(),s.key!=null&&s.key!==""&&(i.uint32(10),i.string(s.key)),s.value!=null&&(i.uint32(18),si.codec().encode(s.value,i)),o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{var l;const a={key:""},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const d=s.uint32();switch(d>>>3){case 1:{a.key=s.string();break}case 2:{a.value=si.codec().decode(s,s.uint32(),{limits:(l=o.limits)==null?void 0:l.value});break}default:{s.skipType(d&7);break}}}return a})),n),t.encode=s=>gt(s,t.codec()),t.decode=(s,i)=>ht(s,t.codec(),i)}(r.Peer$tagsEntry||(r.Peer$tagsEntry={}));let e;r.codec=()=>(e==null&&(e=mt((t,n,s={})=>{if(s.lengthDelimited!==!1&&n.fork(),t.addresses!=null)for(const i of t.addresses)n.uint32(10),ni.codec().encode(i,n);if(t.protocols!=null)for(const i of t.protocols)n.uint32(18),n.string(i);if(t.publicKey!=null&&(n.uint32(34),n.bytes(t.publicKey)),t.peerRecordEnvelope!=null&&(n.uint32(42),n.bytes(t.peerRecordEnvelope)),t.metadata!=null&&t.metadata.size!==0)for(const[i,o]of t.metadata.entries())n.uint32(50),r.Peer$metadataEntry.codec().encode({key:i,value:o},n);if(t.tags!=null&&t.tags.size!==0)for(const[i,o]of t.tags.entries())n.uint32(58),r.Peer$tagsEntry.codec().encode({key:i,value:o},n);t.updated!=null&&(n.uint32(64),n.uint64Number(t.updated)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{var a,c,l,d,f,h;const i={addresses:[],protocols:[],metadata:new Map,tags:new Map},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const p=t.uint32();switch(p>>>3){case 1:{if(((a=s.limits)==null?void 0:a.addresses)!=null&&i.addresses.length===s.limits.addresses)throw new Ao('Decode error - map field "addresses" had too many elements');i.addresses.push(ni.codec().decode(t,t.uint32(),{limits:(c=s.limits)==null?void 0:c.addresses$}));break}case 2:{if(((l=s.limits)==null?void 0:l.protocols)!=null&&i.protocols.length===s.limits.protocols)throw new Ao('Decode error - map field "protocols" had too many elements');i.protocols.push(t.string());break}case 4:{i.publicKey=t.bytes();break}case 5:{i.peerRecordEnvelope=t.bytes();break}case 6:{if(((d=s.limits)==null?void 0:d.metadata)!=null&&i.metadata.size===s.limits.metadata)throw new Ic('Decode error - map field "metadata" had too many elements');const g=r.Peer$metadataEntry.codec().decode(t,t.uint32());i.metadata.set(g.key,g.value);break}case 7:{if(((f=s.limits)==null?void 0:f.tags)!=null&&i.tags.size===s.limits.tags)throw new Ic('Decode error - map field "tags" had too many elements');const g=r.Peer$tagsEntry.codec().decode(t,t.uint32(),{limits:{value:(h=s.limits)==null?void 0:h.tags$value}});i.tags.set(g.key,g.value);break}case 8:{i.updated=t.uint64Number();break}default:{t.skipType(p&7);break}}}return i})),e),r.encode=t=>gt(t,r.codec()),r.decode=(t,n)=>ht(t,r.codec(),n)})(Jt||(Jt={}));var ni;(function(r){let e;r.codec=()=>(e==null&&(e=mt((t,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),t.multiaddr!=null&&t.multiaddr.byteLength>0&&(n.uint32(10),n.bytes(t.multiaddr)),t.isCertified!=null&&(n.uint32(16),n.bool(t.isCertified)),t.observed!=null&&(n.uint32(24),n.uint64Number(t.observed)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={multiaddr:Ie(0)},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.multiaddr=t.bytes();break}case 2:{i.isCertified=t.bool();break}case 3:{i.observed=t.uint64Number();break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>gt(t,r.codec()),r.decode=(t,n)=>ht(t,r.codec(),n)})(ni||(ni={}));var si;(function(r){let e;r.codec=()=>(e==null&&(e=mt((t,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),t.value!=null&&t.value!==0&&(n.uint32(8),n.uint32(t.value)),t.expiry!=null&&(n.uint32(16),n.uint64(t.expiry)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={value:0},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.value=t.uint32();break}case 2:{i.expiry=t.uint64();break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>gt(t,r.codec()),r.decode=(t,n)=>ht(t,r.codec(),n)})(si||(si={}));function OE(r,e){if(r.publicKey!=null||e.publicKey==null)return r;let t;r.type==="RSA"&&(t=r.toMultihash());const n=Ea(e.publicKey,t);return ed(n)}function $E(r,e,t){const n=Jt.decode(e);return yn(r,n,t)}function yn(r,e,t){const n=new Map,s=BigInt(Date.now());for(const[i,o]of e.tags.entries())o.expiry!=null&&o.expiry<s||n.set(i,o);return{...e,id:OE(r,e),addresses:e.addresses.filter(({observed:i})=>i!=null&&i>Date.now()-t).map(({multiaddr:i,isCertified:o})=>({multiaddr:Ee(i),isCertified:o??!1})),metadata:e.metadata,peerRecordEnvelope:e.peerRecordEnvelope??void 0,tags:n}}function UE(r,e){return zE(r.addresses,e.addresses)&&qE(r.protocols,e.protocols)&&KE(r.publicKey,e.publicKey)&&VE(r.peerRecordEnvelope,e.peerRecordEnvelope)&&HE(r.metadata,e.metadata)&&WE(r.tags,e.tags)}function zE(r,e){return Df(r,e,(t,n)=>!(t.isCertified!==n.isCertified||!Se(t.multiaddr,n.multiaddr)))}function qE(r,e){return Df(r,e,(t,n)=>t===n)}function KE(r,e){return Tf(r,e)}function VE(r,e){return Tf(r,e)}function HE(r,e){return kf(r,e,(t,n)=>Se(t,n))}function WE(r,e){return kf(r,e,(t,n)=>t.value===n.value&&t.expiry===n.expiry)}function Tf(r,e){return r==null&&e==null?!0:r!=null&&e!=null?Se(r,e):!1}function Df(r,e,t){if(r.length!==e.length)return!1;for(let n=0;n<r.length;n++)if(!t(r[n],e[n]))return!1;return!0}function kf(r,e,t){if(r.size!==e.size)return!1;for(const[n,s]of r.entries()){const i=e.get(n);if(i==null||!t(s,i))return!1}return!0}const bt="/",Pf=new TextEncoder().encode(bt),ls=Pf[0];class Oe{constructor(e,t){u(this,"_buf");if(typeof e=="string")this._buf=W(e);else if(e instanceof Uint8Array)this._buf=e;else throw new Error("Invalid key, should be String of Uint8Array");if(t==null&&(t=!0),t&&this.clean(),this._buf.byteLength===0||this._buf[0]!==ls)throw new Error("Invalid key")}toString(e="utf8"){return X(this._buf,e)}uint8Array(){return this._buf}get[Symbol.toStringTag](){return`Key(${this.toString()})`}static withNamespaces(e){return new Oe(e.join(bt))}static random(){return new Oe(Math.random().toString().substring(2))}static asKey(e){return e instanceof Uint8Array||typeof e=="string"?new Oe(e):typeof e.uint8Array=="function"?new Oe(e.uint8Array()):null}clean(){if((this._buf==null||this._buf.byteLength===0)&&(this._buf=Pf),this._buf[0]!==ls){const e=new Uint8Array(this._buf.byteLength+1);e.fill(ls,0,1),e.set(this._buf,1),this._buf=e}for(;this._buf.byteLength>1&&this._buf[this._buf.byteLength-1]===ls;)this._buf=this._buf.subarray(0,-1)}less(e){const t=this.list(),n=e.list();for(let s=0;s<t.length;s++){if(n.length<s+1)return!1;const i=t[s],o=n[s];if(i<o)return!0;if(i>o)return!1}return t.length<n.length}reverse(){return Oe.withNamespaces(this.list().slice().reverse())}namespaces(){return this.list()}baseNamespace(){const e=this.namespaces();return e[e.length-1]}list(){return this.toString().split(bt).slice(1)}type(){return GE(this.baseNamespace())}name(){return ZE(this.baseNamespace())}instance(e){return new Oe(this.toString()+":"+e)}path(){let e=this.parent().toString();return e.endsWith(bt)||(e+=bt),e+=this.type(),new Oe(e)}parent(){const e=this.list();return e.length===1?new Oe(bt):new Oe(e.slice(0,-1).join(bt))}child(e){return this.toString()===bt?e:e.toString()===bt?this:new Oe(this.toString()+e.toString(),!1)}isAncestorOf(e){return e.toString()===this.toString()?!1:e.toString().startsWith(this.toString())}isDecendantOf(e){return e.toString()===this.toString()?!1:this.toString().startsWith(e.toString())}isTopLevel(){return this.list().length===1}concat(...e){return Oe.withNamespaces([...this.namespaces(),...jE(e.map(t=>t.namespaces()))])}}function GE(r){const e=r.split(":");return e.length<2?"":e.slice(0,-1).join(":")}function ZE(r){const e=r.split(":");return e[e.length-1]}function jE(r){return[].concat(...r)}const Mf="/peers/";function ds(r){if(!wn(r)||r.type==null)throw new Z("Invalid PeerId");const e=r.toCID().toString();return new Oe(`${Mf}${e}`)}async function YE(r,e,t,n,s){const i=new Map;for(const o of t){if(o==null)continue;if(o.multiaddr instanceof Uint8Array&&(o.multiaddr=Ee(o.multiaddr)),!xi(o.multiaddr))throw new Z("Multiaddr was invalid");if(!await e(r,o.multiaddr,s))continue;const a=o.isCertified??!1,c=o.multiaddr.toString(),l=i.get(c);l!=null?o.isCertified=l.isCertified||a:i.set(c,{multiaddr:o.multiaddr,isCertified:a})}return[...i.values()].sort((o,a)=>o.multiaddr.toString().localeCompare(a.multiaddr.toString())).map(({isCertified:o,multiaddr:a})=>{var l;const c=(l=a.getComponents().find(d=>d.code===Q))==null?void 0:l.value;return r.equals(c)&&(a=a.decapsulate(Ee(`/p2p/${r}`))),{isCertified:o,multiaddr:a.bytes}})}async function Qi(r,e,t,n){var h,p;if(e==null)throw new Z("Invalid PeerData");if(e.publicKey!=null&&r.publicKey!=null&&!e.publicKey.equals(r.publicKey))throw new Z("publicKey bytes do not match peer id publicKey bytes");const s=(h=n.existingPeer)==null?void 0:h.peer;if(s!=null&&!r.equals(s.id))throw new Z("peer id did not match existing peer id");let i=(s==null?void 0:s.addresses)??[],o=new Set((s==null?void 0:s.protocols)??[]),a=(s==null?void 0:s.metadata)??new Map,c=(s==null?void 0:s.tags)??new Map,l=s==null?void 0:s.peerRecordEnvelope;if(t==="patch"){if((e.multiaddrs!=null||e.addresses!=null)&&(i=[],e.multiaddrs!=null&&i.push(...e.multiaddrs.map(g=>({isCertified:!1,multiaddr:g}))),e.addresses!=null&&i.push(...e.addresses)),e.protocols!=null&&(o=new Set(e.protocols)),e.metadata!=null){const g=e.metadata instanceof Map?[...e.metadata.entries()]:Object.entries(e.metadata);a=fs(g,{validate:Gc})}if(e.tags!=null){const g=e.tags instanceof Map?[...e.tags.entries()]:Object.entries(e.tags);c=fs(g,{validate:Zc,map:jc})}e.peerRecordEnvelope!=null&&(l=e.peerRecordEnvelope)}if(t==="merge"){if(e.multiaddrs!=null&&i.push(...e.multiaddrs.map(g=>({isCertified:!1,multiaddr:g}))),e.addresses!=null&&i.push(...e.addresses),e.protocols!=null&&(o=new Set([...o,...e.protocols])),e.metadata!=null){const g=e.metadata instanceof Map?[...e.metadata.entries()]:Object.entries(e.metadata);for(const[y,m]of g)m==null?a.delete(y):a.set(y,m);a=fs([...a.entries()],{validate:Gc})}if(e.tags!=null){const g=e.tags instanceof Map?[...e.tags.entries()]:Object.entries(e.tags),y=new Map(c);for(const[m,_]of g)_==null?y.delete(m):y.set(m,_);c=fs([...y.entries()],{validate:Zc,map:jc})}e.peerRecordEnvelope!=null&&(l=e.peerRecordEnvelope)}let d;(s==null?void 0:s.id.publicKey)!=null?d=ir(s.id.publicKey):e.publicKey!=null?d=ir(e.publicKey):r.publicKey!=null&&(d=ir(r.publicKey));const f={addresses:await YE(r,n.addressFilter??(async()=>!0),i,(p=n.existingPeer)==null?void 0:p.peerPB.addresses,n),protocols:[...o.values()].sort((g,y)=>g.localeCompare(y)),metadata:a,tags:c,publicKey:d,peerRecordEnvelope:l};return f.addresses.forEach(g=>{var y,m,_;g.observed=((_=(m=(y=n.existingPeer)==null?void 0:y.peerPB.addresses)==null?void 0:m.find(x=>Se(x.multiaddr,x.multiaddr)))==null?void 0:_.observed)??Date.now()}),r.type!=="RSA"&&delete f.publicKey,f}function fs(r,e){var n;const t=new Map;for(const[s,i]of r)i!=null&&e.validate(s,i);for(const[s,i]of r.sort(([o],[a])=>o.localeCompare(a)))i!=null&&t.set(s,((n=e.map)==null?void 0:n.call(e,s,i))??i);return t}function Gc(r,e){if(typeof r!="string")throw new Z("Metadata key must be a string");if(!(e instanceof Uint8Array))throw new Z("Metadata value must be a Uint8Array")}function Zc(r,e){if(typeof r!="string")throw new Z("Tag name must be a string");if(e.value!=null){if(parseInt(`${e.value}`,10)!==e.value)throw new Z("Tag value must be an integer");if(e.value<0||e.value>100)throw new Z("Tag value must be between 0-100")}if(e.ttl!=null){if(parseInt(`${e.ttl}`,10)!==e.ttl)throw new Z("Tag ttl must be an integer");if(e.ttl<0)throw new Z("Tag ttl must be between greater than 0")}}function jc(r,e){let t;e.expiry!=null&&(t=e.expiry),e.ttl!=null&&(t=BigInt(Date.now()+Number(e.ttl)));const n={value:e.value??0};return t!=null&&(n.expiry=t),n}function Nf(r){const e=r.toString().split("/")[2],t=ue.parse(e,zt);return xa(t)}function Ji(r,e,t){const n=Nf(r);return $E(n,e,t)}function XE(r,e){return{prefix:Mf,filters:(r.filters??[]).map(t=>({key:n,value:s})=>t(Ji(n,s,e))),orders:(r.orders??[]).map(t=>(n,s)=>t(Ji(n.key,n.value,e),Ji(s.key,s.value,e)))}}var Ke,Cs,Ls,Ts;class QE{constructor(e,t={}){se(this,Ke);u(this,"peerId");u(this,"datastore");u(this,"locks");u(this,"addressFilter");u(this,"log");u(this,"maxAddressAge");u(this,"maxPeerAge");this.log=e.logger.forComponent("libp2p:peer-store"),this.peerId=e.peerId,this.datastore=e.datastore,this.addressFilter=t.addressFilter,this.locks=bE({name:"libp2p_peer_store_locks",metrics:e.metrics}),this.maxAddressAge=t.maxAddressAge??BE,this.maxPeerAge=t.maxPeerAge??FE}getLock(e){let t=this.locks.get(e);return t==null&&(t={refs:0,lock:RE({name:e.toString(),singleProcess:!0})},this.locks.set(e,t)),t.refs++,t}maybeRemoveLock(e,t){t.refs--,t.refs===0&&(t.lock.finalize(),this.locks.delete(e))}async getReadLock(e,t){const n=this.getLock(e);try{const s=await n.lock.readLock(t);return()=>{s(),this.maybeRemoveLock(e,n)}}catch(s){throw this.maybeRemoveLock(e,n),s}}async getWriteLock(e,t){const n=this.getLock(e);try{const s=await n.lock.writeLock(t);return()=>{s(),this.maybeRemoveLock(e,n)}}catch(s){throw this.maybeRemoveLock(e,n),s}}async has(e,t){try{return await this.load(e,t),!0}catch(n){if(n.name!=="NotFoundError")throw n}return!1}async delete(e,t){this.peerId.equals(e)||await this.datastore.delete(ds(e),t)}async load(e,t){const n=ds(e),s=await this.datastore.get(n,t),i=Jt.decode(s);if(O(this,Ke,Ts).call(this,e,i))throw await this.datastore.delete(n,t),new ho;return yn(e,i,this.peerId.equals(e)?1/0:this.maxAddressAge)}async save(e,t,n){const s=await O(this,Ke,Cs).call(this,e,n),i=await Qi(e,t,"patch",{...n,addressFilter:this.addressFilter});return O(this,Ke,Ls).call(this,e,i,s)}async patch(e,t,n){const s=await O(this,Ke,Cs).call(this,e,n),i=await Qi(e,t,"patch",{...n,addressFilter:this.addressFilter,existingPeer:s});return O(this,Ke,Ls).call(this,e,i,s)}async merge(e,t,n){const s=await O(this,Ke,Cs).call(this,e,n),i=await Qi(e,t,"merge",{addressFilter:this.addressFilter,existingPeer:s});return O(this,Ke,Ls).call(this,e,i,s)}async*all(e){for await(const{key:t,value:n}of this.datastore.query(XE(e??{},this.maxAddressAge),e)){const s=Nf(t);if(s.equals(this.peerId))continue;const i=Jt.decode(n);if(O(this,Ke,Ts).call(this,s,i)){await this.datastore.delete(t,e);continue}yield yn(s,i,this.peerId.equals(s)?1/0:this.maxAddressAge)}}}Ke=new WeakSet,Cs=async function(e,t){try{const n=ds(e),s=await this.datastore.get(n,t),i=Jt.decode(s);if(O(this,Ke,Ts).call(this,e,i))throw await this.datastore.delete(n,t),new ho;return{peerPB:i,peer:yn(e,i,this.maxAddressAge)}}catch(n){n.name!=="NotFoundError"&&this.log.error("invalid peer data found in peer store - %e",n)}},Ls=async function(e,t,n,s){t.updated=Date.now();const i=Jt.encode(t);return await this.datastore.put(ds(e),i,s),{peer:yn(e,t,this.maxAddressAge),previous:n==null?void 0:n.peer,updated:n==null||!UE(t,n.peerPB)}},Ts=function(e,t){if(t.updated==null)return!0;if(this.peerId.equals(e))return!1;const n=t.updated<Date.now()-this.maxPeerAge,s=Date.now()-this.maxAddressAge,i=t.addresses.filter(o=>o.observed!=null&&o.observed>s);return n&&i.length===0};var xu,$r,Ds;xu=Symbol.toStringTag;class JE{constructor(e,t={}){se(this,$r);u(this,"store");u(this,"events");u(this,"peerId");u(this,"log");u(this,xu,"@libp2p/peer-store");this.log=e.logger.forComponent("libp2p:peer-store"),this.events=e.events,this.peerId=e.peerId,this.store=new QE(e,t)}async forEach(e,t){for await(const n of this.store.all(t))e(n)}async all(e){return $o(this.store.all(e))}async delete(e,t){const n=await this.store.getReadLock(e,t);try{await this.store.delete(e,t)}finally{n()}}async has(e,t){const n=await this.store.getReadLock(e,t);try{return await this.store.has(e,t)}finally{this.log.trace("has release read lock"),n==null||n()}}async get(e,t){const n=await this.store.getReadLock(e,t);try{return await this.store.load(e,t)}finally{n==null||n()}}async getInfo(e,t){const n=await this.get(e,t);return{id:n.id,multiaddrs:n.addresses.map(({multiaddr:s})=>s)}}async save(e,t,n){const s=await this.store.getWriteLock(e,n);try{const i=await this.store.save(e,t,n);return O(this,$r,Ds).call(this,e,i),i.peer}finally{s==null||s()}}async patch(e,t,n){const s=await this.store.getWriteLock(e,n);try{const i=await this.store.patch(e,t,n);return O(this,$r,Ds).call(this,e,i),i.peer}finally{s==null||s()}}async merge(e,t,n){const s=await this.store.getWriteLock(e,n);try{const i=await this.store.merge(e,t,n);return O(this,$r,Ds).call(this,e,i),i.peer}finally{s==null||s()}}async consumePeerRecord(e,t,n){const s=wn(t)?t:wn(t==null?void 0:t.expectedPeer)?t.expectedPeer:void 0,i=wn(t)||t===void 0?n:t,o=await ti.openAndCertify(e,Sn.DOMAIN,i),a=xa(o.publicKey.toCID());if((s==null?void 0:s.equals(a))===!1)return this.log("envelope peer id was not the expected peer id - expected: %p received: %p",s,a),!1;const c=Sn.createFromProtobuf(o.payload);let l;try{l=await this.get(a,i)}catch(d){if(d.name!=="NotFoundError")throw d}if((l==null?void 0:l.peerRecordEnvelope)!=null){const d=ti.createFromProtobuf(l.peerRecordEnvelope),f=Sn.createFromProtobuf(d.payload);if(f.seqNumber>=c.seqNumber)return this.log("sequence number was lower or equal to existing sequence number - stored: %d received: %d",f.seqNumber,c.seqNumber),!1}return await this.patch(c.peerId,{peerRecordEnvelope:e,addresses:c.multiaddrs.map(d=>({isCertified:!0,multiaddr:d}))},i),!0}}$r=new WeakSet,Ds=function(e,t){t.updated&&(this.peerId.equals(e)?this.events.safeDispatchEvent("self:peer:update",{detail:t}):this.events.safeDispatchEvent("peer:update",{detail:t}))};function e1(r,e={}){return new JE(r,e)}const _r=class _r extends Error{constructor(t="Not Found"){super(t);u(this,"name",_r.name);u(this,"code",_r.code)}};u(_r,"name","NotFoundError"),u(_r,"code","ERR_NOT_FOUND");let Uo=_r;function t1(r){return r[Symbol.asyncIterator]!=null}function Yc(r){if(t1(r))return(async()=>{for await(const e of r);})();for(const e of r);}function r1(r){return r[Symbol.asyncIterator]!=null}function br(r,e){let t=0;if(r1(r))return async function*(){for await(const c of r)await e(c,t++)&&(yield c)}();const n=Gw(r),{value:s,done:i}=n.next();if(i===!0)return function*(){}();const o=e(s,t++);if(typeof o.then=="function")return async function*(){await o&&(yield s);for(const c of n)await e(c,t++)&&(yield c)}();const a=e;return function*(){o===!0&&(yield s);for(const c of n)a(c,t++)&&(yield c)}()}function n1(r){return r[Symbol.asyncIterator]!=null}function Xc(r,e){return n1(r)?async function*(){yield*(await $o(r)).sort(e)}():function*(){yield*$o(r).sort(e)}()}function s1(r){return r[Symbol.asyncIterator]!=null}function Qc(r,e){return s1(r)?async function*(){let t=0;if(!(e<1)){for await(const n of r)if(yield n,t++,t===e)return}}():function*(){let t=0;if(!(e<1)){for(const n of r)if(yield n,t++,t===e)return}}()}class i1{put(e,t,n){return Promise.reject(new Error(".put is not implemented"))}get(e,t){return Promise.reject(new Error(".get is not implemented"))}has(e,t){return Promise.reject(new Error(".has is not implemented"))}delete(e,t){return Promise.reject(new Error(".delete is not implemented"))}async*putMany(e,t={}){for await(const{key:n,value:s}of e)await this.put(n,s,t),yield n}async*getMany(e,t={}){for await(const n of e)yield{key:n,value:await this.get(n,t)}}async*deleteMany(e,t={}){for await(const n of e)await this.delete(n,t),yield n}batch(){let e=[],t=[];return{put(n,s){e.push({key:n,value:s})},delete(n){t.push(n)},commit:async n=>{await Yc(this.putMany(e,n)),e=[],await Yc(this.deleteMany(t,n)),t=[]}}}async*_all(e,t){throw new Error("._all is not implemented")}async*_allKeys(e,t){throw new Error("._allKeys is not implemented")}query(e,t){let n=this._all(e,t);if(e.prefix!=null){const s=e.prefix;n=br(n,i=>i.key.toString().startsWith(s))}if(Array.isArray(e.filters)&&(n=e.filters.reduce((s,i)=>br(s,i),n)),Array.isArray(e.orders)&&(n=e.orders.reduce((s,i)=>Xc(s,i),n)),e.offset!=null){let s=0;const i=e.offset;n=br(n,()=>s++>=i)}return e.limit!=null&&(n=Qc(n,e.limit)),n}queryKeys(e,t){let n=this._allKeys(e,t);if(e.prefix!=null){const s=e.prefix;n=br(n,i=>i.toString().startsWith(s))}if(Array.isArray(e.filters)&&(n=e.filters.reduce((s,i)=>br(s,i),n)),Array.isArray(e.orders)&&(n=e.orders.reduce((s,i)=>Xc(s,i),n)),e.offset!=null){const s=e.offset;let i=0;n=br(n,()=>i++>=s)}return e.limit!=null&&(n=Qc(n,e.limit)),n}}class o1 extends i1{constructor(){super();u(this,"data");this.data=new Map}put(t,n,s){var i;return(i=s==null?void 0:s.signal)==null||i.throwIfAborted(),this.data.set(t.toString(),n),t}get(t,n){var i;(i=n==null?void 0:n.signal)==null||i.throwIfAborted();const s=this.data.get(t.toString());if(s==null)throw new Uo;return s}has(t,n){var s;return(s=n==null?void 0:n.signal)==null||s.throwIfAborted(),this.data.has(t.toString())}delete(t,n){var s;(s=n==null?void 0:n.signal)==null||s.throwIfAborted(),this.data.delete(t.toString())}*_all(t,n){var s,i;(s=n==null?void 0:n.signal)==null||s.throwIfAborted();for(const[o,a]of this.data.entries())yield{key:new Oe(o),value:a},(i=n==null?void 0:n.signal)==null||i.throwIfAborted()}*_allKeys(t,n){var s,i;(s=n==null?void 0:n.signal)==null||s.throwIfAborted();for(const o of this.data.keys())yield new Oe(o),(i=n==null?void 0:n.signal)==null||i.throwIfAborted()}}const he=r=>({match:e=>{const t=e[0];return t==null||t.code!==r||t.value!=null?!1:e.slice(1)}}),H=(r,e)=>({match:t=>{const n=t[0];return(n==null?void 0:n.code)!==r||n.value==null||e!=null&&n.value!==e?!1:t.slice(1)}}),a1=r=>({match:e=>r.match(e)===!1?e:!1}),te=r=>({match:e=>{const t=r.match(e);return t===!1?e:t}}),$e=(...r)=>({match:e=>{let t;for(const n of r){const s=n.match(e);s!==!1&&(t==null||s.length<t.length)&&(t=s)}return t??!1}}),oe=(...r)=>({match:e=>{for(const t of r){const n=t.match(e);if(n===!1)return!1;e=n}return e}});function me(...r){function e(s){if(s==null)return!1;let i=s.getComponents();for(const o of r){const a=o.match(i);if(a===!1)return!1;i=a}return i}function t(s){return e(s)!==!1}function n(s){const i=e(s);return i===!1?!1:i.length===0}return{matchers:r,matches:t,exactMatch:n}}const c1=H(Q),u1=me(c1),Ci=H(ld),Li=H(dd),Ti=H(fd),Ha=H(ud);me(Ci,te(H(Q)));me(Li,te(H(Q)));me(Ti,te(H(Q)));const Fx=me($e(Ha,Ti,Ci,Li),te(H(Q))),Rf=oe(H(Hs),te(H(Sa))),Bf=oe(te(H(cd)),H(Ws),te(H(Sa))),Wa=$e(Rf,Bf),lr=$e(Wa,Ha,Ci,Li,Ti),Ox=me($e(Wa,oe($e(Ha,Ti,Ci,Li),te(H(Q))))),Jc=me(Rf),eu=me(Bf),$x=me(Wa),Ga=oe(lr,H(Dr)),Xn=oe(lr,H(ad)),zo=me(oe(Ga,te(H(Q))));me(Xn);const Za=oe(Xn,he(gd),te(H(Q))),Di=oe(Xn,he(md),te(H(Q))),l1=$e(Za,Di);me(Za);const d1=me(Di),qo=$e(lr,Ga,Xn,Za,Di),Ff=$e(oe(qo,he(_a),te(H(Q)))),ii=me(Ff),Of=$e(oe(qo,he(yd),te(H(Q))),oe(qo,he(kr),te(H(Gs)),he(_a),te(H(Q)))),Ko=me(Of),$f=oe(Xn,he(wd),te(H(Dn)),te(H(Dn)),te(H(Q))),tu=me($f),Uf=oe(Di,he(pd),te(H(Dn)),te(H(Dn)),te(H(Q))),ru=me(Uf),oi=$e(Ff,Of,oe(Ga,te(H(Q))),oe(l1,te(H(Q))),oe(lr,te(H(Q))),$f,Uf,H(Q)),Ux=me(oi),f1=oe(te(oi),he(Aa),a1(he(vn)),te(H(Q))),ai=me(f1),h1=$e(oe(oi,he(Aa),he(vn),te(H(Q))),oe(oi,he(vn),te(H(Q))),oe(he(vn),te(H(Q)))),nu=me(h1),g1=$e(oe(lr,H(Dr),he(Pr),te(H(Q))),oe(lr,he(Pr),te(H(Q))));me(g1);const m1=oe(lr,$e(oe(H(Dr,"443"),he(Pr)),oe(H(Dr),he(Do)),oe(H(Dr),he(kr),he(Pr)),oe(he(kr),he(Pr)),he(kr),he(Do)),te(H(Q)));me(m1);const p1=$e(oe(H(bd),te(H(Q))));me(p1);const y1=$e(oe(H(hd),te(H(Q))));me(y1);const su=864e13;class w1{constructor(e,t={}){u(this,"log");u(this,"mappings");this.log=e.logger.forComponent("libp2p:address-manager:dns-mappings"),this.mappings=Dt({name:"libp2p_address_manager_dns_mappings",metrics:e.metrics})}has(e){const t=le(e);let n=t.host;(t.type==="ip4"||t.type==="ip6")&&t.sni!=null&&(n=t.sni);for(const s of this.mappings.values())if(s.domain===n)return!0;return!1}add(e,t){t.forEach(n=>{this.log("add DNS mapping %s to %s",n,e);const s=za(n)===!0;this.mappings.set(n,{domain:e,verified:s,expires:s?su-Date.now():0,lastVerified:s?su-Date.now():void 0})})}remove(e){const t=le(e);if(t.type!=="ip4"&&t.type!=="ip6")return!1;let n=!1;for(const[s,i]of this.mappings.entries())i.domain===t.sni&&(this.log("removing %s to %s DNS mapping %e",s,i.domain),this.mappings.delete(s),n=n||i.verified);return n}getAll(e){const t=[];for(let n=0;n<e.length;n++){const s=e[n].multiaddr;if(!ot(s))continue;const i=le(s);for(const[o,a]of this.mappings.entries()){if(i.host!==o)continue;const c=this.maybeAddSNIComponent(s,a.domain);c!=null&&(e.splice(n,1),n--,t.push({multiaddr:c,verified:a.verified,type:"dns-mapping",expires:a.expires,lastVerified:a.lastVerified}))}}return t}maybeAddSNIComponent(e,t){var s;const n=e.getComponents();for(let i=0;i<n.length;i++)if(n[i].code===kr&&((s=n[i+1])==null?void 0:s.code)!==Gs)return n.splice(i+1,0,{name:"sni",code:Gs,value:t}),Ee(n)}confirm(e,t){const n=le(e);let s=n.host;(n.type==="ip4"||n.type==="ip6")&&n.sni!=null&&(s=n.sni);let i=!1;for(const[o,a]of this.mappings.entries())a.domain===s&&(this.log("marking %s to %s DNS mapping as verified",o,a.domain),i=a.verified,a.verified=!0,a.expires=Date.now()+t,a.lastVerified=Date.now());return i}unconfirm(e,t){const n=le(e);if(n.type!=="ip4"&&n.type!=="ip6")return!1;const s=n.sni??n.host;let i=!1;for(const[o,a]of this.mappings.entries())a.domain===s&&(this.log("removing verification of %s to %s DNS mapping",o,a.domain),i=i||a.verified,a.verified=!1,a.expires=Date.now()+t);return i}}class b1{constructor(e,t={}){u(this,"log");u(this,"mappings");this.log=e.logger.forComponent("libp2p:address-manager:ip-mappings"),this.mappings=Dt({name:"libp2p_address_manager_ip_mappings",metrics:e.metrics})}has(e){const t=le(e);if(t.type!=="ip4"&&t.type!=="ip6")return!1;for(const n of this.mappings.values())for(const s of n)if(s.externalIp===t.host)return!0;return!1}add(e,t,n,s=t,i="tcp"){const o=`${e}-${t}-${i}`,a=this.mappings.get(o)??[],c={internalIp:e,internalPort:t,externalIp:n,externalPort:s,externalFamily:Wr(n)?4:6,protocol:i,verified:!1,expires:0};a.push(c),this.mappings.set(o,a)}remove(e){const t=le(e);if(t.type!=="ip4"&&t.type!=="ip6")return!1;let n=!1;for(const[s,i]of this.mappings.entries()){for(let o=0;o<i.length;o++){const a=i[o];a.externalIp===t.host&&a.externalPort===t.port&&a.protocol===t.protocol&&(this.log("removing %s:%s to %s:%s %s IP mapping",a.externalIp,a.externalPort,t.host,t.port,t.protocol),n=n||a.verified,i.splice(o,1),o--)}i.length===0&&this.mappings.delete(s)}return n}getAll(e){const t=[];for(const{multiaddr:n}of e){if(!ot(n))continue;const s=le(n);if(s.type!=="ip4"&&s.type!=="ip6")continue;let i;if(s.protocol==="tcp"?i=`${s.host}-${s.port}-tcp`:s.protocol==="udp"&&(i=`${s.host}-${s.port}-udp`),i==null)continue;const o=this.mappings.get(i);if(o!=null)for(const a of o)t.push({multiaddr:this.maybeOverrideIp(n,a.externalIp,a.externalFamily,a.protocol,a.externalPort),verified:a.verified,type:"ip-mapping",expires:a.expires,lastVerified:a.lastVerified})}return t}maybeOverrideIp(e,t,n,s,i){const o=e.getComponents(),a=o.findIndex(l=>l.code===Hs||l.code===Ws),c=o.findIndex(l=>l.name===s);return a>-1&&c>-1?(o[a].value=t,o[a].code=n===4?Hs:Ws,o[c].value=`${i}`,Ee(o)):e}confirm(e,t){if(!ot(e))return!1;const n=le(e);let s=!1;for(const i of this.mappings.values())for(const o of i)o.externalIp===n.host&&(this.log("marking %s to %s IP mapping as verified",o.internalIp,o.externalIp),s=o.verified,o.verified=!0,o.expires=Date.now()+t,o.lastVerified=Date.now());return s}unconfirm(e,t){if(!ot(e))return!1;const n=le(e);let s=!1;for(const i of this.mappings.values())for(let o=0;o<i.length;o++){const a=i[o];a.externalIp===n.host&&a.externalPort===n.port&&a.protocol===n.protocol&&(this.log("removing verification of %s:%s to %s:%s %s IP mapping",a.externalIp,a.externalPort,n.host,n.port,n.protocol),s=s||a.verified,a.verified=!1,a.expires=Date.now()+t)}return s}}const E1={maxObservedAddresses:10};class v1{constructor(e,t={}){u(this,"log");u(this,"addresses");u(this,"maxObservedAddresses");this.log=e.logger.forComponent("libp2p:address-manager:observed-addresses"),this.addresses=Dt({name:"libp2p_address_manager_observed_addresses",metrics:e.metrics}),this.maxObservedAddresses=t.maxObservedAddresses??E1.maxObservedAddresses}has(e){return this.addresses.has(e.toString())}removePrefixed(e){for(const t of this.addresses.keys())t.toString().startsWith(e)&&this.addresses.delete(t)}add(e){this.addresses.size!==this.maxObservedAddresses&&(Fn(e)||hb(e)||(this.log("adding observed address %a",e),this.addresses.set(e.toString(),{verified:!1,expires:0})))}getAll(){return Array.from(this.addresses).map(([e,t])=>({multiaddr:Ee(e),verified:t.verified,type:"observed",expires:t.expires,lastVerified:t.lastVerified}))}remove(e){var n;const t=((n=this.addresses.get(e.toString()))==null?void 0:n.verified)??!1;return this.log("removing observed address %a",e),this.addresses.delete(e.toString()),t}confirm(e,t){const n=e.toString(),s=this.addresses.get(n)??{verified:!1,expires:Date.now()+t,lastVerified:Date.now()},i=s.verified;return s.verified=!0,s.expires=Date.now()+t,s.lastVerified=Date.now(),this.log("marking observed address %a as verified",n),this.addresses.set(n,s),i}}const x1={maxObservedAddresses:10};class S1{constructor(e,t={}){u(this,"log");u(this,"addresses");u(this,"maxObservedAddresses");this.log=e.logger.forComponent("libp2p:address-manager:observed-addresses"),this.addresses=Dt({name:"libp2p_address_manager_transport_addresses",metrics:e.metrics}),this.maxObservedAddresses=t.maxObservedAddresses??x1.maxObservedAddresses}get(e,t){if(Fn(e))return{multiaddr:e,verified:!0,type:"transport",expires:Date.now()+t,lastVerified:Date.now()};const n=this.toKey(e);let s=this.addresses.get(n);return s==null&&(s={verified:!ot(e),expires:0},this.addresses.set(n,s)),{multiaddr:e,verified:s.verified,type:"transport",expires:s.expires,lastVerified:s.lastVerified}}has(e){const t=this.toKey(e);return this.addresses.has(t)}remove(e){var s;const t=this.toKey(e),n=((s=this.addresses.get(t))==null?void 0:s.verified)??!1;return this.log("removing observed address %a",e),this.addresses.delete(t),n}confirm(e,t){const n=this.toKey(e),s=this.addresses.get(n)??{verified:!1,expires:0,lastVerified:0},i=s.verified;return s.verified=!0,s.expires=Date.now()+t,s.lastVerified=Date.now(),this.addresses.set(n,s),i}unconfirm(e,t){const n=this.toKey(e),s=this.addresses.get(n)??{verified:!1,expires:0},i=s.verified;return s.verified=!1,s.expires=Date.now()+t,this.addresses.set(n,s),i}toKey(e){if(!ot(e))return e.toString();const t=le(e);return`${t.host}-${t.port}-${t.protocol}`}}const iu=6e4,ou={addressVerificationTTL:iu*10,addressVerificationRetry:iu*5},_1=r=>r;function eo(r,e){var n;const t=(n=r.getComponents().findLast(s=>s.code===Q))==null?void 0:n.value;return t!=null&&Kr(t).equals(e)&&(r=r.decapsulate(Ee(`/p2p/${e.toString()}`))),r}var Su;Su=Symbol.toStringTag;class A1{constructor(e,t={}){u(this,"log");u(this,"components");u(this,"listen");u(this,"announce");u(this,"appendAnnounce");u(this,"announceFilter");u(this,"observed");u(this,"dnsMappings");u(this,"ipMappings");u(this,"transportAddresses");u(this,"observedAddressFilter");u(this,"addressVerificationTTL");u(this,"addressVerificationRetry");u(this,Su,"@libp2p/address-manager");const{listen:n=[],announce:s=[],appendAnnounce:i=[]}=t;this.components=e,this.log=e.logger.forComponent("libp2p:address-manager"),this.listen=n.map(o=>o.toString()),this.announce=new Set(s.map(o=>o.toString())),this.appendAnnounce=new Set(i.map(o=>o.toString())),this.observed=new v1(e,t),this.dnsMappings=new w1(e,t),this.ipMappings=new b1(e,t),this.transportAddresses=new S1(e,t),this.announceFilter=t.announceFilter??_1,this.observedAddressFilter=$a(1024),this.addressVerificationTTL=t.addressVerificationTTL??ou.addressVerificationTTL,this.addressVerificationRetry=t.addressVerificationRetry??ou.addressVerificationRetry,this._updatePeerStoreAddresses=Xs(this._updatePeerStoreAddresses.bind(this),1e3),e.events.addEventListener("transport:listening",()=>{this._updatePeerStoreAddresses()}),e.events.addEventListener("transport:close",()=>{this._updatePeerStoreAddresses()})}_updatePeerStoreAddresses(){const e=this.getAddresses().map(t=>{var n;return((n=t.getComponents().findLast(s=>s.code===Q))==null?void 0:n.value)===this.components.peerId.toString()?t.decapsulate(`/p2p/${this.components.peerId.toString()}`):t});this.components.peerStore.patch(this.components.peerId,{multiaddrs:e}).catch(t=>{this.log.error("error updating addresses - %e",t)})}getListenAddrs(){return Array.from(this.listen).map(e=>Ee(e))}getAnnounceAddrs(){return Array.from(this.announce).map(e=>Ee(e))}getAppendAnnounceAddrs(){return Array.from(this.appendAnnounce).map(e=>Ee(e))}getObservedAddrs(){return this.observed.getAll().map(e=>e.multiaddr)}addObservedAddr(e){const t=le(e);let n;switch(t.type){case"ip4":{n=`${t.host}:${t.port}`;break}case"ip6":{n=`[${t.host}]:${t.port}`;break}default:return}this.observedAddressFilter.has(n)||(this.observedAddressFilter.add(n),e=eo(e,this.components.peerId),!this.ipMappings.has(e)&&(this.dnsMappings.has(e)||this.observed.add(e)))}confirmObservedAddr(e,t){e=eo(e,this.components.peerId);let n=!0;((t==null?void 0:t.type)==="transport"||this.transportAddresses.has(e))&&!this.transportAddresses.confirm(e,(t==null?void 0:t.ttl)??this.addressVerificationTTL)&&n&&(n=!1),((t==null?void 0:t.type)==="dns-mapping"||this.dnsMappings.has(e))&&!this.dnsMappings.confirm(e,(t==null?void 0:t.ttl)??this.addressVerificationTTL)&&n&&(n=!1),((t==null?void 0:t.type)==="ip-mapping"||this.ipMappings.has(e))&&!this.ipMappings.confirm(e,(t==null?void 0:t.ttl)??this.addressVerificationTTL)&&n&&(n=!1),((t==null?void 0:t.type)==="observed"||this.observed.has(e))&&(this.maybeUpgradeToIPMapping(e)?(this.ipMappings.confirm(e,(t==null?void 0:t.ttl)??this.addressVerificationTTL),n=!1):!this.observed.confirm(e,(t==null?void 0:t.ttl)??this.addressVerificationTTL)&&n&&(n=!1)),n||this._updatePeerStoreAddresses()}removeObservedAddr(e,t){e=eo(e,this.components.peerId),this.observed.has(e)&&this.observed.remove(e),this.transportAddresses.has(e)&&this.transportAddresses.unconfirm(e,(t==null?void 0:t.ttl)??this.addressVerificationRetry),this.dnsMappings.has(e)&&this.dnsMappings.unconfirm(e,(t==null?void 0:t.ttl)??this.addressVerificationRetry),this.ipMappings.has(e)&&this.ipMappings.unconfirm(e,(t==null?void 0:t.ttl)??this.addressVerificationRetry)}getAddresses(){const e=new Set,t=this.getAddressesWithMetadata().filter(n=>{if(!n.verified)return!1;const s=n.multiaddr.toString();return e.has(s)?!1:(e.add(s),!0)}).map(n=>n.multiaddr);return this.announceFilter(t.map(n=>{const s=Ee(n),i=s.getComponents().pop();return(i==null?void 0:i.value)===this.components.peerId.toString()?s:s.encapsulate(`/p2p/${this.components.peerId.toString()}`)}))}getAddressesWithMetadata(){const e=this.getAnnounceAddrs();if(e.length>0)return this.components.transportManager.getListeners().forEach(s=>{s.updateAnnounceAddrs(e)}),e.map(s=>({multiaddr:s,verified:!0,type:"announce",expires:Date.now()+this.addressVerificationTTL,lastVerified:Date.now()}));let t=[];t=t.concat(this.components.transportManager.getAddrs().map(s=>this.transportAddresses.get(s,this.addressVerificationTTL)));const n=this.getAppendAnnounceAddrs();return n.length>0&&(this.components.transportManager.getListeners().forEach(s=>{s.updateAnnounceAddrs(n)}),t=t.concat(n.map(s=>({multiaddr:s,verified:!0,type:"announce",expires:Date.now()+this.addressVerificationTTL,lastVerified:Date.now()})))),t=t.concat(this.observed.getAll()),t=t.concat(this.ipMappings.getAll(t)),t=t.concat(this.dnsMappings.getAll(t)),t}addDNSMapping(e,t){this.dnsMappings.add(e,t)}removeDNSMapping(e){this.dnsMappings.remove(Ee(`/dns/${e}`))&&this._updatePeerStoreAddresses()}addPublicAddressMapping(e,t,n,s=t,i="tcp"){this.ipMappings.add(e,t,n,s,i),this.observed.removePrefixed(`/ip${Wr(n)?4:6}/${n}/${i}/${s}`)}removePublicAddressMapping(e,t,n,s=t,i="tcp"){this.ipMappings.remove(Ee(`/ip${Wr(n)?4:6}/${n}/${i}/${s}`))&&this._updatePeerStoreAddresses()}maybeUpgradeToIPMapping(e){if(this.ipMappings.has(e)||!ot(e))return!1;const t=le(e);if(t.type!=="ip4"||za(t.host)===!0)return!1;const n=this.components.transportManager.getListeners(),s=[i=>ii.exactMatch(i)||Ko.exactMatch(i),i=>zo.exactMatch(i),i=>d1.exactMatch(i)];for(const i of s){if(!i(e))continue;const o=n.filter(l=>l.getAddrs().filter(d=>le(d).type==="ip4"&&i(d)).length>0);if(o.length!==1)continue;const a=o[0].getAddrs().filter(l=>!Fo(l)).pop();if(a==null)continue;const c=le(a);return c.port==null?!1:(this.observed.remove(e),this.ipMappings.add(c.host,c.port,t.host,t.port,t.protocol),!0)}return!1}}var au;(function(r){r.NOT_STARTED_YET="The libp2p node is not started yet",r.NOT_FOUND="Not found"})(au||(au={}));class I1 extends Error{constructor(e="Missing service"){super(e),this.name="MissingServiceError"}}class C1 extends Error{constructor(e="Unmet service dependencies"){super(e),this.name="UnmetServiceDependenciesError"}}class to extends Error{constructor(e="No content routers available"){super(e),this.name="NoContentRoutersError"}}class cu extends Error{constructor(e="No peer routers available"){super(e),this.name="NoPeerRoutersError"}}class L1 extends Error{constructor(e="Should not try to find self"){super(e),this.name="QueriedForSelfError"}}class T1 extends Error{constructor(e="Unhandled protocol error"){super(e),this.name="UnhandledProtocolError"}}class D1 extends Error{constructor(e="Duplicate protocol handler error"){super(e),this.name="DuplicateProtocolHandlerError"}}class uu extends Error{constructor(e="Dial denied error"){super(e),this.name="DialDeniedError"}}class k1 extends Error{constructor(e="No transport was configured to listen on this address"){super(e),this.name="UnsupportedListenAddressError"}}class P1 extends Error{constructor(e="Configured listen addresses could not be listened on"){super(e),this.name="UnsupportedListenAddressesError"}}class M1 extends Error{constructor(e="No valid addresses"){super(e),this.name="NoValidAddressesError"}}class N1 extends Error{constructor(e="Connection intercepted"){super(e),this.name="ConnectionInterceptedError"}}class R1 extends Error{constructor(e="Connection denied"){super(e),this.name="ConnectionDeniedError"}}class ks extends Error{constructor(e="Stream is not multiplexed"){super(e),this.name="MuxerUnavailableError"}}class hs extends Error{constructor(e="Encryption failed"){super(e),this.name="EncryptionFailedError"}}class B1 extends Error{constructor(e="Transport unavailable"){super(e),this.name="TransportUnavailableError"}}class F1 extends Error{constructor(e="Max recursive depth reached"){super(e),this.name="RecursionLimitError"}}class O1{constructor(e={}){u(this,"components",{});u(this,"_started",!1);this.components={};for(const[t,n]of Object.entries(e))this.components[t]=n;this.components.logger==null&&(this.components.logger=_d())}isStarted(){return this._started}async _invokeStartableMethod(e){await Promise.all(Object.values(this.components).filter(t=>ea(t)).map(async t=>{var n;await((n=t[e])==null?void 0:n.call(t))}))}async beforeStart(){await this._invokeStartableMethod("beforeStart")}async start(){await this._invokeStartableMethod("start"),this._started=!0}async afterStart(){await this._invokeStartableMethod("afterStart")}async beforeStop(){await this._invokeStartableMethod("beforeStop")}async stop(){await this._invokeStartableMethod("stop"),this._started=!1}async afterStop(){await this._invokeStartableMethod("afterStop")}}const $1=["metrics","connectionProtector","dns"],U1=["components","isStarted","beforeStart","start","afterStart","beforeStop","stop","afterStop","then","_invokeStartableMethod"];function z1(r={}){const e=new O1(r);return new Proxy(e,{get(n,s,i){if(typeof s=="string"&&!U1.includes(s)){const o=e.components[s];if(o==null&&!$1.includes(s))throw new I1(`${s} not set`);return o}return Reflect.get(n,s,i)},set(n,s,i){return typeof s=="string"?e.components[s]=i:Reflect.set(n,s,i),!0}})}function q1(r){const e={};for(const t of Object.values(r.components))for(const n of K1(t))e[n]=!0;for(const t of Object.values(r.components))for(const n of V1(t))if(e[n]!==!0)throw new C1(`Service "${H1(t)}" required capability "${n}" but it was not provided by any component, you may need to add additional configuration when creating your node.`)}function K1(r){return Array.isArray(r==null?void 0:r[mo])?r[mo]:[]}function V1(r){return Array.isArray(r==null?void 0:r[rc])?r[rc]:[]}function H1(r){return(r==null?void 0:r[Symbol.toStringTag])??(r==null?void 0:r.toString())??"unknown"}function W1(r={}){return r.denyDialMultiaddr==null&&(r.denyDialMultiaddr=e=>ii.matches(e)?!0:Fn(e)),r}class He extends Event{constructor(t,n){super(t);u(this,"type");u(this,"detail");this.type=t,this.detail=n}}function zf(r){var n;if(wn(r))return{peerId:r,multiaddrs:[]};let e=Array.isArray(r)?r:[r],t;if(e.length>0){const s=(n=e[0].getComponents().findLast(i=>i.code===Q))==null?void 0:n.value;t=s==null?void 0:Kr(s),e.forEach(i=>{var a;if(!xi(i))throw new Qo("Invalid multiaddr");const o=(a=i.getComponents().findLast(c=>c.code===Q))==null?void 0:a.value;if(o==null){if(t!=null)throw new Z("Multiaddrs must all have the same peer id or have no peer id")}else{const c=Kr(o);if((t==null?void 0:t.equals(c))!==!0)throw new Z("Multiaddrs must all have the same peer id or have no peer id")}})}return e=e.filter(s=>!u1.exactMatch(s)),{peerId:t,multiaddrs:e}}const G1=["/ipfs/id/1.0.0","/ipfs/id/push/1.0.0","/libp2p/autonat/1.0.0","/libp2p/dcutr"];async function Z1(r,e){var s;const t=((s=r==null?void 0:r.streams)==null?void 0:s.map(i=>i.protocol))??[],n=(e==null?void 0:e.closableProtocols)??G1;if(!(t.filter(i=>i!=null&&!n.includes(i)).length>0))try{await(r==null?void 0:r.close(e))}catch(i){r==null||r.abort(i)}}function Vo(r){const e=le(r);let t=e.cidr;if(e.type!=="ip4"&&e.type!=="ip6")throw new Z(`Multiaddr ${r} was not an IPv4 or IPv6 address`);if(t==null)switch(e.type){case"ip4":{t=32;break}case"ip6":{t=128;break}default:throw new Z(`Multiaddr ${r} was not an IPv4 or IPv6 address`)}return new Qd(e.host,t)}function qf(r){return!ai.exactMatch(r)}function Kf(r,e,t){if(r==null||e==null)return;const n=e.sort((i,o)=>i.direct?-1:o.direct?1:0).find(i=>i.limits==null);if(n==null||n.direct||t==null)return n;if(!t.some(i=>qf(i)))return n}class j1{constructor(e,t={}){u(this,"connectionManager");u(this,"peerStore");u(this,"allow");u(this,"events");u(this,"log");this.allow=(t.allow??[]).map(n=>Vo(n)),this.connectionManager=e.connectionManager,this.peerStore=e.peerStore,this.events=e.events,this.log=e.logger.forComponent("libp2p:connection-manager:connection-pruner"),this.maybePruneConnections=this.maybePruneConnections.bind(this)}start(){this.events.addEventListener("connection:open",this.maybePruneConnections)}stop(){this.events.removeEventListener("connection:open",this.maybePruneConnections)}maybePruneConnections(){this._maybePruneConnections().catch(e=>{this.log.error("error while pruning connections - %e",e)})}async _maybePruneConnections(){const e=this.connectionManager.getConnections(),t=e.length,n=this.connectionManager.getMaxConnections();if(this.log("checking max connections limit %d/%d",t,n),t<=n)return;const s=new jn;for(const c of e){const l=c.remotePeer;if(!s.has(l)){s.set(l,0);try{const d=await this.peerStore.get(l);s.set(l,[...d.tags.values()].reduce((f,h)=>f+h.value,0))}catch(d){d.name!=="NotFoundError"&&this.log.error("error loading peer tags - %e",d)}}}const i=this.sortConnections(e,s),o=Math.max(t-n,0),a=[];for(const c of i)if(this.log("too many connections open - closing a connection to %p",c.remotePeer),this.allow.some(d=>{if(ot(c.remoteAddr)){const f=le(c.remoteAddr);return d.contains(f.host)}return!0})||a.push(c),a.length===o)break;await Promise.all(a.map(async c=>{await Z1(c,{signal:AbortSignal.timeout(1e3)})})),this.events.safeDispatchEvent("connection:prune",{detail:a})}sortConnections(e,t){return e.sort((n,s)=>{const i=n.timeline.open,o=s.timeline.open;return i<o?1:i>o?-1:0}).sort((n,s)=>n.direction==="outbound"&&s.direction==="inbound"?1:n.direction==="inbound"&&s.direction==="outbound"?-1:0).sort((n,s)=>n.streams.length>s.streams.length?1:n.streams.length<s.streams.length?-1:0).sort((n,s)=>{const i=t.get(n.remotePeer)??0,o=t.get(s.remotePeer)??0;return i>o?1:i<o?-1:0})}}const Vf=1e4,Hf=1e3,Y1=1e4,ci=1e4,Wf=25,X1=5,Q1=10,J1=5,ev="last-dial-failure",tv="last-dial-success",Gf=500,rv=32,nv=100,Zf=50;function sv(r,e){const t=zo.exactMatch(r.multiaddr),n=zo.exactMatch(e.multiaddr);if(t&&!n)return-1;if(!t&&n)return 1;const s=Ko.exactMatch(r.multiaddr),i=Ko.exactMatch(e.multiaddr);if(s&&!i)return-1;if(!s&&i)return 1;const o=ii.exactMatch(r.multiaddr),a=ii.exactMatch(e.multiaddr);if(o&&!a)return-1;if(!o&&a)return 1;const c=nu.exactMatch(r.multiaddr),l=nu.exactMatch(e.multiaddr);if(c&&!l)return-1;if(!c&&l)return 1;const d=tu.exactMatch(r.multiaddr),f=tu.exactMatch(e.multiaddr);if(d&&!f)return-1;if(!d&&f)return 1;const h=ru.exactMatch(r.multiaddr),p=ru.exactMatch(e.multiaddr);return h&&!p?-1:!h&&p?1:0}function iv(r,e){const t=Fo(r.multiaddr),n=Fo(e.multiaddr);return t&&!n?1:!t&&n?-1:0}function ov(r,e){const t=Fn(r.multiaddr),n=Fn(e.multiaddr);return t&&!n?1:!t&&n?-1:0}function av(r,e){return r.isCertified&&!e.isCertified?-1:!r.isCertified&&e.isCertified?1:0}function cv(r,e){const t=ai.exactMatch(r.multiaddr),n=ai.exactMatch(e.multiaddr);return t&&!n?1:!t&&n?-1:0}function uv(r){return r.sort(sv).sort(av).sort(cv).sort(ov).sort(iv)}class jf extends AggregateError{constructor(){super(...arguments);u(this,"name","DNSQueryFailedError")}}u(jf,"name","DNSQueryFailedError");function Yf(r){const e=[Vt.A];return r==null?e:Array.isArray(r)?r.length===0?e:r:[r]}const Xf=60;function Qf(r){return{Status:r.Status??0,TC:r.TC??r.flag_tc??!1,RD:r.RD??r.flag_rd??!1,RA:r.RA??r.flag_ra??!1,AD:r.AD??r.flag_ad??!1,CD:r.CD??r.flag_cd??!1,Question:(r.Question??r.questions??[]).map(e=>({name:e.name,type:Vt[e.type]})),Answer:(r.Answer??r.answers??[]).map(e=>({name:e.name,type:Vt[e.type],TTL:e.TTL??e.ttl??Xf,data:e.data instanceof Uint8Array?X(e.data):e.data}))}}const lv=4;function lu(r,e={}){const t=new Ww({concurrency:e.queryConcurrency??lv});return async(n,s={})=>{var c,l;const i=(c=s==null?void 0:s.logger)==null?void 0:c.forComponent("dns:dns-json-over-https"),o=new URLSearchParams;o.set("name",n),Yf(s.types).forEach(d=>{o.append("type",Vt[d])}),(l=s.onProgress)==null||l.call(s,new He("dns:query",n)),i==null||i("GET %s",`${r}?${o}`);const a=await t.add(async()=>{var h;const d=await fetch(`${r}?${o}`,{headers:{accept:"application/dns-json"},signal:s==null?void 0:s.signal});if(i==null||i("GET %s %d",d.url,d.status),d.status!==200)throw new Error(`Unexpected HTTP status: ${d.status} - ${d.statusText}`);const f=Qf(await d.json());return(h=s.onProgress)==null||h.call(s,new He("dns:response",f)),f},{signal:s.signal});if(a==null)throw new Error("No DNS response received");return a}}function dv(){return[lu("https://cloudflare-dns.com/dns-query"),lu("https://dns.google/resolve")]}var fv=function(r){if(!r)throw Error("hashlru must have a max value, of type number, greater than 0");var e=0,t=Object.create(null),n=Object.create(null);function s(i,o){t[i]=o,e++,e>=r&&(e=0,n=t,t=Object.create(null))}return{has:function(i){return t[i]!==void 0||n[i]!==void 0},remove:function(i){t[i]!==void 0&&(t[i]=void 0),n[i]!==void 0&&(n[i]=void 0)},get:function(i){var o=t[i];if(o!==void 0)return o;if((o=n[i])!==void 0)return s(i,o),o},set:function(i,o){t[i]!==void 0?t[i]=o:s(i,o)},clear:function(){t=Object.create(null),n=Object.create(null)}}};const hv=Fu(fv);class gv{constructor(e){u(this,"lru");this.lru=hv(e)}get(e,t){let n=!0;const s=[];for(const i of t){const o=this.getAnswers(e,i);if(o.length===0){n=!1;break}s.push(...o)}if(n)return Qf({answers:s})}getAnswers(e,t){const n=`${e.toLowerCase()}-${t}`,s=this.lru.get(n);if(s!=null){const i=s.filter(o=>o.expires>Date.now()).map(({expires:o,value:a})=>({...a,TTL:Math.round((o-Date.now())/1e3),type:Vt[a.type]}));return i.length===0&&this.lru.remove(n),i}return[]}add(e,t){const n=`${e.toLowerCase()}-${t.type}`,s=this.lru.get(n)??[];s.push({expires:Date.now()+(t.TTL??Xf)*1e3,value:t}),this.lru.set(n,s)}remove(e,t){const n=`${e.toLowerCase()}-${t}`;this.lru.remove(n)}clear(){this.lru.clear()}}function mv(r){return new gv(r)}const pv=1e3;class yv{constructor(e){u(this,"resolvers");u(this,"cache");u(this,"logger");this.resolvers={},this.cache=mv(e.cacheSize??pv),this.logger=e.logger,Object.entries(e.resolvers??{}).forEach(([t,n])=>{Array.isArray(n)||(n=[n]),t.endsWith(".")||(t=`${t}.`),this.resolvers[t]=n}),this.resolvers["."]==null&&(this.resolvers["."]=dv())}async query(e,t={}){var c,l,d;const n=Yf(t.types),s=t.cached!==!1?this.cache.get(e,n):void 0;if(s!=null)return(c=t.onProgress)==null||c.call(t,new He("dns:cache",s)),s;const i=`${e.split(".").pop()}.`,o=(this.resolvers[i]??this.resolvers["."]).sort(()=>Math.random()>.5?-1:1),a=[];for(const f of o){if(((l=t.signal)==null?void 0:l.aborted)===!0)break;try{const h=await f(e,{...t,logger:this.logger,types:n});for(const p of h.Answer)this.cache.add(e,p);return h}catch(h){a.push(h),(d=t.onProgress)==null||d.call(t,new He("dns:error",h))}}throw new jf(a,`DNS lookup of ${e} ${n} failed`)}}var Vt;(function(r){r[r.A=1]="A",r[r.CNAME=5]="CNAME",r[r.TXT=16]="TXT",r[r.AAAA=28]="AAAA"})(Vt||(Vt={}));function wv(r={}){return new yv(r)}class bv{constructor(){u(this,"dns")}canResolve(e){return e.getComponents().some(({name:t})=>t==="dnsaddr")}async resolve(e,t){var c,l;const n=(c=e.getComponents().find(d=>d.name==="dnsaddr"))==null?void 0:c.value;if(n==null)return[e];const i=await this.getDNS(t).query(`_dnsaddr.${n}`,{signal:t==null?void 0:t.signal,types:[Vt.TXT]}),o=(l=e.getComponents().find(d=>d.name==="p2p"))==null?void 0:l.value,a=[];for(const d of i.Answer){const f=d.data.replace(/["']/g,"").trim().split("=")[1];f!=null&&(o!=null&&!f.includes(o)||a.push(Ee(f)))}return a}getDNS(e){return e.dns!=null?e.dns:(this.dns==null&&(this.dns=wv()),this.dns)}}const Jf=new bv;async function eh(r,e,t){const n=t.depth??0;if(n>(t.maxRecursiveDepth??rv))throw new F1("Max recursive depth reached");let s=!1;const i=[];for(const o of Object.values(e))if(o.canResolve(r)){s=!0;const a=await o.resolve(r,t);for(const c of a)i.push(...await eh(c,e,{...t,depth:n+1}))}return s===!1&&i.push(r),i}const gn={maxParallelDials:Zf,maxDialQueueLength:Gf,maxPeerAddrsToDial:Wf,dialTimeout:Vf,resolvers:{dnsaddr:Jf}};class Ev{constructor(e,t={}){u(this,"queue");u(this,"components");u(this,"addressSorter");u(this,"maxPeerAddrsToDial");u(this,"maxDialQueueLength");u(this,"dialTimeout");u(this,"shutDownController");u(this,"connections");u(this,"log");u(this,"resolvers");this.addressSorter=t.addressSorter,this.maxPeerAddrsToDial=t.maxPeerAddrsToDial??gn.maxPeerAddrsToDial,this.maxDialQueueLength=t.maxDialQueueLength??gn.maxDialQueueLength,this.dialTimeout=t.dialTimeout??gn.dialTimeout,this.connections=t.connections??new jn,this.log=e.logger.forComponent("libp2p:connection-manager:dial-queue"),this.components=e,this.resolvers=t.resolvers??gn.resolvers,this.shutDownController=new AbortController,this.shutDownController.signal,this.queue=new hE({concurrency:t.maxParallelDials??gn.maxParallelDials,metricName:"libp2p_dial_queue",metrics:e.metrics}),this.queue.addEventListener("failure",n=>{var s;((s=n.detail)==null?void 0:s.error.name)!==_n.name&&this.log.error("error in dial queue - %e",n.detail.error)})}start(){this.shutDownController=new AbortController,this.shutDownController.signal}stop(){this.shutDownController.abort(),this.queue.abort()}async dial(e,t={}){var o,a,c;const{peerId:n,multiaddrs:s}=zf(e);if(n!=null&&t.force!==!0){const l=Kf(n,this.connections.get(n),s);if(l!=null)return this.log("already connected to %a",l.remoteAddr),(o=t.onProgress)==null||o.call(t,new He("dial-queue:already-connected")),l}const i=this.queue.queue.find(l=>{if((n==null?void 0:n.equals(l.options.peerId))===!0)return!0;const d=l.options.multiaddrs;if(d==null)return!1;for(const f of s)if(d.has(f.toString()))return!0;return!1});if(i!=null){this.log("joining existing dial target for %p",n);for(const l of s)i.options.multiaddrs.add(l.toString());return(a=t.onProgress)==null||a.call(t,new He("dial-queue:already-in-dial-queue")),i.join(t)}if(this.queue.size>=this.maxDialQueueLength)throw new ps("Dial queue is full");return this.log("creating dial target for %p",n,s.map(l=>l.toString())),(c=t.onProgress)==null||c.call(t,new He("dial-queue:add-to-dial-queue")),this.queue.add(async l=>{var f;(f=l.onProgress)==null||f.call(l,new He("dial-queue:start-dial"));const d=Gr([this.shutDownController.signal,l.signal]);try{return await this.dialPeer(l,d)}finally{d.clear()}},{peerId:n,priority:t.priority??th,multiaddrs:new Set(s.map(l=>l.toString())),signal:t.signal??AbortSignal.timeout(this.dialTimeout),onProgress:t.onProgress})}async dialPeer(e,t){var d;const n=e.peerId,s=e.multiaddrs,i=new Set;let o=e.multiaddrs.size===0,a=0,c=0;const l=[];for(this.log("starting dial to %p",n);o||s.size>0;){c++,o=!1;const f=[],h=new Set(e.multiaddrs);s.clear(),this.log("calculating addrs to dial %p from %s",n,[...h]);const p=await this.calculateMultiaddrs(n,h,{...e,signal:t});for(const g of p){if(i.has(g.multiaddr.toString())){this.log.trace("skipping previously failed multiaddr %a while dialing %p",g.multiaddr,n);continue}f.push(g)}this.log("%s dial to %p with %s",c===1?"starting":"continuing",n,f.map(g=>g.multiaddr.toString())),(d=e==null?void 0:e.onProgress)==null||d.call(e,new He("dial-queue:calculated-addresses",f));for(const g of f){if(a===this.maxPeerAddrsToDial)throw this.log("dialed maxPeerAddrsToDial (%d) addresses for %p, not trying any others",a,e.peerId),new ps("Peer had more than maxPeerAddrsToDial");a++;try{const y=await this.components.transportManager.dial(g.multiaddr,{...e,signal:t});this.log("dial to %a succeeded",g.multiaddr);try{await this.components.peerStore.merge(y.remotePeer,{multiaddrs:[y.remoteAddr],metadata:{[tv]:W(Date.now().toString())}})}catch(m){this.log.error("could not update last dial failure key for %p - %e",n,m)}return y}catch(y){if(this.log.error("dial failed to %a - %e",g.multiaddr,y),i.add(g.multiaddr.toString()),n!=null)try{await this.components.peerStore.merge(n,{metadata:{[ev]:W(Date.now().toString())}})}catch(m){this.log.error("could not update last dial failure key for %p - %e",n,m)}if(t.aborted)throw new mh(y.message);l.push(y)}}}throw l.length===1?l[0]:new AggregateError(l,"All multiaddr dials failed")}async calculateMultiaddrs(e,t=new Set,n={}){var f,h;const s=[...t].map(p=>({multiaddr:Ee(p),isCertified:!1}));if(e!=null){if(this.components.peerId.equals(e))throw new ps("Tried to dial self");if(await((h=(f=this.components.connectionGater).denyDialPeer)==null?void 0:h.call(f,e))===!0)throw new uu("The dial request is blocked by gater.allowDialPeer");if(s.length===0){this.log("loading multiaddrs for %p",e);try{const p=await this.components.peerStore.get(e);s.push(...p.addresses),this.log("loaded multiaddrs for %p",e,s.map(({multiaddr:g})=>g.toString()))}catch(p){if(p.name!=="NotFoundError")throw p}}if(s.length===0){this.log("looking up multiaddrs for %p in the peer routing",e);try{const p=await this.components.peerRouting.findPeer(e,n);this.log("found multiaddrs for %p in the peer routing",e,s.map(({multiaddr:g})=>g.toString())),s.push(...p.multiaddrs.map(g=>({multiaddr:g,isCertified:!1})))}catch(p){p.name==="NoPeerRoutersError"?this.log("no peer routers configured",e):this.log.error("looking up multiaddrs for %p in the peer routing failed - %e",e,p)}}}let i=(await Promise.all(s.map(async p=>{const g=await eh(p.multiaddr,this.resolvers,{dns:this.components.dns,log:this.log,...n});return g.length===1&&g[0].equals(p.multiaddr)?p:g.map(y=>({multiaddr:y,isCertified:!1}))}))).flat();if(e!=null){const p=`/p2p/${e.toString()}`;i=i.map(g=>{const y=g.multiaddr.getComponents().pop();return(y==null?void 0:y.name)!=="p2p"?{multiaddr:g.multiaddr.encapsulate(p),isCertified:g.isCertified}:g})}const o=i.filter(p=>{var y;if(this.components.transportManager.dialTransportForMultiaddr(p.multiaddr)==null)return!1;const g=(y=p.multiaddr.getComponents().findLast(m=>m.code===Q))==null?void 0:y.value;return e!=null&&g!=null?e.equals(g):!0}),a=new Map;for(const p of o){const g=p.multiaddr.toString(),y=a.get(g);if(y!=null){y.isCertified=y.isCertified||p.isCertified||!1;continue}a.set(g,p)}const c=[...a.values()];if(c.length===0)throw new M1("The dial request has no valid addresses");const l=[];for(const p of c)this.components.connectionGater.denyDialMultiaddr!=null&&await this.components.connectionGater.denyDialMultiaddr(p.multiaddr)||l.push(p);const d=this.addressSorter==null?uv(l):l.sort(this.addressSorter);if(d.length===0)throw new uu("The connection gater denied all addresses in the dial request");return this.log.trace("addresses for %p before filtering",e??"unknown peer",i.map(({multiaddr:p})=>p.toString())),this.log.trace("addresses for %p after filtering",e??"unknown peer",d.map(({multiaddr:p})=>p.toString())),d}async isDialable(e,t={}){Array.isArray(e)||(e=[e]);try{const n=await this.calculateMultiaddrs(void 0,new Set(e.map(s=>s.toString())),t);return t.runOnLimitedConnection===!1?n.find(s=>!ai.matches(s.multiaddr))!=null:!0}catch{}return!1}}const vv=Object.prototype.toString,xv=r=>vv.call(r)==="[object Error]",Sv=new Set(["network error","Failed to fetch","NetworkError when attempting to fetch resource.","The Internet connection appears to be offline.","Network request failed","fetch failed","terminated"," A network error occurred.","Network connection lost"]);function _v(r){if(!(r&&xv(r)&&r.name==="TypeError"&&typeof r.message=="string"))return!1;const{message:t,stack:n}=r;return t==="Load failed"?n===void 0||"__sentry_captured__"in r:t.startsWith("error sending request for url")?!0:Sv.has(t)}function Av(r){if(typeof r=="number"){if(r<0)throw new TypeError("Expected `retries` to be a non-negative number.");if(Number.isNaN(r))throw new TypeError("Expected `retries` to be a valid number or Infinity, got NaN.")}else if(r!==void 0)throw new TypeError("Expected `retries` to be a number or Infinity.")}function gs(r,e,{min:t=0,allowInfinity:n=!1}={}){if(e!==void 0){if(typeof e!="number"||Number.isNaN(e))throw new TypeError(`Expected \`${r}\` to be a number${n?" or Infinity":""}.`);if(!n&&!Number.isFinite(e))throw new TypeError(`Expected \`${r}\` to be a finite number.`);if(e<t)throw new TypeError(`Expected \`${r}\` to be â‰¥ ${t}.`)}}class Iv extends Error{constructor(e){super(),e instanceof Error?(this.originalError=e,{message:e}=e):(this.originalError=new Error(e),this.originalError.stack=this.stack),this.name="AbortError",this.message=e}}function Cv(r,e){const t=Math.max(1,r+1),n=e.randomize?Math.random()+1:1;let s=Math.round(n*e.minTimeout*e.factor**(t-1));return s=Math.min(s,e.maxTimeout),s}function du(r,e){return Number.isFinite(e)?e-(performance.now()-r):e}async function Lv({error:r,attemptNumber:e,retriesConsumed:t,startTime:n,options:s}){var p,g,y,m;const i=r instanceof Error?r:new TypeError(`Non-error was thrown: "${r}". You should only throw errors.`);if(i instanceof Iv)throw i.originalError;const o=Number.isFinite(s.retries)?Math.max(0,s.retries-t):s.retries,a=s.maxRetryTime??Number.POSITIVE_INFINITY,c=Object.freeze({error:i,attemptNumber:e,retriesLeft:o,retriesConsumed:t});if(await s.onFailedAttempt(c),du(n,a)<=0)throw i;const l=await s.shouldConsumeRetry(c),d=du(n,a);if(d<=0||o<=0)throw i;if(i instanceof TypeError&&!_v(i)){if(l)throw i;return(p=s.signal)==null||p.throwIfAborted(),!1}if(!await s.shouldRetry(c))throw i;if(!l)return(g=s.signal)==null||g.throwIfAborted(),!1;const f=Cv(t,s),h=Math.min(f,d);return(y=s.signal)==null||y.throwIfAborted(),h>0&&await new Promise((_,x)=>{var A,N;const E=()=>{var R;clearTimeout(C),(R=s.signal)==null||R.removeEventListener("abort",E),x(s.signal.reason)},C=setTimeout(()=>{var R;(R=s.signal)==null||R.removeEventListener("abort",E),_()},h);s.unref&&((A=C.unref)==null||A.call(C)),(N=s.signal)==null||N.addEventListener("abort",E,{once:!0})}),(m=s.signal)==null||m.throwIfAborted(),!0}async function Tv(r,e={}){var i,o,a;if(e={...e},Av(e.retries),Object.hasOwn(e,"forever"))throw new Error("The `forever` option is no longer supported. For many use-cases, you can set `retries: Infinity` instead.");e.retries??(e.retries=10),e.factor??(e.factor=2),e.minTimeout??(e.minTimeout=1e3),e.maxTimeout??(e.maxTimeout=Number.POSITIVE_INFINITY),e.maxRetryTime??(e.maxRetryTime=Number.POSITIVE_INFINITY),e.randomize??(e.randomize=!1),e.onFailedAttempt??(e.onFailedAttempt=()=>{}),e.shouldRetry??(e.shouldRetry=()=>!0),e.shouldConsumeRetry??(e.shouldConsumeRetry=()=>!0),gs("factor",e.factor,{min:0,allowInfinity:!1}),gs("minTimeout",e.minTimeout,{min:0,allowInfinity:!1}),gs("maxTimeout",e.maxTimeout,{min:0,allowInfinity:!0}),gs("maxRetryTime",e.maxRetryTime,{min:0,allowInfinity:!0}),e.factor>0||(e.factor=1),(i=e.signal)==null||i.throwIfAborted();let t=0,n=0;const s=performance.now();for(;!Number.isFinite(e.retries)||n<=e.retries;){t++;try{(o=e.signal)==null||o.throwIfAborted();const c=await r(t);return(a=e.signal)==null||a.throwIfAborted(),c}catch(c){await Lv({error:c,attemptNumber:t,retriesConsumed:n,startTime:s,options:e})&&n++}}throw new Error("Retry attempts exhausted without throwing an error.")}class Dv{constructor(e,t={}){u(this,"log");u(this,"queue");u(this,"started");u(this,"peerStore");u(this,"retries");u(this,"retryInterval");u(this,"backoffFactor");u(this,"connectionManager");u(this,"events");this.log=e.logger.forComponent("libp2p:reconnect-queue"),this.peerStore=e.peerStore,this.connectionManager=e.connectionManager,this.queue=new fE({concurrency:t.maxParallelReconnects??J1,metricName:"libp2p_reconnect_queue",metrics:e.metrics}),this.started=!1,this.retries=t.retries??5,this.backoffFactor=t.backoffFactor,this.retryInterval=t.retryInterval,this.events=e.events,e.events.addEventListener("peer:disconnect",n=>{this.maybeReconnect(n.detail).catch(s=>{this.log.error("failed to maybe reconnect to %p - %e",n.detail,s)})})}async maybeReconnect(e){if(!this.started)return;const t=await this.peerStore.get(e);fu(t)&&(this.queue.has(e)||this.queue.add(async n=>{await Tv(async s=>{if(this.started)try{await this.connectionManager.openConnection(e,{signal:n==null?void 0:n.signal})}catch(i){throw this.log("reconnecting to %p attempt %d of %d failed - %e",e,s,this.retries,i),i}},{signal:n==null?void 0:n.signal,retries:this.retries,factor:this.backoffFactor,minTimeout:this.retryInterval})},{peerId:e}).catch(async n=>{this.log.error("failed to reconnect to %p - %e",e,n);const s={};[...t.tags.keys()].forEach(i=>{i.startsWith(Wu)&&(s[i]=void 0)}),await this.peerStore.merge(e,{tags:s}),this.events.safeDispatchEvent("peer:reconnect-failure",{detail:e})}).catch(async n=>{this.log.error("failed to remove keep-alive tag from %p - %e",e,n)}))}start(){this.started=!0}async afterStart(){Promise.resolve().then(async()=>{const e=await this.peerStore.all({filters:[t=>fu(t)]});await Promise.all(e.map(async t=>{await this.connectionManager.openConnection(t.id).catch(n=>{this.log.error("could not open connection to keepalive peer - %e",n)})}))}).catch(e=>{this.log.error("error reconnect to peers after start - %e",e)})}stop(){this.started=!1,this.queue.abort()}}function fu(r){for(const e of r.tags.keys())if(e.startsWith(Wu))return!0;return!1}const th=50,ro={maxConnections:nv,inboundConnectionThreshold:X1,maxIncomingPendingConnections:Q1};var _u;_u=Symbol.toStringTag;class kv{constructor(e,t={}){u(this,"started");u(this,"connections");u(this,"allow");u(this,"deny");u(this,"maxIncomingPendingConnections");u(this,"incomingPendingConnections");u(this,"outboundPendingConnections");u(this,"maxConnections");u(this,"dialQueue");u(this,"reconnectQueue");u(this,"connectionPruner");u(this,"inboundConnectionRateLimiter");u(this,"peerStore");u(this,"metrics");u(this,"events");u(this,"log");u(this,"peerId");u(this,_u,"@libp2p/connection-manager");var n;if(this.maxConnections=t.maxConnections??ro.maxConnections,this.maxConnections<1)throw new Z("Connection Manager maxConnections must be greater than 0");this.connections=new jn,this.started=!1,this.peerId=e.peerId,this.peerStore=e.peerStore,this.metrics=e.metrics,this.events=e.events,this.log=e.logger.forComponent("libp2p:connection-manager"),this.onConnect=this.onConnect.bind(this),this.onDisconnect=this.onDisconnect.bind(this),this.allow=(t.allow??[]).map(s=>Vo(Ee(s))),this.deny=(t.deny??[]).map(s=>Vo(Ee(s))),this.incomingPendingConnections=0,this.maxIncomingPendingConnections=t.maxIncomingPendingConnections??ro.maxIncomingPendingConnections,this.outboundPendingConnections=0,this.inboundConnectionRateLimiter=new gE({points:t.inboundConnectionThreshold??ro.inboundConnectionThreshold,duration:1}),this.connectionPruner=new j1({connectionManager:this,peerStore:e.peerStore,events:e.events,logger:e.logger},{allow:(n=t.allow)==null?void 0:n.map(s=>Ee(s))}),this.dialQueue=new Ev(e,{addressSorter:t.addressSorter,maxParallelDials:t.maxParallelDials??Zf,maxDialQueueLength:t.maxDialQueueLength??Gf,maxPeerAddrsToDial:t.maxPeerAddrsToDial??Wf,dialTimeout:t.dialTimeout??Vf,resolvers:t.resolvers??{dnsaddr:Jf},connections:this.connections}),this.reconnectQueue=new Dv({events:e.events,peerStore:e.peerStore,logger:e.logger,connectionManager:this},{retries:t.reconnectRetries,retryInterval:t.reconnectRetryInterval,backoffFactor:t.reconnectBackoffFactor,maxParallelReconnects:t.maxParallelReconnects})}async start(){var e,t,n;(e=this.metrics)==null||e.registerMetricGroup("libp2p_connection_manager_connections",{calculate:()=>{const s={inbound:0,"inbound pending":this.incomingPendingConnections,outbound:0,"outbound pending":this.outboundPendingConnections};for(const i of this.connections.values())for(const o of i)s[o.direction]++;return s}}),(t=this.metrics)==null||t.registerMetricGroup("libp2p_protocol_streams_total",{label:"protocol",calculate:()=>{const s={};for(const i of this.connections.values())for(const o of i)for(const a of o.streams){const c=`${a.direction} ${a.protocol??"unnegotiated"}`;s[c]=(s[c]??0)+1}return s}}),(n=this.metrics)==null||n.registerMetricGroup("libp2p_connection_manager_protocol_streams_per_connection_90th_percentile",{label:"protocol",calculate:()=>{const s={};for(const o of this.connections.values())for(const a of o){const c={};for(const l of a.streams){const d=`${l.direction} ${l.protocol??"unnegotiated"}`;c[d]=(c[d]??0)+1}for(const[l,d]of Object.entries(c))s[l]=s[l]??[],s[l].push(d)}const i={};for(let[o,a]of Object.entries(s)){a=a.sort((l,d)=>l-d);const c=Math.floor(a.length*.9);i[o]=a[c]}return i}}),this.events.addEventListener("connection:open",this.onConnect),this.events.addEventListener("connection:close",this.onDisconnect),await Eh(this.dialQueue,this.reconnectQueue,this.connectionPruner),this.started=!0,this.log("started")}async stop(){this.events.removeEventListener("connection:open",this.onConnect),this.events.removeEventListener("connection:close",this.onDisconnect),await vh(this.reconnectQueue,this.dialQueue,this.connectionPruner);const e=[];for(const t of this.connections.values())for(const n of t)e.push(Promise.all([Qe(n,"close",{signal:AbortSignal.timeout(500)}),n.close({signal:AbortSignal.timeout(500)})]).catch(s=>{n.abort(s)}));this.log("closing %d connections",e.length),await Promise.all(e),this.connections.clear(),this.log("stopped")}getMaxConnections(){return this.maxConnections}setMaxConnections(e){if(this.maxConnections<1)throw new Z("Connection Manager maxConnections must be greater than 0");let t=!1;e<this.maxConnections&&(t=!0),this.maxConnections=e,t&&this.connectionPruner.maybePruneConnections()}onConnect(e){this._onConnect(e).catch(t=>{this.log.error("could not connect - %e",t)})}async _onConnect(e){const{detail:t}=e;if(!this.started){await t.close();return}if(t.status!=="open")return;const n=t.remotePeer,s=!this.connections.has(n),i=this.connections.get(n)??[];i.push(t),this.connections.set(n,i),n.publicKey!=null&&n.type==="RSA"&&await this.peerStore.patch(n,{publicKey:n.publicKey}),s&&this.events.safeDispatchEvent("peer:connect",{detail:t.remotePeer})}onDisconnect(e){const{detail:t}=e,n=t.remotePeer,i=(this.connections.get(n)??[]).filter(o=>o.id!==t.id);this.connections.set(n,i),i.length===0&&(this.log.trace("peer %p disconnected, removing connection map entry",n),this.connections.delete(n),this.events.safeDispatchEvent("peer:disconnect",{detail:n}))}getConnections(e){if(e!=null)return this.connections.get(e)??[];let t=[];for(const n of this.connections.values())t=t.concat(n);return t}getConnectionsMap(){return this.connections}async openConnection(e,t={}){var n,s;if(!this.started)throw new An("Not started");this.outboundPendingConnections++;try{(n=t.signal)==null||n.throwIfAborted();const{peerId:i,multiaddrs:o}=zf(e);if(this.peerId.equals(i))throw new Xo("Can not dial self");if(i!=null&&t.force!==!0){this.log("dial %p",i);const d=Kf(i,this.getConnections(i),o);if(d!=null)return this.log("had an existing connection to %p as %a",i,d.remoteAddr),(s=t.onProgress)==null||s.call(t,new He("dial-queue:already-connected")),d}const a=await this.dialQueue.dial(e,{...t,priority:t.priority??th});if(a.status!=="open")throw new Ps("Remote closed connection during opening");let c=this.connections.get(a.remotePeer);c==null&&(c=[],this.connections.set(a.remotePeer,c));let l=!1;for(const d of c)if(d.id===a.id&&(l=!0),t.force!==!0&&d.id!==a.id&&d.remoteAddr.equals(a.remoteAddr))return a.abort(new Qo("Duplicate multiaddr connection")),d;return l||c.push(a),a}finally{this.outboundPendingConnections--}}async openStream(e,t,n={}){return(await this.openConnection(e,n)).newStream(t,n)}async closeConnections(e,t={}){const n=this.connections.get(e)??[];await Promise.all(n.map(async s=>{try{await Promise.all([Qe(s,"close",t),s.close(t)])}catch(i){s.abort(i)}}))}acceptIncomingConnection(e){if(this.deny.some(s=>{if(ot(e.remoteAddr)){const i=le(e.remoteAddr);return s.contains(i.host)}return!1}))return this.log("connection from %a refused - connection remote address was in deny list",e.remoteAddr),!1;if(this.allow.some(s=>{if(ot(e.remoteAddr)){const i=le(e.remoteAddr);return s.contains(i.host)}return!0}))return this.incomingPendingConnections++,!0;if(this.incomingPendingConnections===this.maxIncomingPendingConnections)return this.log("connection from %a refused - incomingPendingConnections exceeded by host",e.remoteAddr),!1;if(ot(e.remoteAddr)){const s=le(e.remoteAddr);try{this.inboundConnectionRateLimiter.consume(s.host,1)}catch{return this.log("connection from %a refused - inboundConnectionThreshold exceeded by host %s",e.remoteAddr,s.host),!1}}return this.getConnections().length<this.maxConnections?(this.incomingPendingConnections++,!0):(this.log("connection from %a refused - maxConnections exceeded",e.remoteAddr),!1)}afterUpgradeInbound(){this.incomingPendingConnections--}getDialQueue(){const e={queued:"queued",running:"active",errored:"error",complete:"success"};return this.dialQueue.queue.queue.map(t=>({id:t.id,status:e[t.status],peerId:t.options.peerId,multiaddrs:[...t.options.multiaddrs].map(n=>Ee(n))}))}async isDialable(e,t={}){return this.dialQueue.isDialable(e,t)}}const Pv=1e4,Mv="1.0.0",Nv="ping",Rv="ipfs",hu=32,Bv=!0;var Au,Iu;Iu=Symbol.toStringTag,Au=mo;class Fv{constructor(e,t={}){u(this,"protocol");u(this,"components");u(this,"log");u(this,"heartbeatInterval");u(this,"pingIntervalMs");u(this,"abortController");u(this,"timeout");u(this,"abortConnectionOnPingFailure");u(this,Iu,"@libp2p/connection-monitor");u(this,Au,["@libp2p/connection-monitor"]);this.components=e,this.protocol=`/${t.protocolPrefix??Rv}/${Nv}/${Mv}`,this.log=e.logger.forComponent("libp2p:connection-monitor"),this.pingIntervalMs=t.pingInterval??Pv,this.abortConnectionOnPingFailure=t.abortConnectionOnPingFailure??Bv,this.timeout=new $b({...t.pingTimeout??{},metrics:e.metrics,metricName:"libp2p_connection_monitor_ping_time_milliseconds"})}start(){this.abortController=new AbortController,this.abortController.signal,this.heartbeatInterval=setInterval(()=>{this.components.connectionManager.getConnections().forEach(e=>{Promise.resolve().then(async()=>{var n;let t=Date.now();try{const s=this.timeout.getTimeoutSignal({signal:(n=this.abortController)==null?void 0:n.signal}),i=await e.newStream(this.protocol,{signal:s,runOnLimitedConnection:!0}),o=cf(i);t=Date.now(),await Promise.all([o.write(Ol(hu),{signal:s}),o.read({bytes:hu,signal:s})]),e.rtt=Date.now()-t,await i.close({signal:s})}catch(s){if(s.name!=="UnsupportedProtocolError")throw s;e.rtt=(Date.now()-t)/2}}).catch(t=>{this.log.error("error during heartbeat - %e",t),this.abortConnectionOnPingFailure?(this.log.error("aborting connection due to ping failure"),e.abort(t)):this.log("connection ping failed, but not aborting due to abortConnectionOnPingFailure flag")})})},this.pingIntervalMs)}stop(){var e;(e=this.abortController)==null||e.abort(),this.heartbeatInterval!=null&&clearInterval(this.heartbeatInterval)}}var Cu;Cu=Symbol.toStringTag;class Ov{constructor(e,t){u(this,"routers");u(this,"started");u(this,"components");u(this,Cu,"@libp2p/content-routing");var n,s,i,o,a;this.routers=t.routers??[],this.started=!1,this.components=e,this.findProviders=((n=e.metrics)==null?void 0:n.traceFunction("libp2p.contentRouting.findProviders",this.findProviders.bind(this),{optionsIndex:1,getAttributesFromArgs:([c],l)=>({...l,cid:c.toString()}),getAttributesFromYieldedValue:(c,l)=>({...l,providers:[...Array.isArray(l.providers)?l.providers:[],c.id.toString()]})}))??this.findProviders,this.provide=((s=e.metrics)==null?void 0:s.traceFunction("libp2p.contentRouting.provide",this.provide.bind(this),{optionsIndex:1,getAttributesFromArgs:([c],l)=>({...l,cid:c.toString()})}))??this.provide,this.cancelReprovide=((i=e.metrics)==null?void 0:i.traceFunction("libp2p.contentRouting.cancelReprovide",this.cancelReprovide.bind(this),{optionsIndex:1,getAttributesFromArgs:([c],l)=>({...l,cid:c.toString()})}))??this.cancelReprovide,this.put=((o=e.metrics)==null?void 0:o.traceFunction("libp2p.contentRouting.put",this.put.bind(this),{optionsIndex:2,getAttributesFromArgs:([c])=>({key:X(c,"base36")})}))??this.put,this.get=((a=e.metrics)==null?void 0:a.traceFunction("libp2p.contentRouting.get",this.get.bind(this),{optionsIndex:1,getAttributesFromArgs:([c])=>({key:X(c,"base36")})}))??this.get}isStarted(){return this.started}async start(){this.started=!0}async stop(){this.started=!1}async*findProviders(e,t={}){if(this.routers.length===0)throw new to("No content routers available");const n=this,s=new Mr;for await(const i of Js(...n.routers.filter(o=>o.findProviders instanceof Function).map(o=>o.findProviders(e,t))))i!=null&&(i.multiaddrs.length>0&&await this.components.peerStore.merge(i.id,{multiaddrs:i.multiaddrs},t),!s.has(i.id)&&(s.add(i.id),yield i))}async provide(e,t={}){if(this.routers.length===0)throw new to("No content routers available");await Promise.all(this.routers.filter(n=>n.provide instanceof Function).map(async n=>{await n.provide(e,t)}))}async cancelReprovide(e,t={}){if(this.routers.length===0)throw new to("No content routers available");await Promise.all(this.routers.filter(n=>n.cancelReprovide instanceof Function).map(async n=>{await n.cancelReprovide(e,t)}))}async put(e,t,n){if(!this.isStarted())throw new An;await Promise.all(this.routers.filter(s=>s.put instanceof Function).map(async s=>{await s.put(e,t,n)}))}async get(e,t){if(!this.isStarted())throw new An;return Promise.any(this.routers.filter(n=>n.get instanceof Function).map(async n=>n.get(e,t)))}}const ms=globalThis.CustomEvent??Event;async function*$v(r,e={}){let t=e.concurrency??1/0;t<1&&(t=1/0);const n=e.ordered??!1,s=new EventTarget,i=[];let o=Xe(),a=Xe(),c=!1,l,d=!1;s.addEventListener("task-complete",()=>{a.resolve()}),Promise.resolve().then(async()=>{try{for await(const g of r){if(i.length===t&&(o=Xe(),await o.promise),d)break;const y={done:!1};i.push(y),g().then(m=>{y.done=!0,y.ok=!0,y.value=m,s.dispatchEvent(new ms("task-complete"))},m=>{y.done=!0,y.err=m,s.dispatchEvent(new ms("task-complete"))})}c=!0,s.dispatchEvent(new ms("task-complete"))}catch(g){l=g,s.dispatchEvent(new ms("task-complete"))}});function f(){var g;return n?(g=i[0])==null?void 0:g.done:!!i.find(y=>y.done)}function*h(){for(;i.length>0&&i[0].done;){const g=i[0];if(i.shift(),g.ok)yield g.value;else throw d=!0,o.resolve(),g.err;o.resolve()}}function*p(){for(;f();)for(let g=0;g<i.length;g++)if(i[g].done){const y=i[g];if(i.splice(g,1),g--,y.ok)yield y.value;else throw d=!0,o.resolve(),y.err;o.resolve()}}for(;;){if(f()||(a=Xe(),await a.promise),l!=null||(n?yield*h():yield*p(),l!=null))throw l;if(c&&i.length===0)break}}var Lu;Lu=Symbol.toStringTag;class Uv{constructor(e,t={}){u(this,"log");u(this,"peerId");u(this,"peerStore");u(this,"routers");u(this,Lu,"@libp2p/peer-routing");var n,s;this.log=e.logger.forComponent("libp2p:peer-routing"),this.peerId=e.peerId,this.peerStore=e.peerStore,this.routers=t.routers??[],this.findPeer=((n=e.metrics)==null?void 0:n.traceFunction("libp2p.peerRouting.findPeer",this.findPeer.bind(this),{optionsIndex:1,getAttributesFromArgs:([i],o)=>({...o,peer:i.toString()})}))??this.findPeer,this.getClosestPeers=((s=e.metrics)==null?void 0:s.traceFunction("libp2p.peerRouting.getClosestPeers",this.getClosestPeers.bind(this),{optionsIndex:1,getAttributesFromArgs:([i],o)=>({...o,key:X(i,"base36")}),getAttributesFromYieldedValue:(i,o)=>({...o,peers:[...Array.isArray(o.peers)?o.peers:[],i.id.toString()]})}))??this.getClosestPeers}async findPeer(e,t){if(this.routers.length===0)throw new cu("No peer routers available");if(e.toString()===this.peerId.toString())throw new L1("Should not try to find self");const n=this,s=Js(...this.routers.filter(i=>i.findPeer instanceof Function).map(i=>async function*(){try{yield await i.findPeer(e,t)}catch(o){n.log.error("router failed to find peer - %e",o)}}()));for await(const i of s)if(i!=null)return i.multiaddrs.length>0&&await this.peerStore.merge(i.id,{multiaddrs:i.multiaddrs},t),i;throw new ho}async*getClosestPeers(e,t={}){if(this.routers.length===0)throw new cu("No peer routers available");const n=this,s=$a(1024);for await(const i of $v(async function*(){const o=Js(...n.routers.filter(a=>a.getClosestPeers instanceof Function).map(a=>a.getClosestPeers(e,t)));for await(let a of o)yield async()=>{if(a.multiaddrs.length===0)try{a=await n.findPeer(a.id,{...t,useCache:!1})}catch(c){n.log.error("could not find peer multiaddrs - %e",c);return}return a}}()))i!=null&&(i.multiaddrs.length>0&&await this.peerStore.merge(i.id,{multiaddrs:i.multiaddrs},t),!s.has(i.id.toMultihash().bytes)&&(s.add(i.id.toMultihash().bytes),yield i))}}var Tu,Du;class zv extends(Du=It,Tu=Symbol.toStringTag,Du){constructor(t){super();u(this,"peerRouting");u(this,"log");u(this,"walking");u(this,"walkers");u(this,"shutdownController");u(this,"walkController");u(this,"needNext");u(this,Tu,"@libp2p/random-walk");this.log=t.logger.forComponent("libp2p:random-walk"),this.peerRouting=t.peerRouting,this.walkers=0,this.walking=!1,this.shutdownController=new AbortController,this.shutdownController.signal}start(){this.shutdownController=new AbortController,this.shutdownController.signal}stop(){this.shutdownController.abort()}async*walk(t){var s,i;this.walking||this.startWalk(),this.walkers++;const n=Gr([this.shutdownController.signal,t==null?void 0:t.signal]);try{for(;;)(s=this.needNext)==null||s.resolve(),this.needNext=Xe(),yield(await Qe(this,"walk:peer",{signal:n,rejectionEvents:["walk:error"]})).detail}catch(o){throw o.detail!=null?o.detail:o}finally{n.clear(),this.walkers--,this.walkers===0&&((i=this.walkController)==null||i.abort(),this.walkController=void 0)}}startWalk(){this.walking=!0,this.walkController=new AbortController,this.walkController.signal;const t=Gr([this.walkController.signal,this.shutdownController.signal]),n=Date.now();let s=0;Promise.resolve().then(async()=>{for(this.log("start walk");this.walkers>0;)try{const i=Ol(32);let o=Date.now();for await(const a of this.peerRouting.getClosestPeers(i,{signal:t}))t.aborted&&this.log("aborting walk"),t.throwIfAborted(),this.log("found peer %p after %dms for %d walkers",a.id,Date.now()-o,this.walkers),s++,this.safeDispatchEvent("walk:peer",{detail:a}),this.walkers===1&&this.needNext!=null&&(this.log("wait for need next"),await Tt(this.needNext.promise,t)),o=Date.now();this.log("walk iteration for %b and %d walkers finished, found %d peers",i,this.walkers,s)}catch(i){this.log.error("random walk errored - %e",i),this.safeDispatchEvent("walk:error",{detail:i})}this.log("no walkers left, ended walk")}).catch(i=>{this.log.error("random walk errored - %e",i)}).finally(()=>{this.log("finished walk, found %d peers after %dms",s,Date.now()-n),this.walking=!1})}}const rh=32,nh=64;var ku;ku=Symbol.toStringTag;class qv{constructor(e){u(this,"log");u(this,"topologies");u(this,"handlers");u(this,"components");u(this,"middleware");u(this,ku,"@libp2p/registrar");var t;this.components=e,this.log=e.logger.forComponent("libp2p:registrar"),this.middleware=new Map,this.topologies=new Map,(t=e.metrics)==null||t.registerMetricGroup("libp2p_registrar_topologies",{calculate:()=>{const n={};for(const[s,i]of this.topologies)n[s]=i.size;return n}}),this.handlers=Dt({name:"libp2p_registrar_protocol_handlers",metrics:e.metrics}),this._onDisconnect=this._onDisconnect.bind(this),this._onPeerUpdate=this._onPeerUpdate.bind(this),this._onPeerIdentify=this._onPeerIdentify.bind(this),this.components.events.addEventListener("peer:disconnect",this._onDisconnect),this.components.events.addEventListener("peer:update",this._onPeerUpdate),this.components.events.addEventListener("peer:identify",this._onPeerIdentify)}getProtocols(){return Array.from(new Set([...this.handlers.keys()])).sort()}getHandler(e){const t=this.handlers.get(e);if(t==null)throw new T1(`No handler registered for protocol ${e}`);return t}getTopologies(e){const t=this.topologies.get(e);return t==null?[]:[...t.values()]}async handle(e,t,n){if(this.handlers.has(e)&&(n==null?void 0:n.force)!==!0)throw new D1(`Handler already registered for protocol ${e}`);this.handlers.set(e,{handler:t,options:{maxInboundStreams:rh,maxOutboundStreams:nh,...n}}),await this.components.peerStore.merge(this.components.peerId,{protocols:[e]},n)}async unhandle(e,t){(Array.isArray(e)?e:[e]).forEach(s=>{this.handlers.delete(s)}),await this.components.peerStore.patch(this.components.peerId,{protocols:this.getProtocols()},t)}async register(e,t){if(t==null)throw new Z("invalid topology");const n=`${(Math.random()*1e9).toString(36)}${Date.now()}`;let s=this.topologies.get(e);return s==null&&(s=new Map,this.topologies.set(e,s)),s.set(n,t),n}unregister(e){for(const[t,n]of this.topologies.entries())n.has(e)&&(n.delete(e),n.size===0&&this.topologies.delete(t))}use(e,t){this.middleware.set(e,t)}unuse(e){this.middleware.delete(e)}getMiddleware(e){return this.middleware.get(e)??[]}async _onDisconnect(e){const t=e.detail,n={signal:AbortSignal.timeout(5e3)};try{const s=await this.components.peerStore.get(t,n);for(const i of s.protocols){const o=this.topologies.get(i);o!=null&&await Promise.all([...o.values()].map(async a=>{var c,l,d;((c=a.filter)==null?void 0:c.has(t))!==!1&&((l=a.filter)==null||l.remove(t),await((d=a.onDisconnect)==null?void 0:d.call(a,t)))}))}}catch(s){if(s.name==="NotFoundError")return;this.log.error("could not inform topologies of disconnecting peer %p - %e",t,s)}}async _onPeerUpdate(e){const{peer:t,previous:n}=e.detail,s=((n==null?void 0:n.protocols)??[]).filter(i=>!t.protocols.includes(i));try{for(const i of s){const o=this.topologies.get(i);o!=null&&await Promise.all([...o.values()].map(async a=>{var c,l,d;((c=a.filter)==null?void 0:c.has(t.id))!==!1&&((l=a.filter)==null||l.remove(t.id),await((d=a.onDisconnect)==null?void 0:d.call(a,t.id)))}))}}catch(i){this.log.error("could not inform topologies of updated peer %p - %e",t.id,i)}}async _onPeerIdentify(e){const t=e.detail.protocols,n=e.detail.connection,s=e.detail.peerId;try{for(const i of t){const o=this.topologies.get(i);o!=null&&await Promise.all([...o.values()].map(async a=>{var c,l,d;n.limits!=null&&a.notifyOnLimitedConnection!==!0||((c=a.filter)==null?void 0:c.has(s))!==!0&&((l=a.filter)==null||l.add(s),await((d=a.onConnect)==null?void 0:d.call(a,s,n)))}))}}catch(i){this.log.error("could not inform topologies of updated peer after identify %p - %e",s,i)}}}var Pu;Pu=Symbol.toStringTag;class Kv{constructor(e,t={}){u(this,"log");u(this,"components");u(this,"transports");u(this,"listeners");u(this,"faultTolerance");u(this,"started");u(this,Pu,"@libp2p/transport-manager");this.log=e.logger.forComponent("libp2p:transports"),this.components=e,this.started=!1,this.transports=Dt({name:"libp2p_transport_manager_transports",metrics:this.components.metrics}),this.listeners=Dt({name:"libp2p_transport_manager_listeners",metrics:this.components.metrics}),this.faultTolerance=t.faultTolerance??Ms.FATAL_ALL}add(e){const t=e[Symbol.toStringTag];if(t==null)throw new Z("Transport must have a valid tag");if(this.transports.has(t))throw new Z(`There is already a transport with the tag ${t}`);this.log("adding transport %s",t),this.transports.set(t,e),this.listeners.has(t)||this.listeners.set(t,[])}isStarted(){return this.started}start(){this.started=!0}async afterStart(){const e=this.components.addressManager.getListenAddrs();await this.listen(e)}async stop(){const e=[];for(const[t,n]of this.listeners)for(this.log("closing listeners for %s",t);n.length>0;){const s=n.pop();s!=null&&e.push(s.close())}await Promise.all(e),this.log("all listeners closed");for(const t of this.listeners.keys())this.listeners.set(t,[]);this.started=!1}async dial(e,t){var s;const n=this.dialTransportForMultiaddr(e);if(n==null)throw new B1(`No transport available for address ${String(e)}`);return(s=t==null?void 0:t.onProgress)==null||s.call(t,new He("transport-manager:selected-transport",n[Symbol.toStringTag])),n.dial(e,{...t,upgrader:this.components.upgrader})}getAddrs(){let e=[];for(const t of this.listeners.values())for(const n of t)e=[...e,...n.getAddrs()];return e}getTransports(){return Array.of(...this.transports.values())}getListeners(){return Array.of(...this.listeners.values()).flat()}dialTransportForMultiaddr(e){for(const t of this.transports.values())if(t.dialFilter([e]).length>0)return t}listenTransportForMultiaddr(e){for(const t of this.transports.values())if(t.listenFilter([e]).length>0)return t}async listen(e){if(!this.isStarted())throw new An("Not started");if(e==null||e.length===0){this.log("no addresses were provided for listening, this node is dial only");return}const t={errors:new Map,ipv4:{success:0,attempts:0},ipv6:{success:0,attempts:0}};e.forEach(i=>{t.errors.set(i.toString(),new k1)});const n=[];for(const[i,o]of this.transports.entries()){const a=o.listenFilter(e);for(const c of a){this.log("creating listener for %s on %a",i,c);const l=o.createListener({upgrader:this.components.upgrader});let d=this.listeners.get(i)??[];d==null&&(d=[],this.listeners.set(i,d)),d.push(l),l.addEventListener("listening",()=>{this.components.events.safeDispatchEvent("transport:listening",{detail:l})}),l.addEventListener("close",()=>{const f=d.findIndex(h=>h===l);d.splice(f,1),this.components.events.safeDispatchEvent("transport:close",{detail:l})}),Jc.matches(c)?t.ipv4.attempts++:eu.matches(c)&&t.ipv6.attempts++,n.push(l.listen(c).then(()=>{t.errors.delete(c.toString()),Jc.matches(c)&&t.ipv4.success++,eu.matches(c)&&t.ipv6.success++},f=>{throw this.log.error("transport %s could not listen on address %a - %e",i,c,f),t.errors.set(c.toString(),f),f}))}}const s=await Promise.allSettled(n);if(!(s.length>0&&s.every(i=>i.status==="fulfilled"))){if(this.ipv6Unsupported(t)){this.log("all IPv4 addresses succeed but all IPv6 failed");return}if(this.faultTolerance===Ms.NO_FATAL){this.log("failed to listen on any address but fault tolerance allows this");return}throw new P1(`Some configured addresses failed to be listened on, you may need to remove one or more listen addresses from your configuration or set \`transportManager.faultTolerance\` to NO_FATAL:
${[...t.errors.entries()].map(([i,o])=>`
  ${i}: ${`${Vv(o)}`.split(`
`).join(`
  `)}
`).join("")}`)}}ipv6Unsupported(e){if(e.ipv4.attempts===0||e.ipv6.attempts===0)return!1;const t=e.ipv4.attempts===e.ipv4.success,n=e.ipv6.success===0;return t&&n}async remove(e){const t=this.listeners.get(e)??[];this.log.trace("removing transport %s",e);const n=[];for(this.log.trace("closing listeners for %s",e);t.length>0;){const s=t.pop();s!=null&&n.push(s.close())}await Promise.all(n),this.transports.delete(e),this.listeners.delete(e)}async removeAll(){const e=[];for(const t of this.transports.keys())e.push(this.remove(t));await Promise.all(e)}}function Vv(r){return r.stack!=null&&r.stack.trim()!==""?r.stack:r.message!=null?r.message:r.toString()}const er="/multistream/1.0.0",sh=1024,Hv=W(`
`);async function Ho(r,e){const n=(await r.read(e)).subarray();if(n.byteLength===0||n[n.length-1]!==Hv[0])throw new Ku("Missing newline");return X(n).trimEnd()}async function Wo(r,e,t={}){if(e=Array.isArray(e)?[...e]:[e],e.length===0)throw new Error("At least one protocol must be specified");const n=r.log.newScope("mss:select"),s=qa(r,{...t,maxDataLength:sh});for(let i=0;i<e.length;i++){const o=e[i];let a;if(i===0){n.trace('write ["%s", "%s"]',er,o);const c=W(`${er}
`),l=W(`${o}
`);if(await s.writeV([c,l],t),n.trace("reading multistream-select header"),a=await Ho(s,t),n.trace('read "%s"',a),a!==er){n.error("did not read multistream-select header from response");break}}else n.trace('write "%s"',o),await s.write(W(`${o}
`),t);if(n.trace("reading protocol response"),a=await Ho(s,t),n.trace('read "%s"',a),a===o)return n.trace('selected "%s" after negotiation',a),s.unwrap(),o}throw new qu(`Protocol selection failed - could not negotiate ${e}`)}async function Go(r,e,t={}){e=Array.isArray(e)?e:[e];const n=r.log.newScope("mss:handle"),s=qa(r,{...t,maxDataLength:sh,maxLengthLength:2});for(;;){n.trace("reading incoming string");const i=await Ho(s,t);if(n.trace('read "%s"',i),i===er){n.trace('respond with "%s" for "%s"',er,i),await s.write(W(`${er}
`),t),n.trace('responded with "%s" for "%s"',er,i);continue}if(e.includes(i))return n.trace('respond with "%s" for "%s"',i,i),await s.write(W(`${i}
`),t),n.trace('responded with "%s" for "%s"',i,i),s.unwrap(),i;if(i==="ls"){const o=new ce(...e.map(a=>ff.single(W(`${a}
`))),W(`
`));n.trace('respond with "%s" for %s',e,i),await s.write(o,t),n.trace('responded with "%s" for %s',e,i);continue}n.trace('respond with "na" for "%s"',i),await s.write(W(`na
`),t),n('responded with "na" for "%s"',i)}}var Mu,Nu,Ru;class Wv extends(Ru=It,Nu=Symbol.toStringTag,Mu=lh,Ru){constructor(t,n){super();u(this,"id");u(this,"remoteAddr");u(this,"remotePeer");u(this,"direction");u(this,"timeline");u(this,"direct");u(this,"multiplexer");u(this,"encryption");u(this,"limits");u(this,"log");u(this,"maConn");u(this,"muxer");u(this,"components");u(this,"outboundStreamProtocolNegotiationTimeout");u(this,"inboundStreamProtocolNegotiationTimeout");u(this,"closeTimeout");u(this,Nu,"Connection");u(this,Mu,!0);u(this,"newStream",async(t,n={})=>{var i;if(this.muxer==null)throw new ks("Connection is not multiplexed");if(this.muxer.status!=="open")throw new Ps(`The connection muxer is "${this.muxer.status}" and not "open"`);if(this.maConn.status!=="open")throw new Ps(`The connection is "${this.status}" and not "open"`);if(this.limits!=null&&(n==null?void 0:n.runOnLimitedConnection)!==!0)throw new go("Cannot open protocol stream on limited connection");Array.isArray(t)||(t=[t]),this.log.trace("starting new stream for protocols %s",t);const s=await this.muxer.createStream({...n,protocol:t.length===1?t[0]:void 0});this.log.trace("started new stream %s for protocols %s",s.id,t);try{if(n.signal==null){s.log("no abort signal was passed while trying to negotiate protocols %s falling back to default timeout",t);const l=AbortSignal.timeout(this.outboundStreamProtocolNegotiationTimeout);n={...n,signal:l}}s.protocol===""?(s.log.trace("selecting protocol from protocols %s",t),s.protocol=await Wo(s,t,n),s.log("negotiated protocol %s",s.protocol)):s.log("pre-negotiated protocol %s",s.protocol);const o=jv(s.protocol,this.components.registrar,n),a=gu(s.protocol,"outbound",this);if(a>o){const l=new Hu(`Too many outbound protocol streams for protocol "${s.protocol}" - ${a}/${o}`);throw s.abort(l),l}await this.components.peerStore.merge(this.remotePeer,{protocols:[s.protocol]}),(i=this.components.metrics)==null||i.trackProtocolStream(s);const c=this.components.registrar.getMiddleware(s.protocol);return await this.runMiddlewareChain(s,this,c)}catch(o){throw s.status==="open"?s.abort(o):this.log.error("could not create new outbound stream on connection %s %a for protocols %s - %e",this.direction==="inbound"?"from":"to",this.remoteAddr,t,o),o}});this.components=t,this.id=n.id,this.remoteAddr=n.maConn.remoteAddr,this.remotePeer=n.remotePeer,this.direction=n.direction??"outbound",this.timeline=n.maConn.timeline,this.encryption=n.cryptoProtocol,this.limits=n.limits,this.maConn=n.maConn,this.log=n.maConn.log,this.outboundStreamProtocolNegotiationTimeout=n.outboundStreamProtocolNegotiationTimeout??ci,this.inboundStreamProtocolNegotiationTimeout=n.inboundStreamProtocolNegotiationTimeout??ci,this.closeTimeout=n.closeTimeout??Hf,this.direct=qf(n.maConn.remoteAddr),this.onIncomingStream=this.onIncomingStream.bind(this),this.remoteAddr.getComponents().find(s=>s.code===Q)==null&&(this.remoteAddr=this.remoteAddr.encapsulate(`/p2p/${this.remotePeer}`)),n.muxer!=null&&(this.multiplexer=n.muxer.protocol,this.muxer=n.muxer,this.muxer.addEventListener("stream",this.onIncomingStream)),this.maConn.addEventListener("close",s=>{this.dispatchEvent(new li(s.local,s.error))})}get streams(){var t;return((t=this.muxer)==null?void 0:t.streams)??[]}get status(){return this.maConn.status}async onIncomingStream(t){var i;const n=t.detail,s=AbortSignal.timeout(this.inboundStreamProtocolNegotiationTimeout);n.log("start protocol negotiation, timing out after %dms",this.inboundStreamProtocolNegotiationTimeout);try{if(n.protocol===""){const f=this.components.registrar.getProtocols();n.log.trace("selecting protocol from protocols %s",f),n.protocol=await Go(n,f,{signal:s}),n.log("negotiated protocol %s",n.protocol)}else n.log("pre-negotiated protocol %s",n.protocol);const o=Zv(n.protocol,this.components.registrar);if(gu(n.protocol,"inbound",this)>o)throw new Vu(`Too many inbound protocol streams for protocol "${n.protocol}" - limit ${o}`);await this.components.peerStore.merge(this.remotePeer,{protocols:[n.protocol]},{signal:s}),(i=this.components.metrics)==null||i.trackProtocolStream(n);const{handler:c,options:l}=this.components.registrar.getHandler(n.protocol);if(this.limits!=null&&l.runOnLimitedConnection!==!0)throw new go("Cannot open protocol stream on limited connection");const d=this.components.registrar.getMiddleware(n.protocol);d.push(async(f,h,p)=>{await c(f,h),p(f,h)}),await this.runMiddlewareChain(n,this,d)}catch(o){n.abort(o)}}async runMiddlewareChain(t,n,s){for(let i=0;i<s.length;i++){const o=s[i];t.log.trace("running middleware",i,o),await new Promise((a,c)=>{try{const l=o(t,n,(d,f)=>{t=d,n=f,a()});l instanceof Promise&&l.catch(c)}catch(l){c(l)}}),t.log.trace("ran middleware",i,o)}return t}async close(t={}){var n;if(this.log("closing connection to %a",this.remoteAddr),t.signal==null){const s=AbortSignal.timeout(this.closeTimeout);t={...t,signal:s}}await((n=this.muxer)==null?void 0:n.close(t)),await this.maConn.close(t)}abort(t){var n;(n=this.muxer)==null||n.abort(t),this.maConn.abort(t)}}function Gv(r,e){return new Wv(r,e)}function Zv(r,e){try{const{options:t}=e.getHandler(r);if(t.maxInboundStreams!=null)return t.maxInboundStreams}catch(t){if(t.name!=="UnhandledProtocolError")throw t}return rh}function jv(r,e,t={}){try{const{options:n}=e.getHandler(r);if(n.maxOutboundStreams!=null)return n.maxOutboundStreams}catch(n){if(n.name!=="UnhandledProtocolError")throw n}return t.maxOutboundStreams??nh}function gu(r,e,t){let n=0;return t.streams.forEach(s=>{s.direction===e&&s.protocol===r&&n++}),n}var Bu;Bu=Symbol.toStringTag;class Yv{constructor(e,t){u(this,"components");u(this,"connectionEncrypters");u(this,"streamMuxers");u(this,"inboundUpgradeTimeout");u(this,"inboundStreamProtocolNegotiationTimeout");u(this,"outboundStreamProtocolNegotiationTimeout");u(this,"events");u(this,"metrics");u(this,"connectionCloseTimeout");u(this,Bu,"@libp2p/upgrader");var n,s,i,o;this.components=e,this.connectionEncrypters=Dt({name:"libp2p_upgrader_connection_encrypters",metrics:this.components.metrics}),t.connectionEncrypters.forEach(a=>{this.connectionEncrypters.set(a.protocol,a)}),this.streamMuxers=Dt({name:"libp2p_upgrader_stream_multiplexers",metrics:this.components.metrics}),t.streamMuxers.forEach(a=>{this.streamMuxers.set(a.protocol,a)}),this.inboundUpgradeTimeout=t.inboundUpgradeTimeout??Y1,this.inboundStreamProtocolNegotiationTimeout=t.inboundStreamProtocolNegotiationTimeout??ci,this.outboundStreamProtocolNegotiationTimeout=t.outboundStreamProtocolNegotiationTimeout??ci,this.connectionCloseTimeout=t.connectionCloseTimeout??Hf,this.events=e.events,this.metrics={dials:(n=e.metrics)==null?void 0:n.registerCounterGroup("libp2p_connection_manager_dials_total"),errors:(s=e.metrics)==null?void 0:s.registerCounterGroup("libp2p_connection_manager_dial_errors_total"),inboundErrors:(i=e.metrics)==null?void 0:i.registerCounterGroup("libp2p_connection_manager_dials_inbound_errors_total"),outboundErrors:(o=e.metrics)==null?void 0:o.registerCounterGroup("libp2p_connection_manager_dials_outbound_errors_total")}}async shouldBlockConnection(e,...t){const n=this.components.connectionGater[e];if(n==null)return;if(await n.apply(this.components.connectionGater,t)===!0)throw new N1(`The multiaddr connection is blocked by gater.${e}`)}createInboundAbortSignal(e){return Gr([AbortSignal.timeout(this.inboundUpgradeTimeout),e])}async upgradeInbound(e,t){var i,o,a;let n=!1;const s=this.createInboundAbortSignal(t.signal);try{if((i=this.metrics.dials)==null||i.increment({inbound:!0}),n=this.components.connectionManager.acceptIncomingConnection(e),!n)throw new R1("Connection denied");await Tt(this.shouldBlockConnection("denyInboundConnection",e),s),await this._performUpgrade(e,"inbound",{...t,signal:s})}catch(c){throw(o=this.metrics.errors)==null||o.increment({inbound:!0}),(a=this.metrics.inboundErrors)==null||a.increment({[c.name??"Error"]:!0}),c}finally{s.clear(),n&&this.components.connectionManager.afterUpgradeInbound()}}async upgradeOutbound(e,t){var n,s,i,o;try{(n=this.metrics.dials)==null||n.increment({outbound:!0});const a=(s=e.remoteAddr.getComponents().findLast(d=>d.code===Q))==null?void 0:s.value;let c;a!=null&&(c=Kr(a),await Tt(this.shouldBlockConnection("denyOutboundConnection",c,e),t.signal));let l="outbound";return t.initiator===!1&&(l="inbound"),await this._performUpgrade(e,l,t)}catch(a){throw(i=this.metrics.errors)==null||i.increment({outbound:!0}),(o=this.metrics.outboundErrors)==null||o.increment({[a.name??"Error"]:!0}),a}}async _performUpgrade(e,t,n){var f,h,p,g;let s=e,i,o,a,c;const l=`${parseInt(String(Math.random()*1e9)).toString(36)}${Date.now()}`;if(e.log=e.log.newScope(`${t}:${l}`),(f=this.components.metrics)==null||f.trackMultiaddrConnection(e),e.log.trace("starting the %s connection upgrade",t),(n==null?void 0:n.skipProtection)!==!0){const y=this.components.connectionProtector;y!=null&&(e.log("protecting the %s connection",t),s=await y.protect(s,n))}try{if(Xv(n)){if(n.remotePeer==null)throw new Qo(`${t} connection that skipped encryption must have a peer id`);c="native",i=n.remotePeer}else{const y=(h=e.remoteAddr.getComponents().findLast(_=>_.code===Q))==null?void 0:h.value;let m;y!=null&&(m=Kr(y)),(p=n==null?void 0:n.onProgress)==null||p.call(n,new He(`upgrader:encrypt-${t}-connection`)),{connection:s,remotePeer:i,protocol:c,streamMuxer:o}=await(t==="inbound"?this._encryptInbound(s,{...n,remotePeer:m}):this._encryptOutbound(s,{...n,remotePeer:m}))}if(i.equals(this.components.peerId)){const y=new Xo("Can not dial self");throw e.abort(y),y}await this.shouldBlockConnection(t==="inbound"?"denyInboundEncryptedConnection":"denyOutboundEncryptedConnection",i,e),(n==null?void 0:n.muxerFactory)!=null?o=n.muxerFactory:o==null&&this.streamMuxers.size>0&&((g=n==null?void 0:n.onProgress)==null||g.call(n,new He(`upgrader:multiplex-${t}-connection`)),o=await(t==="inbound"?this._multiplexInbound(s,this.streamMuxers,n):this._multiplexOutbound(s,this.streamMuxers,n)))}catch(y){throw e.log.error("failed to upgrade %s connection %s %a - %e",t,t==="inbound"?"from":"to",e.remoteAddr,y),y}o!=null&&(e.log("create muxer %s",o.protocol),a=o.createStreamMuxer(s)),await this.shouldBlockConnection(t==="inbound"?"denyInboundUpgradedConnection":"denyOutboundUpgradedConnection",i,e);const d=this._createConnection({id:l,cryptoProtocol:c,direction:t,maConn:e,stream:s,muxer:a,remotePeer:i,limits:n==null?void 0:n.limits,closeTimeout:this.connectionCloseTimeout});return d.log("successfully upgraded connection"),d}_createConnection(e){const t=Gv(this.components,{...e,outboundStreamProtocolNegotiationTimeout:this.outboundStreamProtocolNegotiationTimeout,inboundStreamProtocolNegotiationTimeout:this.inboundStreamProtocolNegotiationTimeout});return t.addEventListener("close",()=>{this.events.safeDispatchEvent("connection:close",{detail:t})}),this.events.safeDispatchEvent("connection:open",{detail:t}),t}async _encryptInbound(e,t){const n=Array.from(this.connectionEncrypters.keys());try{const s=await Go(e,n,t),i=this.connectionEncrypters.get(s);if(i==null)throw new hs(`no crypto module found for ${s}`);return e.log("encrypting inbound connection using %s",s),{...await i.secureInbound(e,t),protocol:s}}catch(s){throw new hs(s.message)}}async _encryptOutbound(e,t){const n=Array.from(this.connectionEncrypters.keys());try{e.log.trace("selecting encrypter from %s",n);const s=await Wo(e,n,t),i=this.connectionEncrypters.get(s);if(i==null)throw new hs(`no crypto module found for ${s}`);return e.log("encrypting outbound connection using %s",s),{...await i.secureOutbound(e,t),protocol:s}}catch(s){throw new hs(s.message)}}async _multiplexOutbound(e,t,n){const s=Array.from(t.keys());e.log("outbound selecting muxer %s",s);try{e.log.trace("selecting stream muxer from %s",s);const i=await Wo(e,s,n),o=t.get(i);if(o==null)throw new ks(`No muxer configured for protocol "${i}"`);return e.log("selected %s as muxer protocol",i),o}catch(i){throw e.log.error("error multiplexing outbound connection - %e",i),new ks(String(i))}}async _multiplexInbound(e,t,n){const s=Array.from(t.keys());e.log("inbound handling muxers %s",s);try{e.log.trace("selecting stream muxer from %s",s);const i=await Go(e,s,n),o=t.get(i);if(o==null)throw new ks(`No muxer configured for protocol "${i}"`);return e.log("selected %s as muxer protocol",i),o}catch(i){throw e.log.error("error multiplexing inbound connection - %e",i),i}}getConnectionEncrypters(){return this.connectionEncrypters}getStreamMuxers(){return this.streamMuxers}}function Xv(r){return r.skipEncryption===!0}const ih="3.1.3",oh="js-libp2p";function Qv(r,e){return`${r??oh}/${e??ih} browser/${globalThis.navigator.userAgent}`}var Un,Zo;class Jv extends It{constructor(t){var d,f,h,p,g,y,m,_,x,E,C;super();se(this,Un);u(this,"peerId");u(this,"peerStore");u(this,"contentRouting");u(this,"peerRouting");u(this,"metrics");u(this,"services");u(this,"logger");u(this,"status");u(this,"components");u(this,"log");this.status="stopped";const n=new It,s=n.dispatchEvent.bind(n);n.dispatchEvent=A=>{const N=s(A),R=this.dispatchEvent(new CustomEvent(A.type,{detail:A.detail}));return N||R},this.peerId=t.peerId,this.logger=t.logger??_d(),this.log=this.logger.forComponent("libp2p"),this.services={};const i=((d=t.nodeInfo)==null?void 0:d.name)??oh,o=((f=t.nodeInfo)==null?void 0:f.version)??ih,a=this.components=z1({peerId:t.peerId,privateKey:t.privateKey,nodeInfo:{name:i,version:o,userAgent:((h=t.nodeInfo)==null?void 0:h.userAgent)??Qv(i,o)},logger:this.logger,events:n,datastore:t.datastore??new o1,connectionGater:W1(t.connectionGater),dns:t.dns});t.metrics!=null&&(this.metrics=this.configureComponent("metrics",t.metrics(this.components))),this.peerStore=this.configureComponent("peerStore",e1(a,{addressFilter:this.components.connectionGater.filterMultiaddrForPeer,...t.peerStore})),a.events.addEventListener("peer:update",A=>{if(A.detail.previous==null){const N={id:A.detail.peer.id,multiaddrs:A.detail.peer.addresses.map(R=>R.multiaddr)};a.events.safeDispatchEvent("peer:discovery",{detail:N})}}),t.connectionProtector!=null&&this.configureComponent("connectionProtector",t.connectionProtector(a)),this.components.upgrader=new Yv(this.components,{connectionEncrypters:(t.connectionEncrypters??[]).map((A,N)=>this.configureComponent(`connection-encryption-${N}`,A(this.components))),streamMuxers:(t.streamMuxers??[]).map((A,N)=>this.configureComponent(`stream-muxers-${N}`,A(this.components))),inboundUpgradeTimeout:(p=t.connectionManager)==null?void 0:p.inboundUpgradeTimeout,inboundStreamProtocolNegotiationTimeout:(g=t.connectionManager)==null?void 0:g.inboundStreamProtocolNegotiationTimeout,outboundStreamProtocolNegotiationTimeout:(y=t.connectionManager)==null?void 0:y.outboundStreamProtocolNegotiationTimeout,connectionCloseTimeout:(m=t.connectionManager)==null?void 0:m.connectionCloseTimeout}),this.configureComponent("transportManager",new Kv(this.components,t.transportManager)),this.configureComponent("connectionManager",new kv(this.components,t.connectionManager)),((_=t.connectionMonitor)==null?void 0:_.enabled)!==!1&&this.configureComponent("connectionMonitor",new Fv(this.components,t.connectionMonitor)),this.configureComponent("registrar",new qv(this.components)),this.configureComponent("addressManager",new A1(this.components,t.addresses));const c=(t.peerRouters??[]).map((A,N)=>this.configureComponent(`peer-router-${N}`,A(this.components)));this.peerRouting=this.components.peerRouting=this.configureComponent("peerRouting",new Uv(this.components,{routers:c}));const l=(t.contentRouters??[]).map((A,N)=>this.configureComponent(`content-router-${N}`,A(this.components)));if(this.contentRouting=this.components.contentRouting=this.configureComponent("contentRouting",new Ov(this.components,{routers:l})),this.configureComponent("randomWalk",new zv(this.components)),(t.peerDiscovery??[]).forEach((A,N)=>{this.configureComponent(`peer-discovery-${N}`,A(this.components)).addEventListener("peer",L=>{O(this,Un,Zo).call(this,L)})}),(x=t.transports)==null||x.forEach((A,N)=>{this.components.transportManager.add(this.configureComponent(`transport-${N}`,A(this.components)))}),t.services!=null)for(const A of Object.keys(t.services)){const N=t.services[A],R=N(this.components);if(R==null){this.log.error("service factory %s returned null or undefined instance",A);continue}this.services[A]=R,this.configureComponent(A,R),R[Ja]!=null&&(this.log("registering service %s for content routing",A),l.push(R[Ja])),R[tc]!=null&&(this.log("registering service %s for peer routing",A),c.push(R[tc])),R[ec]!=null&&(this.log("registering service %s for peer discovery",A),(C=(E=R[ec]).addEventListener)==null||C.call(E,"peer",L=>{O(this,Un,Zo).call(this,L)}))}q1(a)}configureComponent(t,n){return n==null&&this.log.error("component %s was null or undefined",t),this.components[t]=n,n}async start(){var t,n,s,i;if(this.status==="stopped"){this.status="starting",this.log("libp2p is starting");try{await((n=(t=this.components).beforeStart)==null?void 0:n.call(t)),await this.components.start(),await((i=(s=this.components).afterStart)==null?void 0:i.call(s)),this.status="started",this.safeDispatchEvent("start",{detail:this}),this.log("libp2p has started with peer id %p",this.peerId)}catch(o){throw this.log.error("an error occurred starting libp2p - %e",o),this.status="started",await this.stop(),o}}}async stop(){var t,n,s,i;this.status==="started"&&(this.log("libp2p is stopping"),this.status="stopping",await((n=(t=this.components).beforeStop)==null?void 0:n.call(t)),await this.components.stop(),await((i=(s=this.components).afterStop)==null?void 0:i.call(s)),this.status="stopped",this.safeDispatchEvent("stop",{detail:this}),this.log("libp2p has stopped"))}getConnections(t){return this.components.connectionManager.getConnections(t)}getDialQueue(){return this.components.connectionManager.getDialQueue()}getPeers(){const t=new Mr;for(const n of this.components.connectionManager.getConnections())t.add(n.remotePeer);return Array.from(t)}async dial(t,n={}){return this.components.connectionManager.openConnection(t,{priority:75,...n})}async dialProtocol(t,n,s={}){if(n==null)throw new Z("no protocols were provided to open a stream");if(n=Array.isArray(n)?n:[n],n.length===0)throw new Z("no protocols were provided to open a stream");return this.components.connectionManager.openStream(t,n,s)}getMultiaddrs(){return this.components.addressManager.getAddresses()}getProtocols(){return this.components.registrar.getProtocols()}async hangUp(t,n={}){var s;xi(t)&&(t=Kr(((s=t.getComponents().findLast(i=>i.code===Q))==null?void 0:s.value)??"")),await this.components.connectionManager.closeConnections(t,n)}async getPublicKey(t,n={}){if(this.log("getPublicKey %p",t),t.publicKey!=null)return t.publicKey;try{const a=await this.peerStore.get(t,n);if(a.id.publicKey!=null)return a.id.publicKey}catch(a){if(a.name!=="NotFoundError")throw a}const s=Ur([W("/pk/"),t.toMultihash().bytes]),i=await this.contentRouting.get(s,n),o=Ea(i);return await this.peerStore.patch(t,{publicKey:o},n),o}async handle(t,n,s){Array.isArray(t)||(t=[t]),await Promise.all(t.map(async i=>{await this.components.registrar.handle(i,n,s)}))}async unhandle(t,n){Array.isArray(t)||(t=[t]),await Promise.all(t.map(async s=>{await this.components.registrar.unhandle(s,n)}))}async register(t,n,s){return this.components.registrar.register(t,n,s)}unregister(t){this.components.registrar.unregister(t)}use(t,n){this.components.registrar.use(t,Array.isArray(n)?n:[n])}unuse(t){this.components.registrar.unuse(t)}async isDialable(t,n={}){return this.components.connectionManager.isDialable(t,n)}}Un=new WeakSet,Zo=function(t){const{detail:n}=t;if(n.id.toString()===this.peerId.toString()){this.log.error("peer discovery mechanism discovered self");return}this.components.peerStore.merge(n.id,{multiaddrs:n.multiaddrs}).catch(s=>{this.log.error("could not update multiaddrs of discovered peer - %e",s)})};async function zx(r={}){r.privateKey??(r.privateKey=await S0("Ed25519"));const e=new Jv({...await Zw(r),peerId:D0(r.privateKey)});return r.start!==!1&&await e.start(),e}export{lx as $,Ee as A,Kr as B,ue as C,Ku as D,ed as E,Sn as F,xa as G,mo as H,zu as I,Dx as J,Fn as K,Ws as L,Ao as M,ho as N,cd as O,Ww as P,yx as Q,ti as R,Q as S,zo as T,Ox as U,ir as V,cl as W,ql as X,or as Y,zr as Z,ee as _,gt as a,Eh as a$,pi as a0,Ct as a1,cx as a2,Ie as a3,ce as a4,nf as a5,Px as a6,dh as a7,qa as a8,fh as a9,Qe as aA,hh as aB,ii as aC,Ko as aD,ru as aE,Qo as aF,bo as aG,Ge as aH,Er as aI,$u as aJ,me as aK,he as aL,Aa as aM,Ux as aN,nu as aO,en as aP,el as aQ,Dn as aR,tu as aS,Wu as aT,oe as aU,fE as aV,ph as aW,jn as aX,$a as aY,ai as aZ,Rx as a_,Ix as aa,Ax as ab,Nx as ac,Ou as ad,Hu as ae,Tt as af,ff as ag,kx as ah,zc as ai,Ol as aj,ra as ak,ot as al,le as am,It as an,Yn as ao,rc as ap,Wb as aq,Dr as ar,ud as as,fd as at,ld as au,dd as av,kr as aw,_x as ax,ox as ay,He as az,hi as b,vh as b0,ps as b1,ec as b2,mh as b3,gh as b4,Oe as b5,Wn as b6,$v as b7,rf as b8,Mr as b9,$b as ba,jo as bb,En as bc,_n as bd,Js as be,Qc as bf,Yc as bg,bE as bh,$o as bi,Fx as bj,$x as bk,Mx as bl,hx as bm,gx as bn,_d as bo,zx as bp,Ms as bq,dx as br,S0 as bs,fx as bt,uh as bu,Ur as c,ht as d,zp as e,W as f,Fu as g,mx as h,Se as i,_0 as j,Jn as k,Ia as l,mt as m,Gw as n,vi as o,Ea as p,ux as q,qn as r,ax as s,X as t,Ja as u,tc as v,Gr as w,Xe as x,wn as y,Z as z};
